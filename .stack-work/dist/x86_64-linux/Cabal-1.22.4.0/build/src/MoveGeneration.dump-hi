
==================== FINAL INTERFACE ====================
2016-01-06 14:29:57.036532 UTC

interface hches_3PXdSEAhhp2JIrhYvA7RvZ:MoveGeneration 7102
  interface hash: 41b5a070534af6dc690e6e3210bd796a
  ABI hash: ce1d02882b6ddd45bc070e1ba131e4f0
  export-list hash: 1f99f8eb6a68e1c4b2e8b815849b3aac
  orphan hash: bd31b17a8881193e8b8ddc61b3c2b309
  flag hash: 2bfdd69c509df0f94c327e5faec9ae27
  sig of: Nothing
  used TH splices: False
  where
exports:
  MoveGeneration.bishopMovement
  MoveGeneration.expandBitBoard
  MoveGeneration.gEnPassant
  MoveGeneration.gIndexGen
  MoveGeneration.gPawnGen
  MoveGeneration.gPawnPromotion
  MoveGeneration.gPawnPushAndAttack
  MoveGeneration.genPromotions
  MoveGeneration.generateMoves
  MoveGeneration.inCheck
  MoveGeneration.indexedBitBoard
  MoveGeneration.indexedOnly
  MoveGeneration.kingMovement
  MoveGeneration.knightMovement
  MoveGeneration.pawnMovement
  MoveGeneration.queenMovement
  MoveGeneration.rookMovement
  MoveGeneration.serializeBitBoard
module dependencies: BitBoard Board FEN Index Masks MoveTables
                     MoveTypes
package dependencies: ansi-terminal-0.6.2.3@ansit_KW0LUY2zB7JCYzE4ZYrwBg
                      ansi-wl-pprint-0.6.7.3@ansiw_KPlSW7tbqXS51Lj59n3FC4
                      array-0.5.1.0@array_E0sTtauuKsGDLZoT7lTbgZ
                      attoparsec-0.13.0.1@attop_FtJZAZu3GDOJSwmSRnXnPH base-4.8.1.0
                      binary-0.7.5.0@binar_IvYoLp9H6Xy3zEH13MmZwd
                      bool-extras-0.4.0@boole_GdoTyzdjqQqAeS3KnmOc2Q
                      bytestring-0.10.6.0@bytes_6elQVSg5cWdFrvRnfxTUrH
                      containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN
                      deepseq-1.4.1.1@deeps_LbCWUlehDDeLxurARKDH5o ghc-prim-0.4.0.0
                      hashable-1.2.3.3@hasha_2GTZqecVp8NJZrNuKzGxfy integer-gmp-1.0.0.0
                      pretty-1.1.2.0@prett_7UQTOB05U7lIYPkFOVraeR
                      primitive-0.6.1.0@primi_5Jnw7oEuYtM9dmKXelGXVb
                      scientific-0.3.4.4@scien_03wvk1zJytY0wVzR42F1U4
                      template-haskell-2.10.0.0 text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh
                      transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X
                      vector-th-unbox-0.2.1.3@vecto_7UKBkJbwJOEKV3lSwERBE0
                      vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF
orphans: attoparsec-0.13.0.1@attop_FtJZAZu3GDOJSwmSRnXnPH:Data.Attoparsec.ByteString.Char8
         base-4.8.1.0:GHC.Base base-4.8.1.0:GHC.Float
         binary-0.7.5.0@binar_IvYoLp9H6Xy3zEH13MmZwd:Data.Binary.Generic
         bytestring-0.10.6.0@bytes_6elQVSg5cWdFrvRnfxTUrH:Data.ByteString.Builder
         hashable-1.2.3.3@hasha_2GTZqecVp8NJZrNuKzGxfy:Data.Hashable.Generic
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Lazy
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Show
         transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X:Control.Monad.Trans.Error
         vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector.Fusion.Bundle
         vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector.Unboxed
family instance modules: attoparsec-0.13.0.1@attop_FtJZAZu3GDOJSwmSRnXnPH:Data.Attoparsec.Internal.Types
                         base-4.8.1.0:Control.Applicative base-4.8.1.0:Data.Either
                         base-4.8.1.0:Data.Functor.Identity base-4.8.1.0:Data.Monoid
                         base-4.8.1.0:Data.Type.Equality base-4.8.1.0:Data.Void
                         base-4.8.1.0:GHC.Exts base-4.8.1.0:GHC.Generics
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntMap.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntSet.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Map.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Sequence
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Set.Base
                         hches_3PXdSEAhhp2JIrhYvA7RvZ:MoveTypes
                         pretty-1.1.2.0@prett_7UQTOB05U7lIYPkFOVraeR:Text.PrettyPrint.HughesPJ
                         primitive-0.6.1.0@primi_5Jnw7oEuYtM9dmKXelGXVb:Control.Monad.Primitive
                         template-haskell-2.10.0.0:Language.Haskell.TH.Syntax
                         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text
                         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Lazy
                         vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector
                         vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector.Primitive
                         vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector.Unboxed
                         vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector.Unboxed.Base
import  -/  base-4.8.1.0:Control.Monad.ST 8106edce31e42c95a9fdb099a8903634
import  -/  base-4.8.1.0:Data.Bits 5341167fdd5958c2b3f0dac8924f1efd
import  -/  base-4.8.1.0:Data.Bool ca042538fb71252dd8e7a494efe2ad9e
import  -/  base-4.8.1.0:Data.Word 448c480b98a0c18988a37db5ab829b22
import  -/  base-4.8.1.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.1.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.1.0:GHC.Word ef6286c279d61931eb675109b4b93579
import  -/  base-4.8.1.0:Prelude 518f762991bc287d78f21a73c974da1f
import  -/  bool-extras-0.4.0@boole_GdoTyzdjqQqAeS3KnmOc2Q:Data.Bool.Extras 1c40d801968a12a7749b9e1cb7a3e7e2
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  BitBoard 1d34c765e2913aef164a6d247daf4736
  exports: 6eb44feaf65c4fa3bf03a262b000e28d
  All 0de8f551b6e917ca64ced26c26f4402b
  AllColors 2ae40172b6bd1c78ff99d52a092b989a
  AllColors bd3c928fdda9b2653a392ef5b2ba3f68
  Bishops a15afab21984376fcca9e854bca44382
  BitBoard 3518c7b888c6b59ff7203e4eadbc3ec2
  Knights b80987aae7cdfda9940945ebe8072565
  Pawns 4d2284a49846d7b07867d0fc910e2a9e
  Queens 9629fd7bec6a90730f751c886daf3175
  Rooks 3d3676956b7b8e76653873bd1127c4ef
import  -/  Board 39873f4ed53528af07e0b2ad9994c225
  exports: 4f7b98092ef87ef50bc5f50b83e780d6
  Board 1ffa6443c43038ccbc7b40dad1d4f199
  Board 458dfcc1aefda7aa0429ea905d2402da
import  -/  FEN faec11b9a63df206767d39b5afe70cab
  exports: 8539ee7adba37556989bad8e5d089858
  Black 4901c8d3ecfdb9ff396e00f95b99dc63
  Castling a96f19b49cc3cc46d2d398a533fb5126
  Castling 444c72f692ba7b0ccd917726e94249b7
  Turn b0d8b799572cdc0afc9568575422153c
  White 86850bce68ce7577bc5ff79181e8b07d
import  -/  Index d8cad232a279cafde9ae933a407e67d2
  exports: f2069996af848e99f6e14ee9d6b1f04e
  Index 5c8ceb59f924ec508c7fc4cbb0c05d15
import  -/  Masks 55c4d56f50ab20ffacfc1a39cdfbd49c
  exports: feaf700f129259df1ad72dc0703830d7
  Mask f38957cdd0de556bb5e3c58d439fe9ff
import  -/  MoveTables 9cba8bf51b8271cc35d6054726b13b21
  exports: 5c6462c384f95468fbdd7b31dbfe5421
  Attacks 0ea9ae003cd173ef676b5f96438ff46e
  kingAttack 12ec1a7e361bca4147f6678a0d5e359f
  knightAttack 288980a0710a8073e859740de0a1bf2a
  pawnAttackB 2d06795a3fe097bcc8e268117128239c
  pawnAttackW 8202b60af84ce7fb3a7d09e0df1a2b79
import  -/  MoveTypes af3194be44047c2d3b912109768e02c7
  exports: 30f47618c7224af3cabbf9f4bcec13bb
  EnPassantA 0a98aa17fb6f4ce24e3182e86341db1f
  KingM 2fcd72edc8098e89a3672dce93469314
  KnightM 01671b71c82e508f0f62b9c6a394cfcf
  Move a1d0cc74d2c86eee37c6c3f3d072a07a
  Move b13936b6226fe6ee038902e83e9bea5b
  MoveData 16c1819e512d6046846f2570c0139b5c
  Moves 5961b9d8b781221e3276aa7c1c878959
  PawnA 703eac96f15695a4347fc8ff7f322135
  SinglePush 6d33059453b52242d93b63b296446b14
import  -/  vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector.Unboxed 8bd91cd1a3cd2cbd12faec978422ccd8
import  -/  vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector.Unboxed.Base 0761e27d6792efb778c5ac79292248a5
import  -/  vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector.Unboxed.Mutable d0342434d0f49e690fa796e53c38e521
1cd6812cc0de0f4ae9c1754246bdc87f
  $s!_$slength ::
    Data.Vector.Unboxed.Base.Vector GHC.Word.Word64 -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(A,U,A)>m,
     Inline: [NEVER] -}
15ce5c285204ba140793269c4675fa2d
  $w$sexpandBitBoard ::
    (GHC.Word.Word64 -> (GHC.Types.Int, GHC.Word.Word64))
    -> GHC.Prim.Word#
    -> Data.Vector.Unboxed.Base.Vector (GHC.Types.Int, GHC.Word.Word64)
  {- Arity: 2, Strictness: <L,C(U(1*U(U),1*U(U)))><S,U>,
     Inline: INLINE[0] -}
acba154d54c94c8a21d3552d963c49dd
  $w$sexpandBitBoard1 ::
    (GHC.Word.Word64 -> MoveTypes.Move)
    -> GHC.Prim.Word# -> Data.Vector.Unboxed.Base.Vector MoveTypes.Move
  {- Arity: 2, Strictness: <L,C(U(U,U,U))><S,U>, Inline: INLINE[0] -}
ddb2e9ceb6d740cbabade78f16c9b565
  $w$sexpandBitBoard2 ::
    (GHC.Word.Word64 -> GHC.Types.Int)
    -> GHC.Prim.Word# -> Data.Vector.Unboxed.Base.Vector GHC.Types.Int
  {- Arity: 2, Strictness: <L,C(U(U))><S,U>, Inline: INLINE[0],
     Unfolding: (\ w :: GHC.Word.Word64 -> GHC.Types.Int
                   ww :: GHC.Prim.Word# ->
                 GHC.ST.runSTRep
                   @ (Data.Vector.Unboxed.Base.Vector GHC.Types.Int)
                   (\ @ s s1 :: GHC.Prim.State# s[OneShot] ->
                    let {
                      x1 :: GHC.Prim.Int# = GHC.Prim.word2Int# (GHC.Prim.popCnt64# ww)
                    } in
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.>=# x1 0) of wild2 {
                      GHC.Types.False
                      -> case MoveGeneration.expandBitBoard5 @ s x1
                         ret_ty (# GHC.Prim.State# s,
                                   Data.Vector.Unboxed.Base.Vector GHC.Types.Int #)
                         of {}
                      GHC.Types.True
                      -> case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.<# x1 0) of wild1 {
                           GHC.Types.False
                           -> case GHC.Classes.divInt#
                                     9223372036854775807
                                     8 of ww4 { DEFAULT ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.># x1 ww4) of wild3 {
                                GHC.Types.False
                                -> case GHC.Prim.newByteArray#
                                          @ (Control.Monad.Primitive.PrimState (GHC.ST.ST s))
                                          (GHC.Prim.*# x1 8)
                                          s1
                                            `cast`
                                          (GHC.Prim.State#
                                             (Sym (Control.Monad.Primitive.TFCo:R:PrimStateST[0]
                                                       <s>_N)))_R of ds1 { (#,#) ipv ipv1 ->
                                   case {__pkg_ccall primitive-0.6.1.0@primi_5Jnw7oEuYtM9dmKXelGXVb hsprimitive_memset_Word8 forall s.
                                                                                                                             GHC.Prim.MutableByteArray#
                                                                                                                               s
                                                                                                                             -> GHC.Prim.Int#
                                                                                                                             -> GHC.Prim.Word#
                                                                                                                             -> GHC.Prim.Word#
                                                                                                                             -> GHC.Prim.State#
                                                                                                                                  GHC.Prim.RealWorld
                                                                                                                             -> (# GHC.Prim.State#
                                                                                                                                     GHC.Prim.RealWorld #)}
                                          @ (Control.Monad.Primitive.PrimState (GHC.ST.ST s))
                                          ipv1
                                          0
                                          (GHC.Prim.int2Word# (GHC.Prim.*# x1 8))
                                          __word 0
                                          ipv
                                            `cast`
                                          (GHC.Prim.State#
                                             (Control.Monad.Primitive.TFCo:R:PrimStateST[0]
                                                  (Trans
                                                       (Sym (Control.Monad.Primitive.TFCo:R:PrimStateST[0]
                                                                 <s>_N))
                                                       (UnivCo mkUnsafeCo nominal (Control.Monad.Primitive.PrimState
                                                                                     (GHC.ST.ST
                                                                                        s)) GHC.Prim.RealWorld))))_R of wild { (##) ds8 ->
                                   letrec {
                                     $wa :: GHC.Types.Int
                                            -> GHC.Prim.Word#
                                            -> Data.Vector.Unboxed.Base.MVector
                                                 (Control.Monad.Primitive.PrimState (GHC.ST.ST s))
                                                 GHC.Types.Int
                                            -> GHC.Prim.State# s
                                            -> (# GHC.Prim.State# s,
                                                  Data.Vector.Unboxed.Base.MVector
                                                    (Control.Monad.Primitive.PrimState
                                                       (GHC.ST.ST s))
                                                    GHC.Types.Int #)
                                       {- Arity: 4, Strictness: <L,1*U(U)><S,1*U><L,U(U,U,U)><L,U>,
                                          Inline: [0] -}
                                     = \ w1 :: GHC.Types.Int
                                         ww1 :: GHC.Prim.Word#
                                         w2 :: Data.Vector.Unboxed.Base.MVector
                                                 (Control.Monad.Primitive.PrimState (GHC.ST.ST s))
                                                 GHC.Types.Int
                                         w3 :: GHC.Prim.State# s[OneShot] ->
                                       case ww1 of wild4 {
                                         DEFAULT
                                         -> case w1 of wild5 { GHC.Types.I# x2 ->
                                            case GHC.Prim.tagToEnum#
                                                   @ GHC.Types.Bool
                                                   (GHC.Prim.>=# x2 0) of wild6 {
                                              GHC.Types.False
                                              -> case w2
                                                        `cast`
                                                      (Trans
                                                           (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                                     <Control.Monad.Primitive.PrimState
                                                                        (GHC.ST.ST s)>_N))
                                                           (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                                                <Control.Monad.Primitive.PrimState
                                                                   (GHC.ST.ST
                                                                      s)>_N)) of wild7 { Data.Vector.Primitive.Mutable.MVector dt dt1 dt2 ->
                                                 case MoveGeneration.expandBitBoard4 @ s dt1 x2
                                                 ret_ty (# GHC.Prim.State# s,
                                                           Data.Vector.Unboxed.Base.MVector
                                                             (Control.Monad.Primitive.PrimState
                                                                (GHC.ST.ST s))
                                                             GHC.Types.Int #)
                                                 of {} }
                                              GHC.Types.True
                                              -> case w2
                                                        `cast`
                                                      (Trans
                                                           (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                                     <Control.Monad.Primitive.PrimState
                                                                        (GHC.ST.ST s)>_N))
                                                           (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                                                <Control.Monad.Primitive.PrimState
                                                                   (GHC.ST.ST
                                                                      s)>_N)) of wild7 { Data.Vector.Primitive.Mutable.MVector dt dt1 dt2 ->
                                                 case GHC.Prim.tagToEnum#
                                                        @ GHC.Types.Bool
                                                        (GHC.Prim.<# x2 dt1) of wild8 {
                                                   GHC.Types.False
                                                   -> case MoveGeneration.expandBitBoard4 @ s dt1 x2
                                                      ret_ty (# GHC.Prim.State# s,
                                                                Data.Vector.Unboxed.Base.MVector
                                                                  (Control.Monad.Primitive.PrimState
                                                                     (GHC.ST.ST s))
                                                                  GHC.Types.Int #)
                                                      of {}
                                                   GHC.Types.True
                                                   -> case w (GHC.Word.W64#
                                                                (GHC.Prim.and#
                                                                   wild4
                                                                   (GHC.Prim.int2Word#
                                                                      (GHC.Prim.negateInt#
                                                                         (GHC.Prim.word2Int#
                                                                            wild4))))) of wild9 { GHC.Types.I# x# ->
                                                      case GHC.Prim.writeIntArray#
                                                             @ (Control.Monad.Primitive.PrimState
                                                                  (GHC.ST.ST s))
                                                             dt2
                                                             (GHC.Prim.+# dt x2)
                                                             x#
                                                             w3
                                                               `cast`
                                                             (GHC.Prim.State#
                                                                (Sym (Control.Monad.Primitive.TFCo:R:PrimStateST[0]
                                                                          <s>_N)))_R of s'# { DEFAULT ->
                                                      $wa
                                                        (GHC.Types.I# (GHC.Prim.+# x2 1))
                                                        (GHC.Prim.and#
                                                           wild4
                                                           (GHC.Prim.minusWord# wild4 __word 1))
                                                        wild7
                                                          `cast`
                                                        (Trans
                                                             (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                                                       <Control.Monad.Primitive.PrimState
                                                                          (GHC.ST.ST s)>_N))
                                                             (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                                            <Control.Monad.Primitive.PrimState
                                                                               (GHC.ST.ST s)>_N))))
                                                        s'#
                                                          `cast`
                                                        (GHC.Prim.State#
                                                           (Control.Monad.Primitive.TFCo:R:PrimStateST[0]
                                                                <s>_N))_R } } } } } }
                                         __word 0
                                         -> (GHC.ST.$w$cpure
                                               @ s
                                               GHC.Prim.void#
                                               @ (Data.Vector.Unboxed.Base.MVector
                                                    (Control.Monad.Primitive.PrimState
                                                       (GHC.ST.ST s))
                                                    GHC.Types.Int)
                                               w2)
                                              `cast`
                                            (GHC.ST.NTCo:ST[0]
                                                 <s>_N
                                                 <Data.Vector.Unboxed.Base.MVector
                                                    (Control.Monad.Primitive.PrimState
                                                       (GHC.ST.ST s))
                                                    GHC.Types.Int>_R)
                                              w3 }
                                   } in
                                   case ($wa
                                           MoveGeneration.expandBitBoard3
                                           ww
                                           (Data.Vector.Primitive.Mutable.MVector
                                              @ (Control.Monad.Primitive.PrimState (GHC.ST.ST s))
                                              @ GHC.Types.Int
                                              0
                                              x1
                                              ipv1)
                                             `cast`
                                           (Trans
                                                (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                                          <Control.Monad.Primitive.PrimState
                                                             (GHC.ST.ST s)>_N))
                                                (Trans
                                                     (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                                    <Control.Monad.Primitive.PrimState
                                                                       (GHC.ST.ST s)>_N)))
                                                     (Data.Vector.Unboxed.Base.MVector
                                                        (Control.Monad.Primitive.TFCo:R:PrimStateST[0]
                                                             (Sym (Control.Monad.Primitive.TFCo:R:PrimStateST[0]
                                                                       <s>_N)))
                                                        <GHC.Types.Int>_N)_R))
                                           ds8
                                             `cast`
                                           (GHC.Prim.State#
                                              (Trans
                                                   (UnivCo mkUnsafeCo nominal GHC.Prim.RealWorld (Control.Monad.Primitive.PrimState
                                                                                                    (GHC.ST.ST
                                                                                                       s)))
                                                   (Control.Monad.Primitive.TFCo:R:PrimStateST[0]
                                                        <s>_N)))_R)
                                          `cast`
                                        ((# <GHC.Prim.State# s>_R,
                                            Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MutableVector[0])) (Control.Monad.Primitive.TFCo:R:PrimStateST[0]
                                                                                                              <s>_N) <GHC.Types.Int>_N #))_R of ds2 { (#,#) ipv2 ipv3 ->
                                   case ipv3
                                          `cast`
                                        (Trans
                                             (Sub (Data.Vector.Unboxed.Base.TFCo:R:MutableVector[0]) (Sym (Control.Monad.Primitive.TFCo:R:PrimStateST[0]
                                                                                                               <s>_N)) <GHC.Types.Int>_N)
                                             (Trans
                                                  (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                            <Control.Monad.Primitive.PrimState
                                                               (GHC.ST.ST s)>_N))
                                                  (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                                       <Control.Monad.Primitive.PrimState
                                                          (GHC.ST.ST
                                                             s)>_N))) of wild4 { Data.Vector.Primitive.Mutable.MVector dt dt1 dt2 ->
                                   case GHC.Prim.unsafeFreezeByteArray#
                                          @ (Control.Monad.Primitive.PrimState (GHC.ST.ST s))
                                          dt2
                                          ipv2
                                            `cast`
                                          (GHC.Prim.State#
                                             (Sym (Control.Monad.Primitive.TFCo:R:PrimStateST[0]
                                                       <s>_N)))_R of ds3 { (#,#) ipv4 ipv5 ->
                                   (# ipv4
                                        `cast`
                                      (GHC.Prim.State#
                                         (Control.Monad.Primitive.TFCo:R:PrimStateST[0] <s>_N))_R,
                                      (Data.Vector.Primitive.Vector @ GHC.Types.Int dt dt1 ipv5)
                                        `cast`
                                      (Trans
                                           (Sym (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0]))
                                           (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0])))) #) } } } } }
                                GHC.Types.True
                                -> case MoveGeneration.expandBitBoard2 @ s x1
                                   ret_ty (# GHC.Prim.State# s,
                                             Data.Vector.Unboxed.Base.Vector GHC.Types.Int #)
                                   of {} } }
                           GHC.Types.True
                           -> case MoveGeneration.expandBitBoard1 @ s x1
                              ret_ty (# GHC.Prim.State# s,
                                        Data.Vector.Unboxed.Base.Vector GHC.Types.Int #)
                              of {} } })) -}
d6edf3a146e984e931e3a5962c1c3ce0
  $wexpandBitBoard ::
    Data.Vector.Unboxed.Base.Unbox a =>
    (GHC.Word.Word64 -> a)
    -> GHC.Prim.Word# -> Data.Vector.Unboxed.Base.Vector a
  {- Arity: 3,
     Strictness: <S(S(LC(C(S))LLLLLL)S),U(1*U(A,1*C1(C1(U)),A,A,A,A,A,A),U)><L,C(U)><S,U>,
     Inline: [0] -}
24ca1e2ddde54f3e74cdf95cf5ac4679
  $wgIndexGen ::
    (Index.Index -> (Index.Index, GHC.Word.Word64))
    -> MoveTypes.MoveData
    -> GHC.Prim.Word#
    -> Data.Vector.Unboxed.Base.Vector MoveTypes.Move
  {- Arity: 3, Strictness: <L,C(U(1*U(U),1*U(U)))><L,U(U)><S,U>,
     Inline: [0] -}
c6ed26930db940b8e7e71edc3440de2c
  $wgPawnGen ::
    ((Index.Index, GHC.Word.Word64) -> (Index.Index, GHC.Word.Word64))
    -> MoveTypes.MoveData
    -> GHC.Prim.Word#
    -> Data.Vector.Unboxed.Base.Vector MoveTypes.Move
  {- Arity: 3, Strictness: <L,C(U(1*U(U),1*U(U)))><L,U(U)><S,U>,
     Inline: [0] -}
dd329d6999a703e44103644a748251ef
  $wgPawnPromotion ::
    (GHC.Word.Word64 -> GHC.Word.Word64)
    -> MoveTables.Attacks
    -> Masks.Mask
    -> GHC.Prim.Word#
    -> Data.Vector.Unboxed.Base.Vector MoveTypes.Move
  {- Arity: 4, Strictness: <L,1*C1(U(U))><L,U(U,U,U)><L,1*U(U)><S,U>,
     Inline: [0],
     Unfolding: (\ w :: GHC.Word.Word64 -> GHC.Word.Word64
                   w1 :: MoveTables.Attacks
                   w2 :: Masks.Mask
                   ww :: GHC.Prim.Word# ->
                 case (MoveGeneration.$w$sexpandBitBoard
                         MoveGeneration.gPawnPromotion3
                         ww)
                        `cast`
                      (Sub (Data.Vector.Unboxed.Base.TFCo:R:Vector(,)[0]
                                <GHC.Types.Int>_N
                                <GHC.Word.Word64>_N)) of nt { Data.Vector.Unboxed.Base.V_2 ipv ipv1 ipv2 ->
                 case ipv1
                        `cast`
                      (Trans
                           (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))
                           (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0])) of wild { Data.Vector.Primitive.Vector dt dt1 dt2 ->
                 case ipv2
                        `cast`
                      (Trans
                           (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorWord64[0]))
                           (Data.Vector.Unboxed.Base.NTCo:R:VectorWord64[0])) of wild1 { Data.Vector.Primitive.Vector dt4 dt5 dt6 ->
                 GHC.ST.runSTRep
                   @ (Data.Vector.Unboxed.Base.Vector MoveTypes.Move)
                   (\ @ s s1 :: GHC.Prim.State# s[OneShot] ->
                    case GHC.Classes.divInt# 9223372036854775807 1 of ww4 { DEFAULT ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.># 0 ww4) of wild3 {
                      GHC.Types.False
                      -> case GHC.Prim.newByteArray#
                                @ (Control.Monad.Primitive.PrimState (GHC.ST.ST s))
                                0
                                s1
                                  `cast`
                                (GHC.Prim.State#
                                   (Sym (Control.Monad.Primitive.TFCo:R:PrimStateST[0]
                                             <s>_N)))_R of ds1 { (#,#) ipv3 ipv4 ->
                         case GHC.Classes.divInt# 9223372036854775807 8 of ww1 { DEFAULT ->
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># 0 ww1) of wild2 {
                           GHC.Types.False
                           -> case GHC.Prim.newByteArray#
                                     @ (Control.Monad.Primitive.PrimState (GHC.ST.ST s))
                                     0
                                     ipv3 of ds2 { (#,#) ipv5 ipv6 ->
                              case GHC.Prim.newByteArray#
                                     @ (Control.Monad.Primitive.PrimState (GHC.ST.ST s))
                                     0
                                     ipv5 of ds3 { (#,#) ipv7 ipv8 ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# 0 ipv) of wild4 {
                                GHC.Types.False
                                -> case GHC.Prim.indexWord64Array# dt6 dt4 of wild5 { DEFAULT ->
                                   case w (GHC.Word.W64# wild5) of wild6 { GHC.Word.W64# x# ->
                                   case w2 of wild7 { GHC.Word.W64# x#1 ->
                                   case GHC.Prim.indexIntArray# dt2 dt of wild8 { DEFAULT ->
                                   case case GHC.Prim.tagToEnum#
                                               @ GHC.Types.Bool
                                               (GHC.Prim.>=# wild8 0) of wild9 {
                                          GHC.Types.False
                                          -> case MoveGeneration.$s!_$slength
                                                    w1 of wild10 { GHC.Types.I# n# ->
                                             MoveGeneration.gEnPassant1 wild8 n# }
                                          GHC.Types.True
                                          -> case MoveGeneration.$s!_$slength
                                                    w1 of wild10 { GHC.Types.I# y ->
                                             case GHC.Prim.tagToEnum#
                                                    @ GHC.Types.Bool
                                                    (GHC.Prim.<# wild8 y) of wild11 {
                                               GHC.Types.False -> MoveGeneration.gEnPassant1 wild8 y
                                               GHC.Types.True
                                               -> case w1
                                                         `cast`
                                                       (Trans
                                                            (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorWord64[0]))
                                                            (Data.Vector.Unboxed.Base.NTCo:R:VectorWord64[0])) of wild12 { Data.Vector.Primitive.Vector dt7 dt8 dt9 ->
                                                  case GHC.Prim.indexWord64Array#
                                                         dt9
                                                         (GHC.Prim.+#
                                                            dt7
                                                            wild8) of wild13 { DEFAULT ->
                                                  GHC.Word.W64#
                                                    (GHC.Prim.or#
                                                       x#
                                                       (GHC.Prim.and#
                                                          x#1
                                                          wild13)) } } } } } of b { GHC.Word.W64# ipv9 ->
                                   case GHC.Err.undefined
                                   ret_ty (# GHC.Prim.State# s,
                                             Data.Vector.Unboxed.Base.Vector MoveTypes.Move #)
                                   of {} } } } } }
                                GHC.Types.True
                                -> case GHC.Prim.unsafeFreezeByteArray#
                                          @ (Control.Monad.Primitive.PrimState (GHC.ST.ST s))
                                          ipv4
                                          ipv7 of ds4 { (#,#) ipv9 ipv10 ->
                                   case GHC.Prim.unsafeFreezeByteArray#
                                          @ (Control.Monad.Primitive.PrimState (GHC.ST.ST s))
                                          ipv6
                                          ipv9 of ds5 { (#,#) ipv11 ipv12 ->
                                   case GHC.Prim.unsafeFreezeByteArray#
                                          @ (Control.Monad.Primitive.PrimState (GHC.ST.ST s))
                                          ipv8
                                          ipv11 of ds6 { (#,#) ipv13 ipv14 ->
                                   (# ipv13
                                        `cast`
                                      (GHC.Prim.State#
                                         (Control.Monad.Primitive.TFCo:R:PrimStateST[0] <s>_N))_R,
                                      (Data.Vector.Unboxed.Base.V_3
                                         @ GHC.Word.Word8
                                         @ GHC.Types.Int
                                         @ GHC.Types.Int
                                         0
                                         (Data.Vector.Primitive.Vector @ GHC.Word.Word8 0 0 ipv10)
                                           `cast`
                                         (Trans
                                              (Sym (Data.Vector.Unboxed.Base.NTCo:R:VectorWord8[0]))
                                              (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:VectorWord8[0]))))
                                         (Data.Vector.Primitive.Vector @ GHC.Types.Int 0 0 ipv12)
                                           `cast`
                                         (Trans
                                              (Sym (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0]))
                                              (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))))
                                         (Data.Vector.Primitive.Vector @ GHC.Types.Int 0 0 ipv14)
                                           `cast`
                                         (Trans
                                              (Sym (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0]))
                                              (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0])))))
                                        `cast`
                                      (Trans
                                           (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:Vector(,,)[0]
                                                          <GHC.Word.Word8>_N
                                                          <GHC.Types.Int>_N
                                                          <GHC.Types.Int>_N)))
                                           (Trans
                                                (Sym (MoveTypes.NTCo:R:VectorMove[0]))
                                                (Sub (Sym (MoveTypes.TFCo:R:VectorMove[0]))))) #) } } } } } }
                           GHC.Types.True
                           -> case MoveGeneration.gPawnPromotion2
                              ret_ty (# GHC.Prim.State# s,
                                        Data.Vector.Unboxed.Base.Vector MoveTypes.Move #)
                              of {} } } }
                      GHC.Types.True
                      -> case MoveGeneration.gPawnPromotion1
                         ret_ty (# GHC.Prim.State# s,
                                   Data.Vector.Unboxed.Base.Vector MoveTypes.Move #)
                         of {} } }) } } }) -}
5a30fcce11ab6d8b43c17b9b5502f67a
  $wgPawnPushAndAttack ::
    (GHC.Word.Word64 -> GHC.Word.Word64)
    -> MoveTables.Attacks
    -> Masks.Mask
    -> GHC.Prim.Word#
    -> Data.Vector.Unboxed.Base.Vector MoveTypes.Move
  {- Arity: 4, Strictness: <L,C(U(U))><L,U(U,U,U)><L,U(U)><S,U>,
     Inline: [0] -}
c70ca578e5ab443dbef6ea728e502fd0
  $wgenerateMoves ::
    GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Types.Bool
    -> GHC.Types.Bool
    -> GHC.Types.Bool
    -> GHC.Types.Bool
    -> GHC.Base.Maybe Index.Index
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> MoveTypes.Moves
  {- Arity: 17,
     Strictness: <L,U><L,U><L,U><L,U><L,U><S,1*U><L,U><L,U><S,1*U><L,U><S,H><S,H><S,U><S,H><S,U><L,U><L,U>,
     Inline: [0] -}
7896c5c92951967c536612377a5b3f6c
  $wkingMovement ::
    GHC.Prim.Word#
    -> FEN.Castling
    -> Index.Index
    -> Index.Index
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> Data.Vector.Unboxed.Base.Vector MoveTypes.Move
  {- Arity: 6,
     Strictness: <S,1*U><L,1*U(1*H,1*H,U,1*H)><L,U(U)><L,U(U)><L,U><L,U>,
     Inline: [0] -}
dcfcac422034a98758f912a8a6824c94
  $wknightMovement ::
    GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> Data.Vector.Unboxed.Base.Vector MoveTypes.Move
  {- Arity: 5, Strictness: <S,1*U><L,U><L,U><L,U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Word#
                   ww1 :: GHC.Prim.Word#
                   ww2 :: GHC.Prim.Word#
                   ww3 :: GHC.Prim.Word#
                   ww4 :: GHC.Prim.Word# ->
                 case ww of wild8 {
                   DEFAULT -> MoveGeneration.knightMovement2
                   __word 0
                   -> let {
                        a1 :: GHC.Prim.Word#
                        = GHC.Prim.xor# ww3 __word 18446744073709551615
                      } in
                      MoveGeneration.$wgIndexGen
                        (\ i :: GHC.Types.Int ->
                         (i,
                          case i of wild1 { GHC.Types.I# x1 ->
                          case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.>=# x1 0) of wild2 {
                            GHC.Types.False
                            -> case MoveGeneration.knightMovement1 of wild3 { GHC.Types.I# n# ->
                               MoveGeneration.gEnPassant1 x1 n# }
                            GHC.Types.True
                            -> case MoveGeneration.knightMovement1 of wild3 { GHC.Types.I# y ->
                               case GHC.Prim.tagToEnum#
                                      @ GHC.Types.Bool
                                      (GHC.Prim.<# x1 y) of wild4 {
                                 GHC.Types.False -> MoveGeneration.gEnPassant1 x1 y
                                 GHC.Types.True
                                 -> case MoveTables.knightAttack
                                           `cast`
                                         (Trans
                                              (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorWord64[0]))
                                              (Data.Vector.Unboxed.Base.NTCo:R:VectorWord64[0])) of wild { Data.Vector.Primitive.Vector dt dt1 dt2 ->
                                    case GHC.Prim.indexWord64Array#
                                           dt2
                                           (GHC.Prim.+# dt x1) of wild7 { DEFAULT ->
                                    GHC.Word.W64# (GHC.Prim.and# a1 wild7) } } } } } }))
                        MoveTypes.$bKnightM1 `cast` (Sym (MoveTypes.NTCo:MoveData[0]))
                        ww1
                   __word 1
                   -> let {
                        a1 :: GHC.Prim.Word#
                        = GHC.Prim.xor# ww4 __word 18446744073709551615
                      } in
                      MoveGeneration.$wgIndexGen
                        (\ i :: GHC.Types.Int ->
                         (i,
                          case i of wild1 { GHC.Types.I# x1 ->
                          case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.>=# x1 0) of wild2 {
                            GHC.Types.False
                            -> case MoveGeneration.knightMovement1 of wild3 { GHC.Types.I# n# ->
                               MoveGeneration.gEnPassant1 x1 n# }
                            GHC.Types.True
                            -> case MoveGeneration.knightMovement1 of wild3 { GHC.Types.I# y ->
                               case GHC.Prim.tagToEnum#
                                      @ GHC.Types.Bool
                                      (GHC.Prim.<# x1 y) of wild4 {
                                 GHC.Types.False -> MoveGeneration.gEnPassant1 x1 y
                                 GHC.Types.True
                                 -> case MoveTables.knightAttack
                                           `cast`
                                         (Trans
                                              (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorWord64[0]))
                                              (Data.Vector.Unboxed.Base.NTCo:R:VectorWord64[0])) of wild { Data.Vector.Primitive.Vector dt dt1 dt2 ->
                                    case GHC.Prim.indexWord64Array#
                                           dt2
                                           (GHC.Prim.+# dt x1) of wild7 { DEFAULT ->
                                    GHC.Word.W64# (GHC.Prim.and# a1 wild7) } } } } } }))
                        MoveTypes.$bKnightM1 `cast` (Sym (MoveTypes.NTCo:MoveData[0]))
                        ww2 }) -}
dfdc798d9f4e27d24888289fee6e63ff
  $wpawnMovement ::
    GHC.Prim.Word#
    -> GHC.Base.Maybe Index.Index
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> MoveTypes.Moves
  {- Arity: 7, Strictness: <S,1*U><S,1*U><L,U><L,U><L,U><L,U><L,U>,
     Inline: [0] -}
8949edc4983590b2ab65895fc20cd5ee
  bishopMovement ::
    FEN.Turn
    -> BitBoard.AllColors 'BitBoard.Bishops
    -> BitBoard.AllColors 'BitBoard.All
    -> Data.Vector.Unboxed.Base.Vector MoveTypes.Move
  {- Arity: 3, Strictness: <L,A><S,1*H><S,1*H>,
     Unfolding: InlineRule (3, True, False)
                (\ t :: FEN.Turn
                   ds :: BitBoard.AllColors 'BitBoard.Bishops
                   ds1 :: BitBoard.AllColors 'BitBoard.All ->
                 case ds of wild { BitBoard.AllColors dt dt1 dt2 ->
                 case ds1 of wild1 { BitBoard.AllColors dt3 dt4 dt5 ->
                 MoveGeneration.bishopMovement1 } }) -}
bb3837f316786b1a11a951ccc6dda0d7
  bishopMovement1 :: Data.Vector.Unboxed.Base.Vector MoveTypes.Move
  {- Unfolding: (GHC.ST.runSTRep
                   @ (Data.Vector.Unboxed.Base.Vector MoveTypes.Move)
                   MoveGeneration.bishopMovement2) -}
7a24f61d71d0475ffe1c487a4ade0347
  bishopMovement2 ::
    GHC.Prim.State# s
    -> (# GHC.Prim.State# s,
          Data.Vector.Unboxed.Base.Vector MoveTypes.Move #)
  {- Arity: 1,
     Unfolding: (\ @ s s1 :: GHC.Prim.State# s[OneShot] ->
                 case GHC.Classes.divInt# 9223372036854775807 1 of ww4 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># 0 ww4) of wild3 {
                   GHC.Types.False
                   -> case GHC.Prim.newByteArray#
                             @ (Control.Monad.Primitive.PrimState (GHC.ST.ST s))
                             0
                             s1
                               `cast`
                             (GHC.Prim.State#
                                (Sym (Control.Monad.Primitive.TFCo:R:PrimStateST[0]
                                          <s>_N)))_R of ds1 { (#,#) ipv ipv1 ->
                      case GHC.Classes.divInt# 9223372036854775807 8 of ww1 { DEFAULT ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.># 0 ww1) of wild1 {
                        GHC.Types.False
                        -> case GHC.Prim.newByteArray#
                                  @ (Control.Monad.Primitive.PrimState (GHC.ST.ST s))
                                  0
                                  ipv of ds2 { (#,#) ipv2 ipv3 ->
                           case GHC.Prim.newByteArray#
                                  @ (Control.Monad.Primitive.PrimState (GHC.ST.ST s))
                                  0
                                  ipv2 of ds3 { (#,#) ipv4 ipv5 ->
                           case GHC.Prim.unsafeFreezeByteArray#
                                  @ (Control.Monad.Primitive.PrimState (GHC.ST.ST s))
                                  ipv1
                                  ipv4 of ds4 { (#,#) ipv6 ipv7 ->
                           case GHC.Prim.unsafeFreezeByteArray#
                                  @ (Control.Monad.Primitive.PrimState (GHC.ST.ST s))
                                  ipv3
                                  ipv6 of ds5 { (#,#) ipv8 ipv9 ->
                           case GHC.Prim.unsafeFreezeByteArray#
                                  @ (Control.Monad.Primitive.PrimState (GHC.ST.ST s))
                                  ipv5
                                  ipv8 of ds6 { (#,#) ipv10 ipv11 ->
                           (# ipv10
                                `cast`
                              (GHC.Prim.State#
                                 (Control.Monad.Primitive.TFCo:R:PrimStateST[0] <s>_N))_R,
                              (Data.Vector.Unboxed.Base.V_3
                                 @ GHC.Word.Word8
                                 @ GHC.Types.Int
                                 @ GHC.Types.Int
                                 0
                                 (Data.Vector.Primitive.Vector @ GHC.Word.Word8 0 0 ipv7)
                                   `cast`
                                 (Trans
                                      (Sym (Data.Vector.Unboxed.Base.NTCo:R:VectorWord8[0]))
                                      (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:VectorWord8[0]))))
                                 (Data.Vector.Primitive.Vector @ GHC.Types.Int 0 0 ipv9)
                                   `cast`
                                 (Trans
                                      (Sym (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0]))
                                      (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))))
                                 (Data.Vector.Primitive.Vector @ GHC.Types.Int 0 0 ipv11)
                                   `cast`
                                 (Trans
                                      (Sym (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0]))
                                      (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0])))))
                                `cast`
                              (Trans
                                   (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:Vector(,,)[0]
                                                  <GHC.Word.Word8>_N
                                                  <GHC.Types.Int>_N
                                                  <GHC.Types.Int>_N)))
                                   (Trans
                                        (Sym (MoveTypes.NTCo:R:VectorMove[0]))
                                        (Sub (Sym (MoveTypes.TFCo:R:VectorMove[0]))))) #) } } } } }
                        GHC.Types.True
                        -> case GHC.Err.error
                                  @ (GHC.ST.ST
                                       s
                                       (Data.Vector.Primitive.Mutable.MVector
                                          (Control.Monad.Primitive.PrimState (GHC.ST.ST s))
                                          GHC.Types.Int))
                                  MoveGeneration.bishopMovement3
                           ret_ty (# GHC.Prim.State# s,
                                     Data.Vector.Unboxed.Base.Vector MoveTypes.Move #)
                           of {} } } }
                   GHC.Types.True
                   -> case GHC.Err.error
                             @ (GHC.ST.ST
                                  s
                                  (Data.Vector.Primitive.Mutable.MVector
                                     (Control.Monad.Primitive.PrimState (GHC.ST.ST s))
                                     GHC.Word.Word8))
                             MoveGeneration.bishopMovement3
                      ret_ty (# GHC.Prim.State# s,
                                Data.Vector.Unboxed.Base.Vector MoveTypes.Move #)
                      of {} } }) -}
8fad778483c45879547e419f8fa8b674
  bishopMovement3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "Primitive.basicUnsafeNew: length to large: "#
                   MoveGeneration.bishopMovement4) -}
e677327acf3ffd69bdd848d21731faa4
  bishopMovement4 :: [GHC.Types.Char]
  {- Unfolding: (case GHC.Show.$wshowSignedInt
                        0
                        0
                        (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                 GHC.Types.: @ GHC.Types.Char ww5 ww6 }) -}
1d3e866eb95be12ca85b426b283902c3
  expandBitBoard ::
    Data.Vector.Unboxed.Base.Unbox a =>
    (GHC.Word.Word64 -> a)
    -> GHC.Word.Word64 -> Data.Vector.Unboxed.Base.Vector a
  {- Arity: 3,
     Strictness: <S(S(LC(C(S))LLLLLL)S),U(1*U(A,1*C1(C1(U)),A,A,A,A,A,A),U)><L,C(U)><S(S),1*U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a1
                   w :: Data.Vector.Unboxed.Base.Unbox a1
                   w1 :: GHC.Word.Word64 -> a1
                   w2 :: GHC.Word.Word64 ->
                 case w2 of ww { GHC.Word.W64# ww1 ->
                 MoveGeneration.$wexpandBitBoard @ a1 w w1 ww1 }) -}
840adc71ddebd297e92b24e4100c9470
  expandBitBoard1 ::
    GHC.Prim.Int#
    -> GHC.ST.ST
         s
         (Data.Vector.Primitive.Mutable.MVector
            (Control.Monad.Primitive.PrimState (GHC.ST.ST s)) GHC.Types.Int)
  {- Arity: 1, Strictness: <L,U>b -}
4d785ab75c875095aa6a4f774a82b786
  expandBitBoard2 ::
    GHC.Prim.Int#
    -> GHC.ST.ST
         s
         (Data.Vector.Primitive.Mutable.MVector
            (Control.Monad.Primitive.PrimState (GHC.ST.ST s)) GHC.Types.Int)
  {- Arity: 1, Strictness: <L,U>b -}
bcb2c38cdf83de8c2102cc02423448bd
  expandBitBoard3 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
df8e94d73ec2790344c4b75bb5ddad22
  expandBitBoard4 :: GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.ST.ST s ()
  {- Arity: 2, Strictness: <L,U><L,U>b -}
5685d07c0a37caf55d467348e2aa0831
  expandBitBoard5 ::
    GHC.Prim.Int#
    -> GHC.ST.ST
         s
         (Data.Vector.Unboxed.Base.MVector
            (Control.Monad.Primitive.PrimState (GHC.ST.ST s)) GHC.Types.Int)
  {- Arity: 1, Strictness: <L,U>b -}
84555e62cfbb769464893fc1a4444016
  expandBitBoard_$sexpandBitBoard ::
    (GHC.Word.Word64 -> (GHC.Types.Int, GHC.Word.Word64))
    -> GHC.Word.Word64
    -> Data.Vector.Unboxed.Base.Vector (GHC.Types.Int, GHC.Word.Word64)
  {- Arity: 2, Strictness: <L,C(U(1*U(U),1*U(U)))><S(S),1*U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Word.Word64 -> (GHC.Types.Int, GHC.Word.Word64)
                   w1 :: GHC.Word.Word64 ->
                 case w1 of ww { GHC.Word.W64# ww1 ->
                 MoveGeneration.$w$sexpandBitBoard w ww1 }) -}
b50ef969af66cf62f86fc3ac02dbaa7b
  expandBitBoard_$sexpandBitBoard1 ::
    (GHC.Word.Word64 -> MoveTypes.Move)
    -> GHC.Word.Word64
    -> Data.Vector.Unboxed.Base.Vector MoveTypes.Move
  {- Arity: 2, Strictness: <L,C(U(U,U,U))><S(S),1*U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Word.Word64 -> MoveTypes.Move w1 :: GHC.Word.Word64 ->
                 case w1 of ww { GHC.Word.W64# ww1 ->
                 MoveGeneration.$w$sexpandBitBoard1 w ww1 }) -}
06e2ef16ac8accb5f2846d4c1389ec76
  expandBitBoard_$sexpandBitBoard2 ::
    (GHC.Word.Word64 -> GHC.Types.Int)
    -> GHC.Word.Word64 -> Data.Vector.Unboxed.Base.Vector GHC.Types.Int
  {- Arity: 2, Strictness: <L,C(U(U))><S(S),1*U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Word.Word64 -> GHC.Types.Int w1 :: GHC.Word.Word64 ->
                 case w1 of ww { GHC.Word.W64# ww1 ->
                 MoveGeneration.$w$sexpandBitBoard2 w ww1 }) -}
5e2888339a39808dbc096d77f39a5c9d
  gEnPassant ::
    GHC.Base.Maybe Index.Index
    -> MoveTables.Attacks
    -> GHC.Word.Word64
    -> Data.Vector.Unboxed.Base.Vector MoveTypes.Move
  {- Arity: 3, Strictness: <S,1*U><L,U(U,U,U)><L,1*U(U)>,
     Unfolding: (\ ds :: GHC.Base.Maybe Index.Index
                   attackTable :: MoveTables.Attacks
                   eta :: GHC.Word.Word64 ->
                 let {
                   lvl56 :: GHC.Types.Int = MoveGeneration.$s!_$slength attackTable
                 } in
                 case ds of wild {
                   GHC.Base.Nothing -> MoveGeneration.bishopMovement1
                   GHC.Base.Just ep
                   -> case eta of ww { GHC.Word.W64# ww1 ->
                      let {
                        lvl57 :: GHC.Word.Word64
                        = case ep of wild1 { GHC.Types.I# i# ->
                          case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.>=# i# 64) of wild2 {
                            GHC.Types.False
                            -> GHC.Word.W64# (GHC.Prim.uncheckedShiftL# __word 1 i#)
                            GHC.Types.True -> MoveGeneration.gEnPassant2 } }
                      } in
                      MoveGeneration.$wgIndexGen
                        (\ i :: GHC.Types.Int ->
                         (i,
                          case lvl57 of wild1 { GHC.Word.W64# x# ->
                          case i of wild2 { GHC.Types.I# x1 ->
                          case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.>=# x1 0) of wild3 {
                            GHC.Types.False
                            -> case lvl56 of wild4 { GHC.Types.I# n# ->
                               MoveGeneration.gEnPassant1 x1 n# }
                            GHC.Types.True
                            -> case lvl56 of wild4 { GHC.Types.I# y ->
                               case GHC.Prim.tagToEnum#
                                      @ GHC.Types.Bool
                                      (GHC.Prim.<# x1 y) of wild5 {
                                 GHC.Types.False -> MoveGeneration.gEnPassant1 x1 y
                                 GHC.Types.True
                                 -> case attackTable
                                           `cast`
                                         (Trans
                                              (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorWord64[0]))
                                              (Data.Vector.Unboxed.Base.NTCo:R:VectorWord64[0])) of wild6 { Data.Vector.Primitive.Vector dt dt1 dt2 ->
                                    case GHC.Prim.indexWord64Array#
                                           dt2
                                           (GHC.Prim.+# dt x1) of wild7 { DEFAULT ->
                                    GHC.Word.W64# (GHC.Prim.and# x# wild7) } } } } } } }))
                        MoveTypes.$bEnPassantA1 `cast` (Sym (MoveTypes.NTCo:MoveData[0]))
                        ww1 } }) -}
cb00576f61a955b25f72d594f089f54c
  gEnPassant1 :: GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Word.Word64
  {- Arity: 2, Strictness: <L,U><L,U>b -}
ab488a4a06dfe7eb530f4f9db5508642
  gEnPassant2 :: GHC.Word.Word64
  {- HasNoCafRefs, Unfolding: (GHC.Word.W64# __word 0) -}
79a83f64d7fb694af242d643696a061c
  gIndexGen ::
    (Index.Index -> (Index.Index, GHC.Word.Word64))
    -> MoveTypes.MoveData
    -> GHC.Word.Word64
    -> Data.Vector.Unboxed.Base.Vector MoveTypes.Move
  {- Arity: 3,
     Strictness: <L,C(U(1*U(U),1*U(U)))><L,U(U)><S(S),1*U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: Index.Index -> (Index.Index, GHC.Word.Word64)
                   w1 :: MoveTypes.MoveData
                   w2 :: GHC.Word.Word64 ->
                 case w2 of ww { GHC.Word.W64# ww1 ->
                 MoveGeneration.$wgIndexGen w w1 ww1 }) -}
88776ff882beab0ceae52cde673c7712
  gPawnGen ::
    ((Index.Index, GHC.Word.Word64) -> (Index.Index, GHC.Word.Word64))
    -> MoveTypes.MoveData
    -> GHC.Word.Word64
    -> Data.Vector.Unboxed.Base.Vector MoveTypes.Move
  {- Arity: 3,
     Strictness: <L,C(U(1*U(U),1*U(U)))><L,U(U)><S(S),1*U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: (Index.Index, GHC.Word.Word64)
                        -> (Index.Index, GHC.Word.Word64)
                   w1 :: MoveTypes.MoveData
                   w2 :: GHC.Word.Word64 ->
                 case w2 of ww { GHC.Word.W64# ww1 ->
                 MoveGeneration.$wgPawnGen w w1 ww1 }) -}
0e814a806e4ac4b477840389a2940690
  gPawnPromotion ::
    (GHC.Word.Word64 -> GHC.Word.Word64)
    -> MoveTables.Attacks
    -> Masks.Mask
    -> GHC.Word.Word64
    -> MoveTypes.Moves
  {- Arity: 4,
     Strictness: <L,1*C1(U(U))><L,U(U,U,U)><L,1*U(U)><S(S),1*U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ w :: GHC.Word.Word64 -> GHC.Word.Word64
                   w1 :: MoveTables.Attacks
                   w2 :: Masks.Mask
                   w3 :: GHC.Word.Word64 ->
                 case w3 of ww { GHC.Word.W64# ww1 ->
                 MoveGeneration.$wgPawnPromotion w w1 w2 ww1 }) -}
c9b1163502af150fffd5065c40290bc7
  gPawnPromotion1 ::
    GHC.ST.ST
      s2
      (Data.Vector.Primitive.Mutable.MVector
         (Control.Monad.Primitive.PrimState (GHC.ST.ST s2)) GHC.Word.Word8)
  {- Strictness: b -}
59d7b8294dbe3235e62b718856f3f1fa
  gPawnPromotion2 ::
    GHC.ST.ST
      s2
      (Data.Vector.Primitive.Mutable.MVector
         (Control.Monad.Primitive.PrimState (GHC.ST.ST s2)) GHC.Types.Int)
  {- Strictness: b -}
c43cc4f7f681f6a4adc0c5aaf688d952
  gPawnPromotion3 ::
    GHC.Word.Word64 -> (GHC.Types.Int, GHC.Word.Word64)
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ b :: GHC.Word.Word64 ->
                 (GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros b, b)) -}
a2f475313d19023cdafe3be059b1a74f
  gPawnPushAndAttack ::
    (GHC.Word.Word64 -> GHC.Word.Word64)
    -> MoveTables.Attacks
    -> Masks.Mask
    -> GHC.Word.Word64
    -> Data.Vector.Unboxed.Base.Vector MoveTypes.Move
  {- Arity: 4,
     Strictness: <L,C(U(U))><L,U(U,U,U)><L,U(U)><S(S),U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ w :: GHC.Word.Word64 -> GHC.Word.Word64
                   w1 :: MoveTables.Attacks
                   w2 :: Masks.Mask
                   w3 :: GHC.Word.Word64 ->
                 case w3 of ww { GHC.Word.W64# ww1 ->
                 MoveGeneration.$wgPawnPushAndAttack w w1 w2 ww1 }) -}
10afe400f4b2051e4d177e00bca393ba
  genPromotions :: Index.Index -> GHC.Word.Word64 -> MoveTypes.Moves
  {- Arity: 2, Strictness: <B,A><B,A>b,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Index.Index ds1 :: GHC.Word.Word64 ->
                 GHC.Err.undefined @ MoveTypes.Moves) -}
0d5ed3035c4568476b7843285dcb965c
  generateMoves :: Board.Board -> MoveTypes.Moves
  {- Arity: 1,
     Strictness: <S(LLLLLSLLLLLSLLLLLLLLLLSSSSSLLLL),1*U(U,U,U,U,U,1*U,A,A,A,U,U,1*U,A,A,A,A,A,A,A,A,A,U,H,H,U,H,U,A,A,U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: Board.Board ->
                 case w of ww { Board.Board ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ww11 ww12 ww13 ww14 ww15 ww16 ww17 ww18 ww19 ww20 ww21 ww22 ww23 ww24 ww25 ww26 ww27 ww28 ww29 ww30 ww31 ->
                 MoveGeneration.$wgenerateMoves
                   ww1
                   ww2
                   ww3
                   ww4
                   ww5
                   ww6
                   ww10
                   ww11
                   ww12
                   ww22
                   ww23
                   ww24
                   ww25
                   ww26
                   ww27
                   ww30
                   ww31 }) -}
6fee63cddeff9f6e07b97334a9b1b060
  inCheck :: Board.Board -> MoveTypes.Move -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Board.Board ds1 :: MoveTypes.Move -> GHC.Types.False) -}
f4d4a4a08af2434f000790e44f40c49d
  indexedBitBoard ::
    GHC.Word.Word64
    -> Data.Vector.Unboxed.Base.Vector (GHC.Types.Int, GHC.Word.Word64)
  {- Arity: 1,
     Unfolding: (\ w :: GHC.Word.Word64 ->
                 case w of ww { GHC.Word.W64# ww1 ->
                 MoveGeneration.$w$sexpandBitBoard
                   MoveGeneration.gPawnPromotion3
                   ww1 }) -}
49fcc9ae76002a0c23ee7d7e77a547f3
  indexedOnly ::
    GHC.Word.Word64 -> Data.Vector.Unboxed.Base.Vector Index.Index
  {- Arity: 1,
     Unfolding: (\ w :: GHC.Word.Word64 ->
                 case w of ww { GHC.Word.W64# ww1 ->
                 MoveGeneration.$w$sexpandBitBoard2
                   GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros
                   ww1 }) -}
0ab2c0db4224d46aa859cc3d4c4ecdb1
  kingMovement ::
    FEN.Turn
    -> FEN.Castling
    -> Index.Index
    -> Index.Index
    -> BitBoard.AllColors 'BitBoard.All
    -> Data.Vector.Unboxed.Base.Vector MoveTypes.Move
  {- Arity: 5,
     Strictness: <S(S),1*U(1*U)><L,1*U(1*H,1*H,U,1*H)><L,U(U)><L,U(U)><S,1*U(U,U,A)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (5, True, False)
                (\ w :: FEN.Turn
                   w1 :: FEN.Castling
                   w2 :: Index.Index
                   w3 :: Index.Index
                   w4 :: BitBoard.AllColors 'BitBoard.All ->
                 case w `cast` (FEN.NTCo:Turn[0]) of ww { GHC.Word.W8# ww1 ->
                 case w4 of ww2 { BitBoard.AllColors ww3 ww4 ww5 ->
                 MoveGeneration.$wkingMovement ww1 w1 w2 w3 ww3 ww4 } }) -}
d5889f94b5cd0fce1b50d396d76f906c
  knightMovement ::
    FEN.Turn
    -> BitBoard.AllColors 'BitBoard.Knights
    -> BitBoard.AllColors 'BitBoard.All
    -> Data.Vector.Unboxed.Base.Vector MoveTypes.Move
  {- Arity: 3,
     Strictness: <S(S),1*U(1*U)><S,1*U(U,U,A)><S,1*U(U,U,A)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: FEN.Turn
                   w1 :: BitBoard.AllColors 'BitBoard.Knights
                   w2 :: BitBoard.AllColors 'BitBoard.All ->
                 case w `cast` (FEN.NTCo:Turn[0]) of ww { GHC.Word.W8# ww1 ->
                 case w1 of ww2 { BitBoard.AllColors ww3 ww4 ww5 ->
                 case w2 of ww6 { BitBoard.AllColors ww7 ww8 ww9 ->
                 MoveGeneration.$wknightMovement ww1 ww3 ww4 ww7 ww8 } } }) -}
3711872c4abccbe8253f9e10032612d3
  knightMovement1 :: GHC.Types.Int
  {- Unfolding: (MoveGeneration.$s!_$slength
                   MoveTables.knightAttack) -}
1e1e85764264e20da9512b8bfd496052
  knightMovement2 :: Data.Vector.Unboxed.Base.Vector MoveTypes.Move
  {- Strictness: b -}
6e2ccfd11e88f1a610c35464a8d0d193
  pawnMovement ::
    FEN.Turn
    -> GHC.Base.Maybe Index.Index
    -> BitBoard.AllColors 'BitBoard.Pawns
    -> BitBoard.AllColors 'BitBoard.All
    -> MoveTypes.Moves
  {- Arity: 4,
     Strictness: <S(S),1*U(1*U)><S,1*U><S,1*U(U,U,A)><S,1*U(U,U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ w :: FEN.Turn
                   w1 :: GHC.Base.Maybe Index.Index
                   w2 :: BitBoard.AllColors 'BitBoard.Pawns
                   w3 :: BitBoard.AllColors 'BitBoard.All ->
                 case w `cast` (FEN.NTCo:Turn[0]) of ww { GHC.Word.W8# ww1 ->
                 case w2 of ww2 { BitBoard.AllColors ww3 ww4 ww5 ->
                 case w3 of ww6 { BitBoard.AllColors ww7 ww8 ww9 ->
                 MoveGeneration.$wpawnMovement ww1 w1 ww3 ww4 ww7 ww8 ww9 } } }) -}
09344f6abba4ee4381e945df8ac8fa32
  queenMovement ::
    FEN.Turn
    -> BitBoard.AllColors 'BitBoard.Queens
    -> BitBoard.AllColors 'BitBoard.All
    -> Data.Vector.Unboxed.Base.Vector MoveTypes.Move
  {- Arity: 3, Strictness: <L,A><S,1*H><S,1*H>,
     Unfolding: InlineRule (3, True, False)
                (\ t :: FEN.Turn
                   ds :: BitBoard.AllColors 'BitBoard.Queens
                   ds1 :: BitBoard.AllColors 'BitBoard.All ->
                 case ds of wild { BitBoard.AllColors dt dt1 dt2 ->
                 case ds1 of wild1 { BitBoard.AllColors dt3 dt4 dt5 ->
                 MoveGeneration.bishopMovement1 } }) -}
fb53a2b0c6f0216848c709aa260088b7
  rookMovement ::
    FEN.Turn
    -> BitBoard.AllColors 'BitBoard.Rooks
    -> BitBoard.AllColors 'BitBoard.All
    -> Data.Vector.Unboxed.Base.Vector MoveTypes.Move
  {- Arity: 3, Strictness: <L,A><S,1*H><S,1*H>,
     Unfolding: InlineRule (3, True, False)
                (\ t :: FEN.Turn
                   ds :: BitBoard.AllColors 'BitBoard.Rooks
                   ds1 :: BitBoard.AllColors 'BitBoard.All ->
                 case ds of wild { BitBoard.AllColors dt dt1 dt2 ->
                 case ds1 of wild1 { BitBoard.AllColors dt3 dt4 dt5 ->
                 MoveGeneration.bishopMovement1 } }) -}
a451696d113681e5d98f7928de50fcfe
  serializeBitBoard ::
    MoveTypes.MoveData
    -> Index.Index
    -> GHC.Word.Word64
    -> Data.Vector.Unboxed.Base.Vector MoveTypes.Move
  {- Arity: 3, Strictness: <L,U(U)><L,U(U)><S(S),1*U(U)>,
     Unfolding: InlineRule (3, True, False)
                (\ metaData :: MoveTypes.MoveData
                   index :: Index.Index
                   eta :: GHC.Word.Word64 ->
                 MoveGeneration.expandBitBoard_$sexpandBitBoard1
                   (\ x :: GHC.Word.Word64 ->
                    case metaData
                           `cast`
                         (MoveTypes.NTCo:MoveData[0]) of dt { GHC.Word.W8# dt1 ->
                    case index of dt2 { GHC.Types.I# dt3 ->
                    case x of wild { GHC.Word.W64# x# ->
                    MoveTypes.Move
                      dt1
                      dt3
                      (GHC.Prim.word2Int# (GHC.Prim.ctz64# x#)) } } })
                   eta) -}
"SPEC expandBitBoard" [ALWAYS] forall $dUnbox :: Data.Vector.Unboxed.Base.Unbox
                                                   GHC.Types.Int
  MoveGeneration.expandBitBoard @ GHC.Types.Int $dUnbox
  = MoveGeneration.expandBitBoard_$sexpandBitBoard2
"SPEC expandBitBoard" [ALWAYS] forall $dUnbox :: Data.Vector.Unboxed.Base.Unbox
                                                   MoveTypes.Move
  MoveGeneration.expandBitBoard @ MoveTypes.Move $dUnbox
  = MoveGeneration.expandBitBoard_$sexpandBitBoard1
"SPEC expandBitBoard" [ALWAYS] forall $dUnbox :: Data.Vector.Unboxed.Base.Unbox
                                                   (GHC.Types.Int, GHC.Word.Word64)
  MoveGeneration.expandBitBoard @ (GHC.Types.Int, GHC.Word.Word64)
                                $dUnbox
  = MoveGeneration.expandBitBoard_$sexpandBitBoard
"SPEC/MoveGeneration length @ Vector @ Word64" [ALWAYS] forall $dVector :: Data.Vector.Generic.Base.Vector
                                                                             Data.Vector.Unboxed.Base.Vector
                                                                             GHC.Word.Word64
  Data.Vector.Generic.length @ Data.Vector.Unboxed.Base.Vector
                             @ GHC.Word.Word64
                             $dVector
  = MoveGeneration.$s!_$slength
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

