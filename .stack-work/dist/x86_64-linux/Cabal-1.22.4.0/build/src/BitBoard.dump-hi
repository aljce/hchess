
==================== FINAL INTERFACE ====================
2016-01-02 04:04:55.319635 UTC

interface hches_KF6MDI5eODG4Q8cKhuw0mn:BitBoard 7102
  interface hash: ce87692e77f1f1f20576da116814b90b
  ABI hash: 3c244b8ec8b253f65c50911201be3573
  export-list hash: ad24690e2a3640cdb930e8fadfacb8b5
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 613f9f74249a44145e3c1e766ddf802d
  sig of: Nothing
  used TH splices: False
  where
exports:
  BitBoard.bitBoardToDoc
  BitBoard.emptyBoard
  BitBoard.AllColors{BitBoard.AllColors BitBoard.black BitBoard.both BitBoard.white}
  BitBoard.BitBoard{BitBoard.BitBoard BitBoard.bishops BitBoard.kings BitBoard.knights BitBoard.pawns BitBoard.pieces BitBoard.queens BitBoard.rooks}
  BitBoard.PieceType{BitBoard.All BitBoard.Bishops BitBoard.Kings BitBoard.Knights BitBoard.Pawns BitBoard.Queens BitBoard.Rooks}
module dependencies:
package dependencies: ansi-terminal-0.6.2.3@ansit_KW0LUY2zB7JCYzE4ZYrwBg
                      ansi-wl-pprint-0.6.7.3@ansiw_KPlSW7tbqXS51Lj59n3FC4
                      array-0.5.1.0@array_E0sTtauuKsGDLZoT7lTbgZ base-4.8.1.0
                      containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN
                      deepseq-1.4.1.1@deeps_LbCWUlehDDeLxurARKDH5o ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
orphans: base-4.8.1.0:GHC.Base base-4.8.1.0:GHC.Float
family instance modules: base-4.8.1.0:Control.Applicative
                         base-4.8.1.0:Data.Either base-4.8.1.0:Data.Functor.Identity
                         base-4.8.1.0:Data.Monoid base-4.8.1.0:Data.Type.Equality
                         base-4.8.1.0:Data.Void base-4.8.1.0:GHC.Exts
                         base-4.8.1.0:GHC.Generics
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntMap.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntSet.Base
import  -/  ansi-wl-pprint-0.6.7.3@ansiw_KPlSW7tbqXS51Lj59n3FC4:Text.PrettyPrint.ANSI.Leijen 8c4176551c95005818f5e57d74e5ea69
import  -/  base-4.8.1.0:Data.Bits 5341167fdd5958c2b3f0dac8924f1efd
import  -/  base-4.8.1.0:Data.Word 448c480b98a0c18988a37db5ab829b22
import  -/  base-4.8.1.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.1.0:GHC.Enum d0db4d619cd8916cc7a23444816222af
import  -/  base-4.8.1.0:GHC.List f31ed8784b3e05f1397195751f7d74ea
import  -/  base-4.8.1.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.1.0:GHC.Show b8c65ca3124f92a166c9f05120382442
import  -/  base-4.8.1.0:GHC.Word ef6286c279d61931eb675109b4b93579
import  -/  base-4.8.1.0:Prelude 518f762991bc287d78f21a73c974da1f
import  -/  containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntMap.Base 41288a612f7bbd399bc0bb07f2f75738
import  -/  containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntMap.Strict 75157829e2fd1bf3aaf8a4fd3bd7d8f4
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  ghc-prim-0.4.0.0:GHC.Types 6b27fb3fdbd0e3f0925a4496c66513bb
f417d32df3225e12d27a8db2fbbc5424
  $fEnumPieceType :: GHC.Enum.Enum BitBoard.PieceType
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.PieceType
                  BitBoard.$fEnumPieceType_$csucc
                  BitBoard.$fEnumPieceType_$cpred
                  BitBoard.$fEnumPieceType_$ctoEnum
                  BitBoard.$fEnumPieceType_$cfromEnum
                  BitBoard.$fEnumPieceType_$cenumFrom
                  BitBoard.$fEnumPieceType_$cenumFromThen
                  BitBoard.$fEnumPieceType_$cenumFromTo
                  BitBoard.$fEnumPieceType_$cenumFromThenTo -}
f417d32df3225e12d27a8db2fbbc5424
  $fEnumPieceType1 :: [BitBoard.PieceType]
  {- Unfolding: (BitBoard.$fEnumPieceType_go7 6) -}
f417d32df3225e12d27a8db2fbbc5424
  $fEnumPieceType10 :: BitBoard.PieceType
  {- Strictness: b -}
f417d32df3225e12d27a8db2fbbc5424
  $fEnumPieceType2 :: [BitBoard.PieceType]
  {- Unfolding: (BitBoard.$fEnumPieceType_go8 5) -}
f417d32df3225e12d27a8db2fbbc5424
  $fEnumPieceType3 :: [BitBoard.PieceType]
  {- Unfolding: (BitBoard.$fEnumPieceType_go9 4) -}
f417d32df3225e12d27a8db2fbbc5424
  $fEnumPieceType4 :: [BitBoard.PieceType]
  {- Unfolding: (BitBoard.$fEnumPieceType_go10 3) -}
f417d32df3225e12d27a8db2fbbc5424
  $fEnumPieceType5 :: [BitBoard.PieceType]
  {- Unfolding: (BitBoard.$fEnumPieceType_go11 2) -}
f417d32df3225e12d27a8db2fbbc5424
  $fEnumPieceType6 :: [BitBoard.PieceType]
  {- Unfolding: (BitBoard.$fEnumPieceType_go12 1) -}
f417d32df3225e12d27a8db2fbbc5424
  $fEnumPieceType7 :: [BitBoard.PieceType]
  {- Unfolding: (BitBoard.$fEnumPieceType_go13 0) -}
f417d32df3225e12d27a8db2fbbc5424
  $fEnumPieceType8 :: GHC.Prim.Int# -> BitBoard.PieceType
  {- Arity: 1, Strictness: <L,U>b -}
f417d32df3225e12d27a8db2fbbc5424
  $fEnumPieceType9 :: BitBoard.PieceType
  {- Strictness: b -}
f417d32df3225e12d27a8db2fbbc5424
  $fEnumPieceType_$cenumFrom ::
    BitBoard.PieceType -> [BitBoard.PieceType]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a :: BitBoard.PieceType ->
                 case a of wild {
                   BitBoard.All -> BitBoard.$fEnumPieceType7
                   BitBoard.Pawns -> BitBoard.$fEnumPieceType6
                   BitBoard.Rooks -> BitBoard.$fEnumPieceType5
                   BitBoard.Knights -> BitBoard.$fEnumPieceType4
                   BitBoard.Bishops -> BitBoard.$fEnumPieceType3
                   BitBoard.Queens -> BitBoard.$fEnumPieceType2
                   BitBoard.Kings -> BitBoard.$fEnumPieceType1 }) -}
f417d32df3225e12d27a8db2fbbc5424
  $fEnumPieceType_$cenumFromThen ::
    BitBoard.PieceType -> BitBoard.PieceType -> [BitBoard.PieceType]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a :: BitBoard.PieceType b :: BitBoard.PieceType ->
                 let {
                   $j :: GHC.Prim.Int# -> [BitBoard.PieceType]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [BitBoard.PieceType]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [BitBoard.PieceType]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [BitBoard.PieceType]
                                    BitBoard.$fEnumPieceType_c
                                    (GHC.Types.[] @ BitBoard.PieceType)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [BitBoard.PieceType]
                                    BitBoard.$fEnumPieceType_c
                                    (GHC.Types.[] @ BitBoard.PieceType)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 6 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       BitBoard.All -> $j1 0
                       BitBoard.Pawns -> $j1 1
                       BitBoard.Rooks -> $j1 2
                       BitBoard.Knights -> $j1 3
                       BitBoard.Bishops -> $j1 4
                       BitBoard.Queens -> $j1 5
                       BitBoard.Kings -> $j1 6 }
                 } in
                 case a of wild {
                   BitBoard.All -> $j 0
                   BitBoard.Pawns -> $j 1
                   BitBoard.Rooks -> $j 2
                   BitBoard.Knights -> $j 3
                   BitBoard.Bishops -> $j 4
                   BitBoard.Queens -> $j 5
                   BitBoard.Kings -> $j 6 }) -}
f417d32df3225e12d27a8db2fbbc5424
  $fEnumPieceType_$cenumFromThenTo ::
    BitBoard.PieceType
    -> BitBoard.PieceType -> BitBoard.PieceType -> [BitBoard.PieceType]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U> -}
f417d32df3225e12d27a8db2fbbc5424
  $fEnumPieceType_$cenumFromTo ::
    BitBoard.PieceType -> BitBoard.PieceType -> [BitBoard.PieceType]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: BitBoard.PieceType y :: BitBoard.PieceType ->
                 let {
                   $j :: GHC.Prim.Int# -> [BitBoard.PieceType]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       BitBoard.All
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> BitBoard.$fEnumPieceType_go6 x1
                            GHC.Types.True -> GHC.Types.[] @ BitBoard.PieceType }
                       BitBoard.Pawns
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> BitBoard.$fEnumPieceType_go5 x1
                            GHC.Types.True -> GHC.Types.[] @ BitBoard.PieceType }
                       BitBoard.Rooks
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 2) of wild1 {
                            GHC.Types.False -> BitBoard.$fEnumPieceType_go4 x1
                            GHC.Types.True -> GHC.Types.[] @ BitBoard.PieceType }
                       BitBoard.Knights
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 3) of wild1 {
                            GHC.Types.False -> BitBoard.$fEnumPieceType_go3 x1
                            GHC.Types.True -> GHC.Types.[] @ BitBoard.PieceType }
                       BitBoard.Bishops
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 4) of wild1 {
                            GHC.Types.False -> BitBoard.$fEnumPieceType_go2 x1
                            GHC.Types.True -> GHC.Types.[] @ BitBoard.PieceType }
                       BitBoard.Queens
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 5) of wild1 {
                            GHC.Types.False -> BitBoard.$fEnumPieceType_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ BitBoard.PieceType }
                       BitBoard.Kings
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 6) of wild1 {
                            GHC.Types.False -> BitBoard.$fEnumPieceType_go x1
                            GHC.Types.True -> GHC.Types.[] @ BitBoard.PieceType } }
                 } in
                 case x of wild {
                   BitBoard.All -> $j 0
                   BitBoard.Pawns -> $j 1
                   BitBoard.Rooks -> $j 2
                   BitBoard.Knights -> $j 3
                   BitBoard.Bishops -> $j 4
                   BitBoard.Queens -> $j 5
                   BitBoard.Kings -> $j 6 }) -}
f417d32df3225e12d27a8db2fbbc5424
  $fEnumPieceType_$cfromEnum :: BitBoard.PieceType -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: BitBoard.PieceType ->
                 case w of wild {
                   BitBoard.All -> GHC.Types.I# 0
                   BitBoard.Pawns -> GHC.Types.I# 1
                   BitBoard.Rooks -> GHC.Types.I# 2
                   BitBoard.Knights -> GHC.Types.I# 3
                   BitBoard.Bishops -> GHC.Types.I# 4
                   BitBoard.Queens -> GHC.Types.I# 5
                   BitBoard.Kings -> GHC.Types.I# 6 }) -}
f417d32df3225e12d27a8db2fbbc5424
  $fEnumPieceType_$cpred :: BitBoard.PieceType -> BitBoard.PieceType
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a :: BitBoard.PieceType ->
                 case a of wild {
                   BitBoard.All -> BitBoard.$fEnumPieceType9
                   BitBoard.Pawns -> BitBoard.All
                   BitBoard.Rooks -> BitBoard.Pawns
                   BitBoard.Knights -> BitBoard.Rooks
                   BitBoard.Bishops -> BitBoard.Knights
                   BitBoard.Queens -> BitBoard.Bishops
                   BitBoard.Kings -> BitBoard.Queens }) -}
f417d32df3225e12d27a8db2fbbc5424
  $fEnumPieceType_$csucc :: BitBoard.PieceType -> BitBoard.PieceType
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a :: BitBoard.PieceType ->
                 case a of wild {
                   BitBoard.All -> BitBoard.Pawns
                   BitBoard.Pawns -> BitBoard.Rooks
                   BitBoard.Rooks -> BitBoard.Knights
                   BitBoard.Knights -> BitBoard.Bishops
                   BitBoard.Bishops -> BitBoard.Queens
                   BitBoard.Queens -> BitBoard.Kings
                   BitBoard.Kings -> BitBoard.$fEnumPieceType10 }) -}
f417d32df3225e12d27a8db2fbbc5424
  $fEnumPieceType_$ctoEnum :: GHC.Types.Int -> BitBoard.PieceType
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 -> BitBoard.$w$ctoEnum ww1 }) -}
f417d32df3225e12d27a8db2fbbc5424
  $fEnumPieceType_c ::
    GHC.Types.Int -> [BitBoard.PieceType] -> [BitBoard.PieceType]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [BitBoard.PieceType] ->
                 GHC.Types.:
                   @ BitBoard.PieceType
                   (case x of wild { GHC.Types.I# a ->
                    GHC.Prim.tagToEnum# @ BitBoard.PieceType a })
                   ys) -}
f417d32df3225e12d27a8db2fbbc5424
  $fEnumPieceType_go :: GHC.Prim.Int# -> [BitBoard.PieceType]
  {- Arity: 1, Strictness: <L,U> -}
f417d32df3225e12d27a8db2fbbc5424
  $fEnumPieceType_go1 :: GHC.Prim.Int# -> [BitBoard.PieceType]
  {- Arity: 1, Strictness: <L,U> -}
f417d32df3225e12d27a8db2fbbc5424
  $fEnumPieceType_go10 :: GHC.Prim.Int# -> [BitBoard.PieceType]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
f417d32df3225e12d27a8db2fbbc5424
  $fEnumPieceType_go11 :: GHC.Prim.Int# -> [BitBoard.PieceType]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
f417d32df3225e12d27a8db2fbbc5424
  $fEnumPieceType_go12 :: GHC.Prim.Int# -> [BitBoard.PieceType]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
f417d32df3225e12d27a8db2fbbc5424
  $fEnumPieceType_go13 :: GHC.Prim.Int# -> [BitBoard.PieceType]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
f417d32df3225e12d27a8db2fbbc5424
  $fEnumPieceType_go2 :: GHC.Prim.Int# -> [BitBoard.PieceType]
  {- Arity: 1, Strictness: <L,U> -}
f417d32df3225e12d27a8db2fbbc5424
  $fEnumPieceType_go3 :: GHC.Prim.Int# -> [BitBoard.PieceType]
  {- Arity: 1, Strictness: <L,U> -}
f417d32df3225e12d27a8db2fbbc5424
  $fEnumPieceType_go4 :: GHC.Prim.Int# -> [BitBoard.PieceType]
  {- Arity: 1, Strictness: <L,U> -}
f417d32df3225e12d27a8db2fbbc5424
  $fEnumPieceType_go5 :: GHC.Prim.Int# -> [BitBoard.PieceType]
  {- Arity: 1, Strictness: <L,U> -}
f417d32df3225e12d27a8db2fbbc5424
  $fEnumPieceType_go6 :: GHC.Prim.Int# -> [BitBoard.PieceType]
  {- Arity: 1, Strictness: <L,U> -}
f417d32df3225e12d27a8db2fbbc5424
  $fEnumPieceType_go7 :: GHC.Prim.Int# -> [BitBoard.PieceType]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
f417d32df3225e12d27a8db2fbbc5424
  $fEnumPieceType_go8 :: GHC.Prim.Int# -> [BitBoard.PieceType]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
f417d32df3225e12d27a8db2fbbc5424
  $fEnumPieceType_go9 :: GHC.Prim.Int# -> [BitBoard.PieceType]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
f417d32df3225e12d27a8db2fbbc5424
  $fEqPieceType :: GHC.Classes.Eq BitBoard.PieceType
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.PieceType
                  BitBoard.$fEqPieceType_$c==
                  BitBoard.$fEqPieceType_$c/= -}
f417d32df3225e12d27a8db2fbbc5424
  $fEqPieceType_$c/= ::
    BitBoard.PieceType -> BitBoard.PieceType -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a :: BitBoard.PieceType b :: BitBoard.PieceType ->
                 case a of wild {
                   BitBoard.All
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True BitBoard.All -> GHC.Types.False }
                   BitBoard.Pawns
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True BitBoard.Pawns -> GHC.Types.False }
                   BitBoard.Rooks
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True BitBoard.Rooks -> GHC.Types.False }
                   BitBoard.Knights
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True BitBoard.Knights -> GHC.Types.False }
                   BitBoard.Bishops
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True BitBoard.Bishops -> GHC.Types.False }
                   BitBoard.Queens
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True BitBoard.Queens -> GHC.Types.False }
                   BitBoard.Kings
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True BitBoard.Kings -> GHC.Types.False } }) -}
f417d32df3225e12d27a8db2fbbc5424
  $fEqPieceType_$c== ::
    BitBoard.PieceType -> BitBoard.PieceType -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: BitBoard.PieceType ds1 :: BitBoard.PieceType ->
                 case ds of wild {
                   BitBoard.All
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False BitBoard.All -> GHC.Types.True }
                   BitBoard.Pawns
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False BitBoard.Pawns -> GHC.Types.True }
                   BitBoard.Rooks
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False BitBoard.Rooks -> GHC.Types.True }
                   BitBoard.Knights
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False BitBoard.Knights -> GHC.Types.True }
                   BitBoard.Bishops
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False BitBoard.Bishops -> GHC.Types.True }
                   BitBoard.Queens
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False BitBoard.Queens -> GHC.Types.True }
                   BitBoard.Kings
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False BitBoard.Kings -> GHC.Types.True } }) -}
f417d32df3225e12d27a8db2fbbc5424
  $fOrdPieceType :: GHC.Classes.Ord BitBoard.PieceType
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.PieceType
                  BitBoard.$fEqPieceType
                  BitBoard.$fOrdPieceType_$ccompare
                  BitBoard.$fOrdPieceType_$c<
                  BitBoard.$fOrdPieceType_$c<=
                  BitBoard.$fOrdPieceType_$c>
                  BitBoard.$fOrdPieceType_$c>=
                  BitBoard.$fOrdPieceType_$cmax
                  BitBoard.$fOrdPieceType_$cmin -}
f417d32df3225e12d27a8db2fbbc5424
  $fOrdPieceType_$c< ::
    BitBoard.PieceType -> BitBoard.PieceType -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a :: BitBoard.PieceType b :: BitBoard.PieceType ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     case b of wild {
                       BitBoard.All
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 0)
                       BitBoard.Pawns
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 1)
                       BitBoard.Rooks
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 2)
                       BitBoard.Knights
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 3)
                       BitBoard.Bishops
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 4)
                       BitBoard.Queens
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 5)
                       BitBoard.Kings
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 6) }
                 } in
                 case a of wild {
                   BitBoard.All -> $j 0
                   BitBoard.Pawns -> $j 1
                   BitBoard.Rooks -> $j 2
                   BitBoard.Knights -> $j 3
                   BitBoard.Bishops -> $j 4
                   BitBoard.Queens -> $j 5
                   BitBoard.Kings -> $j 6 }) -}
f417d32df3225e12d27a8db2fbbc5424
  $fOrdPieceType_$c<= ::
    BitBoard.PieceType -> BitBoard.PieceType -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a :: BitBoard.PieceType b :: BitBoard.PieceType ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     case b of wild {
                       BitBoard.All
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 0)
                       BitBoard.Pawns
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 1)
                       BitBoard.Rooks
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 2)
                       BitBoard.Knights
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 3)
                       BitBoard.Bishops
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 4)
                       BitBoard.Queens
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 5)
                       BitBoard.Kings
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 6) }
                 } in
                 case a of wild {
                   BitBoard.All -> $j 0
                   BitBoard.Pawns -> $j 1
                   BitBoard.Rooks -> $j 2
                   BitBoard.Knights -> $j 3
                   BitBoard.Bishops -> $j 4
                   BitBoard.Queens -> $j 5
                   BitBoard.Kings -> $j 6 }) -}
f417d32df3225e12d27a8db2fbbc5424
  $fOrdPieceType_$c> ::
    BitBoard.PieceType -> BitBoard.PieceType -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a :: BitBoard.PieceType b :: BitBoard.PieceType ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     case b of wild {
                       BitBoard.All
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 0)
                       BitBoard.Pawns
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 1)
                       BitBoard.Rooks
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 2)
                       BitBoard.Knights
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 3)
                       BitBoard.Bishops
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 4)
                       BitBoard.Queens
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 5)
                       BitBoard.Kings
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 6) }
                 } in
                 case a of wild {
                   BitBoard.All -> $j 0
                   BitBoard.Pawns -> $j 1
                   BitBoard.Rooks -> $j 2
                   BitBoard.Knights -> $j 3
                   BitBoard.Bishops -> $j 4
                   BitBoard.Queens -> $j 5
                   BitBoard.Kings -> $j 6 }) -}
f417d32df3225e12d27a8db2fbbc5424
  $fOrdPieceType_$c>= ::
    BitBoard.PieceType -> BitBoard.PieceType -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a :: BitBoard.PieceType b :: BitBoard.PieceType ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     case b of wild {
                       BitBoard.All
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 0)
                       BitBoard.Pawns
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 1)
                       BitBoard.Rooks
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 2)
                       BitBoard.Knights
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 3)
                       BitBoard.Bishops
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 4)
                       BitBoard.Queens
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 5)
                       BitBoard.Kings
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 6) }
                 } in
                 case a of wild {
                   BitBoard.All -> $j 0
                   BitBoard.Pawns -> $j 1
                   BitBoard.Rooks -> $j 2
                   BitBoard.Knights -> $j 3
                   BitBoard.Bishops -> $j 4
                   BitBoard.Queens -> $j 5
                   BitBoard.Kings -> $j 6 }) -}
f417d32df3225e12d27a8db2fbbc5424
  $fOrdPieceType_$ccompare ::
    BitBoard.PieceType -> BitBoard.PieceType -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a :: BitBoard.PieceType b :: BitBoard.PieceType ->
                 case a of wild {
                   BitBoard.All
                   -> case b of wild1 {
                        BitBoard.All -> GHC.Types.EQ
                        BitBoard.Pawns -> GHC.Types.LT
                        BitBoard.Rooks -> GHC.Types.LT
                        BitBoard.Knights -> GHC.Types.LT
                        BitBoard.Bishops -> GHC.Types.LT
                        BitBoard.Queens -> GHC.Types.LT
                        BitBoard.Kings -> GHC.Types.LT }
                   BitBoard.Pawns
                   -> case b of wild1 {
                        BitBoard.All -> GHC.Types.GT
                        BitBoard.Pawns -> GHC.Types.EQ
                        BitBoard.Rooks -> GHC.Types.LT
                        BitBoard.Knights -> GHC.Types.LT
                        BitBoard.Bishops -> GHC.Types.LT
                        BitBoard.Queens -> GHC.Types.LT
                        BitBoard.Kings -> GHC.Types.LT }
                   BitBoard.Rooks
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        BitBoard.Rooks -> GHC.Types.EQ
                        BitBoard.Knights -> GHC.Types.LT
                        BitBoard.Bishops -> GHC.Types.LT
                        BitBoard.Queens -> GHC.Types.LT
                        BitBoard.Kings -> GHC.Types.LT }
                   BitBoard.Knights
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        BitBoard.Knights -> GHC.Types.EQ
                        BitBoard.Bishops -> GHC.Types.LT
                        BitBoard.Queens -> GHC.Types.LT
                        BitBoard.Kings -> GHC.Types.LT }
                   BitBoard.Bishops
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        BitBoard.Bishops -> GHC.Types.EQ
                        BitBoard.Queens -> GHC.Types.LT
                        BitBoard.Kings -> GHC.Types.LT }
                   BitBoard.Queens
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        BitBoard.Queens -> GHC.Types.EQ
                        BitBoard.Kings -> GHC.Types.LT }
                   BitBoard.Kings
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT BitBoard.Kings -> GHC.Types.EQ } }) -}
f417d32df3225e12d27a8db2fbbc5424
  $fOrdPieceType_$cmax ::
    BitBoard.PieceType -> BitBoard.PieceType -> BitBoard.PieceType
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: BitBoard.PieceType y :: BitBoard.PieceType ->
                 case BitBoard.$fOrdPieceType_$c<= x y of wild {
                   GHC.Types.False -> x GHC.Types.True -> y }) -}
f417d32df3225e12d27a8db2fbbc5424
  $fOrdPieceType_$cmin ::
    BitBoard.PieceType -> BitBoard.PieceType -> BitBoard.PieceType
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: BitBoard.PieceType y :: BitBoard.PieceType ->
                 case BitBoard.$fOrdPieceType_$c<= x y of wild {
                   GHC.Types.False -> y GHC.Types.True -> x }) -}
d9e321f5bae9df77c5aad3bd67235d5d
  $fShowBitBoard :: GHC.Show.Show BitBoard.BitBoard
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.BitBoard
                  BitBoard.$fShowBitBoard_$cshowsPrec
                  BitBoard.$fShowBitBoard_$cshow
                  BitBoard.$fShowBitBoard_$cshowList -}
d9e321f5bae9df77c5aad3bd67235d5d
  $fShowBitBoard1 :: BitBoard.BitBoard -> GHC.Show.ShowS
  {- Arity: 1,
     Strictness: <L,1*U(A,A,A,U,U,A,U,U,A,U,U,A,U,U,A,U,U,A,U,U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: BitBoard.BitBoard ->
                 GHC.Base.++ @ GHC.Types.Char (BitBoard.$fShowBitBoard_$cshow x)) -}
aa60f02357514ac46edd119ad6d18647
  $fShowBitBoard10 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# 'q') -}
8876c2ef993238c8f9f24f786a954393
  $fShowBitBoard11 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# 'B') -}
84bd62bb9cf66941e0a6635022a111f0
  $fShowBitBoard12 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# 'b') -}
fa98633598b883c47727f9aac803b806
  $fShowBitBoard13 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# 'N') -}
3e8a097ea36fce9ea100c49996479215
  $fShowBitBoard14 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# 'n') -}
9c866cdeead86429f99bb1e5546100d9
  $fShowBitBoard15 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# 'R') -}
038da9c2c11d32060b726124cc6a91f8
  $fShowBitBoard16 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# 'r') -}
1701accefa1659987c18c8fd97f1604e
  $fShowBitBoard17 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# 'P') -}
0511e2e9513fca16ada524f12bd1f769
  $fShowBitBoard18 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# 'p') -}
7f8ae991429afdbde6c3af62100da071
  $fShowBitBoard19 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (__integer 0) -}
204c624dd7faea1727e5afe1231e1be1
  $fShowBitBoard2 :: [Data.IntMap.Base.IntMap GHC.Types.Char]
  {- Unfolding: (GHC.Types.:
                   @ (Data.IntMap.Base.IntMap GHC.Types.Char)
                   BitBoard.$fShowBitBoard3
                   (GHC.Types.[] @ (Data.IntMap.Base.IntMap GHC.Types.Char))) -}
62fc8535f25295638c8cc6adb3cf421e
  $fShowBitBoard20 ::
    [GHC.Types.Char] -> Text.PrettyPrint.ANSI.Leijen.Doc
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: [GHC.Types.Char] ->
                 Text.PrettyPrint.ANSI.Leijen.string
                   (GHC.List.reverse @ GHC.Types.Char x)) -}
fc9d28c67a00458c82267c625ac2e42f
  $fShowBitBoard3 :: Data.IntMap.Base.IntMap GHC.Types.Char
  {- Unfolding: (BitBoard.$wlvl
                   BitBoard.$fShowBitBoard5
                   BitBoard.$fShowBitBoard4) -}
c436de7f8d4b5c272837554e67f75f5c
  $fShowBitBoard4 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# ' ') -}
94c7a1b22d82b1f913d26dc35a3cc660
  $fShowBitBoard5 :: GHC.Word.Word64
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Word.W64# __word 18446744073709551615) -}
3804680f77b70ebee1e5c3d39cf93936
  $fShowBitBoard6 :: [GHC.Types.Int]
  {- Unfolding: (GHC.Enum.eftInt 0 63) -}
33b6319124899d659dc66dc3745dbc54
  $fShowBitBoard7 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# 'K') -}
2593111edfa393ed9317b07d632ea523
  $fShowBitBoard8 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# 'k') -}
9c0491e435a81b69e262aebeb2e23318
  $fShowBitBoard9 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# 'Q') -}
d9e321f5bae9df77c5aad3bd67235d5d
  $fShowBitBoard_$cshow :: BitBoard.BitBoard -> GHC.Base.String
  {- Arity: 1,
     Strictness: <L,1*U(A,A,A,U,U,A,U,U,A,U,U,A,U,U,A,U,U,A,U,U,A)>,
     Unfolding: (\ x :: BitBoard.BitBoard ->
                 Text.PrettyPrint.ANSI.Leijen.displayS
                   (Text.PrettyPrint.ANSI.Leijen.renderFits
                      Text.PrettyPrint.ANSI.Leijen.fits1
                      Text.PrettyPrint.ANSI.Leijen.$fShowDoc3
                      Text.PrettyPrint.ANSI.Leijen.$fShowDoc2
                      (case x of ww { BitBoard.BitBoard ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ww11 ww12 ww13 ww14 ww15 ww16 ww17 ww18 ww19 ww20 ww21 ->
                       case BitBoard.$wbitBoardToDoc
                              ww4
                              ww5
                              ww7
                              ww8
                              ww10
                              ww11
                              ww13
                              ww14
                              ww16
                              ww17
                              ww19
                              ww20 of wild {
                         [] -> Text.PrettyPrint.ANSI.Leijen.Empty
                         : ipv ipv1
                         -> GHC.List.foldr1_$sfoldr1
                              @ Text.PrettyPrint.ANSI.Leijen.Doc
                              Text.PrettyPrint.ANSI.Leijen.<$>
                              ipv
                              ipv1 } }))
                   (GHC.Types.[] @ GHC.Types.Char)) -}
d9e321f5bae9df77c5aad3bd67235d5d
  $fShowBitBoard_$cshowList :: [BitBoard.BitBoard] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ ls :: [BitBoard.BitBoard] s :: GHC.Base.String ->
                 GHC.Show.showList__
                   @ BitBoard.BitBoard
                   BitBoard.$fShowBitBoard1
                   ls
                   s) -}
d9e321f5bae9df77c5aad3bd67235d5d
  $fShowBitBoard_$cshowsPrec ::
    GHC.Types.Int -> BitBoard.BitBoard -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ ds :: GHC.Types.Int eta :: BitBoard.BitBoard ->
                 BitBoard.$fShowBitBoard1 eta) -}
ddaa618e48b48a87fcd2e90eb8a6f0ac
  $fShowBitBoard_splitEvery8 ::
    GHC.Integer.Type.Integer -> [GHC.Types.Char] -> [[GHC.Types.Char]]
  {- Arity: 2, Strictness: <S,U><L,U> -}
f417d32df3225e12d27a8db2fbbc5424
  $fShowPieceType :: GHC.Show.Show BitBoard.PieceType
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.PieceType
                  BitBoard.$fShowPieceType_$cshowsPrec
                  BitBoard.$fShowPieceType_$cshow
                  BitBoard.$fShowPieceType_$cshowList -}
ca89085a09e38e47125ce923152c3a6b
  $fShowPieceType1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Kings"#) -}
db28c88e8f4d9ad62499e1371938004a
  $fShowPieceType2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Queens"#) -}
ac09fe997c752344dd219f8119395557
  $fShowPieceType3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Bishops"#) -}
958f683feb5aa98556df5c46c9db7e2b
  $fShowPieceType4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Knights"#) -}
4ae0f6d8baa861e7ba08444a88445868
  $fShowPieceType5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Rooks"#) -}
bc29e98838f8d5add44a1c1a0b1004c8
  $fShowPieceType6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Pawns"#) -}
e03c423eea3a35225707d76a93cc074c
  $fShowPieceType7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "All"#) -}
f417d32df3225e12d27a8db2fbbc5424
  $fShowPieceType_$cshow :: BitBoard.PieceType -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: BitBoard.PieceType ->
                 BitBoard.$fShowPieceType_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
f417d32df3225e12d27a8db2fbbc5424
  $fShowPieceType_$cshowList ::
    [BitBoard.PieceType] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ BitBoard.PieceType
                   BitBoard.$w$cshowsPrec) -}
f417d32df3225e12d27a8db2fbbc5424
  $fShowPieceType_$cshowsPrec ::
    GHC.Types.Int -> BitBoard.PieceType -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: BitBoard.PieceType
                   w2 :: GHC.Base.String ->
                 BitBoard.$w$cshowsPrec w1 w2) -}
f417d32df3225e12d27a8db2fbbc5424
  $w$cshowsPrec ::
    BitBoard.PieceType -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: BitBoard.PieceType w1 :: GHC.Base.String ->
                 case w of wild {
                   BitBoard.All
                   -> GHC.Base.++ @ GHC.Types.Char BitBoard.$fShowPieceType7 w1
                   BitBoard.Pawns
                   -> GHC.Base.++ @ GHC.Types.Char BitBoard.$fShowPieceType6 w1
                   BitBoard.Rooks
                   -> GHC.Base.++ @ GHC.Types.Char BitBoard.$fShowPieceType5 w1
                   BitBoard.Knights
                   -> GHC.Base.++ @ GHC.Types.Char BitBoard.$fShowPieceType4 w1
                   BitBoard.Bishops
                   -> GHC.Base.++ @ GHC.Types.Char BitBoard.$fShowPieceType3 w1
                   BitBoard.Queens
                   -> GHC.Base.++ @ GHC.Types.Char BitBoard.$fShowPieceType2 w1
                   BitBoard.Kings
                   -> GHC.Base.++ @ GHC.Types.Char BitBoard.$fShowPieceType1 w1 }) -}
f417d32df3225e12d27a8db2fbbc5424
  $w$ctoEnum :: GHC.Prim.Int# -> BitBoard.PieceType
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> BitBoard.$fEnumPieceType8 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 6) of wild1 {
                        GHC.Types.False -> BitBoard.$fEnumPieceType8 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ BitBoard.PieceType ww } }) -}
7ccf2c994eded66d3c115231d1075391
  $wbitBoardToDoc ::
    GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> [Text.PrettyPrint.ANSI.Leijen.Doc]
  {- Arity: 12,
     Strictness: <L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Word#
                   ww1 :: GHC.Prim.Word#
                   ww2 :: GHC.Prim.Word#
                   ww3 :: GHC.Prim.Word#
                   ww4 :: GHC.Prim.Word#
                   ww5 :: GHC.Prim.Word#
                   ww6 :: GHC.Prim.Word#
                   ww7 :: GHC.Prim.Word#
                   ww8 :: GHC.Prim.Word#
                   ww9 :: GHC.Prim.Word#
                   ww10 :: GHC.Prim.Word#
                   ww11 :: GHC.Prim.Word# ->
                 GHC.Base.map
                   @ [GHC.Types.Char]
                   @ Text.PrettyPrint.ANSI.Leijen.Doc
                   BitBoard.$fShowBitBoard20
                   (BitBoard.$fShowBitBoard_splitEvery8
                      BitBoard.$fShowBitBoard19
                      (GHC.List.reverse1
                         @ GHC.Types.Char
                         (Data.IntMap.Base.elems
                            @ GHC.Types.Char
                            (Data.IntMap.Base.unions1
                               @ GHC.Types.Char
                               (Data.IntMap.Base.Nil @ GHC.Types.Char)
                               (GHC.Types.:
                                  @ (Data.IntMap.Base.IntMap GHC.Types.Char)
                                  (BitBoard.$wlvl (GHC.Word.W64# ww) BitBoard.$fShowBitBoard18)
                                  (GHC.Types.:
                                     @ (Data.IntMap.Base.IntMap GHC.Types.Char)
                                     (BitBoard.$wlvl (GHC.Word.W64# ww1) BitBoard.$fShowBitBoard17)
                                     (GHC.Types.:
                                        @ (Data.IntMap.Base.IntMap GHC.Types.Char)
                                        (BitBoard.$wlvl
                                           (GHC.Word.W64# ww2)
                                           BitBoard.$fShowBitBoard16)
                                        (GHC.Types.:
                                           @ (Data.IntMap.Base.IntMap GHC.Types.Char)
                                           (BitBoard.$wlvl
                                              (GHC.Word.W64# ww3)
                                              BitBoard.$fShowBitBoard15)
                                           (GHC.Types.:
                                              @ (Data.IntMap.Base.IntMap GHC.Types.Char)
                                              (BitBoard.$wlvl
                                                 (GHC.Word.W64# ww4)
                                                 BitBoard.$fShowBitBoard14)
                                              (GHC.Types.:
                                                 @ (Data.IntMap.Base.IntMap GHC.Types.Char)
                                                 (BitBoard.$wlvl
                                                    (GHC.Word.W64# ww5)
                                                    BitBoard.$fShowBitBoard13)
                                                 (GHC.Types.:
                                                    @ (Data.IntMap.Base.IntMap GHC.Types.Char)
                                                    (BitBoard.$wlvl
                                                       (GHC.Word.W64# ww6)
                                                       BitBoard.$fShowBitBoard12)
                                                    (GHC.Types.:
                                                       @ (Data.IntMap.Base.IntMap GHC.Types.Char)
                                                       (BitBoard.$wlvl
                                                          (GHC.Word.W64# ww7)
                                                          BitBoard.$fShowBitBoard11)
                                                       (GHC.Types.:
                                                          @ (Data.IntMap.Base.IntMap GHC.Types.Char)
                                                          (BitBoard.$wlvl
                                                             (GHC.Word.W64# ww8)
                                                             BitBoard.$fShowBitBoard10)
                                                          (GHC.Types.:
                                                             @ (Data.IntMap.Base.IntMap
                                                                  GHC.Types.Char)
                                                             (BitBoard.$wlvl
                                                                (GHC.Word.W64# ww9)
                                                                BitBoard.$fShowBitBoard9)
                                                             (GHC.Types.:
                                                                @ (Data.IntMap.Base.IntMap
                                                                     GHC.Types.Char)
                                                                (BitBoard.$wlvl
                                                                   (GHC.Word.W64# ww10)
                                                                   BitBoard.$fShowBitBoard8)
                                                                (GHC.Types.:
                                                                   @ (Data.IntMap.Base.IntMap
                                                                        GHC.Types.Char)
                                                                   (BitBoard.$wlvl
                                                                      (GHC.Word.W64# ww11)
                                                                      BitBoard.$fShowBitBoard7)
                                                                   BitBoard.$fShowBitBoard2))))))))))))))
                         (GHC.Types.[] @ GHC.Types.Char)))) -}
66412f5fc1a7260c47864b2063aff234
  $wlvl ::
    GHC.Word.Word64
    -> GHC.Types.Char -> Data.IntMap.Base.IntMap GHC.Types.Char
  {- Arity: 2, Strictness: <L,U(U)><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Word.Word64 ww1 :: GHC.Types.Char ->
                 letrec {
                   go7 :: [GHC.Types.Int] -> [(Data.IntSet.Base.Key, GHC.Types.Char)]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ ds :: [GHC.Types.Int] ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ (Data.IntSet.Base.Key, GHC.Types.Char)
                       : y ys
                       -> case ww of wild1 { GHC.Word.W64# x# ->
                          case y of wild2 { GHC.Types.I# i# ->
                          case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.>=# i# 64) of wild3 {
                            GHC.Types.False
                            -> case GHC.Prim.and#
                                      x#
                                      (GHC.Prim.uncheckedShiftL# __word 1 i#) of wild4 {
                                 DEFAULT
                                 -> GHC.Types.:
                                      @ (Data.IntSet.Base.Key, GHC.Types.Char)
                                      (wild2, ww1)
                                      (go7 ys)
                                 __word 0 -> go7 ys }
                            GHC.Types.True -> go7 ys } } } }
                 } in
                 case go7 BitBoard.$fShowBitBoard6 of wild {
                   [] -> Data.IntMap.Base.Nil @ GHC.Types.Char
                   : z0 zs0
                   -> case z0 of ww2 { (,) ww3 ww4 ->
                      case ww3 of ww5 { GHC.Types.I# ww6 ->
                      Data.IntMap.Strict.$wwork
                        @ GHC.Types.Char
                        ww6
                        ww4
                        zs0
                        (Data.IntMap.Strict.Nada @ GHC.Types.Char) } } }) -}
7fafd364ff8efa2da1f30892cf3afe55
  type role AllColors phantom
  data AllColors (p :: BitBoard.PieceType)
    = AllColors {black :: {-# UNPACK #-}GHC.Word.Word64,
                 white :: {-# UNPACK #-}GHC.Word.Word64,
                 both :: {-# UNPACK #-}GHC.Word.Word64}
d9e321f5bae9df77c5aad3bd67235d5d
  data BitBoard
    = BitBoard {pieces :: {-# UNPACK #-}BitBoard.AllColors
                                          'BitBoard.All,
                pawns :: {-# UNPACK #-}BitBoard.AllColors 'BitBoard.Pawns,
                rooks :: {-# UNPACK #-}BitBoard.AllColors 'BitBoard.Rooks,
                knights :: {-# UNPACK #-}BitBoard.AllColors 'BitBoard.Knights,
                bishops :: {-# UNPACK #-}BitBoard.AllColors 'BitBoard.Bishops,
                queens :: {-# UNPACK #-}BitBoard.AllColors 'BitBoard.Queens,
                kings :: {-# UNPACK #-}BitBoard.AllColors 'BitBoard.Kings}
f417d32df3225e12d27a8db2fbbc5424
  data PieceType
    = All | Pawns | Rooks | Knights | Bishops | Queens | Kings
    Promotable
d334d1caee963f2fd02f14ed7dbeb9c2
  bishops ::
    BitBoard.BitBoard -> BitBoard.AllColors 'BitBoard.Bishops
  RecSel BitBoard.BitBoard
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S,1*U(A,A,A,A,A,A,A,A,A,A,A,A,U,U,U,A,A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: BitBoard.BitBoard ->
                 case ds of wild { BitBoard.BitBoard dt dt1 dt2 dt3 dt4 dt5 dt6 dt7 dt8 dt9 dt10 dt11 dt12 dt13 dt14 dt15 dt16 dt17 dt18 dt19 dt20 ->
                 BitBoard.AllColors @ 'BitBoard.Bishops dt12 dt13 dt14 }) -}
a654da33b6a60b7eb1f3cb3540e4796d
  bitBoardToDoc ::
    BitBoard.BitBoard -> [Text.PrettyPrint.ANSI.Leijen.Doc]
  {- Arity: 1,
     Strictness: <S,1*U(A,A,A,U,U,A,U,U,A,U,U,A,U,U,A,U,U,A,U,U,A)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: BitBoard.BitBoard ->
                 case w of ww { BitBoard.BitBoard ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ww11 ww12 ww13 ww14 ww15 ww16 ww17 ww18 ww19 ww20 ww21 ->
                 BitBoard.$wbitBoardToDoc
                   ww4
                   ww5
                   ww7
                   ww8
                   ww10
                   ww11
                   ww13
                   ww14
                   ww16
                   ww17
                   ww19
                   ww20 }) -}
d5daa0fbb82f1798fcd35f1fd58b7c7b
  black :: BitBoard.AllColors p -> GHC.Word.Word64
  RecSel BitBoard.AllColors
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ (p :: BitBoard.PieceType) ds :: BitBoard.AllColors p ->
                 case ds of wild { BitBoard.AllColors dt dt1 dt2 ->
                 GHC.Word.W64# dt }) -}
d2481704520df5f8dc0988703848860d
  both :: BitBoard.AllColors p -> GHC.Word.Word64
  RecSel BitBoard.AllColors
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(A,A,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ (p :: BitBoard.PieceType) ds :: BitBoard.AllColors p ->
                 case ds of wild { BitBoard.AllColors dt dt1 dt2 ->
                 GHC.Word.W64# dt2 }) -}
b5c998c052c85862c40f45127760d2ce
  emptyBoard :: BitBoard.BitBoard
  {- HasNoCafRefs,
     Unfolding: (BitBoard.BitBoard
                   __word 0
                   __word 0
                   __word 0
                   __word 0
                   __word 0
                   __word 0
                   __word 0
                   __word 0
                   __word 0
                   __word 0
                   __word 0
                   __word 0
                   __word 0
                   __word 0
                   __word 0
                   __word 0
                   __word 0
                   __word 0
                   __word 0
                   __word 0
                   __word 0) -}
5e2d0c6397b39afadf48c9e64c688a52
  kings :: BitBoard.BitBoard -> BitBoard.AllColors 'BitBoard.Kings
  RecSel BitBoard.BitBoard
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S,1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: BitBoard.BitBoard ->
                 case ds of wild { BitBoard.BitBoard dt dt1 dt2 dt3 dt4 dt5 dt6 dt7 dt8 dt9 dt10 dt11 dt12 dt13 dt14 dt15 dt16 dt17 dt18 dt19 dt20 ->
                 BitBoard.AllColors @ 'BitBoard.Kings dt18 dt19 dt20 }) -}
6a9ad008279756688135d058a0ae1ddb
  knights ::
    BitBoard.BitBoard -> BitBoard.AllColors 'BitBoard.Knights
  RecSel BitBoard.BitBoard
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S,1*U(A,A,A,A,A,A,A,A,A,U,U,U,A,A,A,A,A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: BitBoard.BitBoard ->
                 case ds of wild { BitBoard.BitBoard dt dt1 dt2 dt3 dt4 dt5 dt6 dt7 dt8 dt9 dt10 dt11 dt12 dt13 dt14 dt15 dt16 dt17 dt18 dt19 dt20 ->
                 BitBoard.AllColors @ 'BitBoard.Knights dt9 dt10 dt11 }) -}
d4077106a3737c430714c19db657bcfa
  pawns :: BitBoard.BitBoard -> BitBoard.AllColors 'BitBoard.Pawns
  RecSel BitBoard.BitBoard
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S,1*U(A,A,A,U,U,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: BitBoard.BitBoard ->
                 case ds of wild { BitBoard.BitBoard dt dt1 dt2 dt3 dt4 dt5 dt6 dt7 dt8 dt9 dt10 dt11 dt12 dt13 dt14 dt15 dt16 dt17 dt18 dt19 dt20 ->
                 BitBoard.AllColors @ 'BitBoard.Pawns dt3 dt4 dt5 }) -}
7121cd26a65c44cf2aa8bc4f638b2410
  pieces :: BitBoard.BitBoard -> BitBoard.AllColors 'BitBoard.All
  RecSel BitBoard.BitBoard
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S,1*U(U,U,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: BitBoard.BitBoard ->
                 case ds of wild { BitBoard.BitBoard dt dt1 dt2 dt3 dt4 dt5 dt6 dt7 dt8 dt9 dt10 dt11 dt12 dt13 dt14 dt15 dt16 dt17 dt18 dt19 dt20 ->
                 BitBoard.AllColors @ 'BitBoard.All dt dt1 dt2 }) -}
2db79008e68555eac1950de170da18e7
  queens :: BitBoard.BitBoard -> BitBoard.AllColors 'BitBoard.Queens
  RecSel BitBoard.BitBoard
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S,1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,U,U,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: BitBoard.BitBoard ->
                 case ds of wild { BitBoard.BitBoard dt dt1 dt2 dt3 dt4 dt5 dt6 dt7 dt8 dt9 dt10 dt11 dt12 dt13 dt14 dt15 dt16 dt17 dt18 dt19 dt20 ->
                 BitBoard.AllColors @ 'BitBoard.Queens dt15 dt16 dt17 }) -}
a9e3fe8319db9539256deb36d6b5861e
  rooks :: BitBoard.BitBoard -> BitBoard.AllColors 'BitBoard.Rooks
  RecSel BitBoard.BitBoard
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S,1*U(A,A,A,A,A,A,U,U,U,A,A,A,A,A,A,A,A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: BitBoard.BitBoard ->
                 case ds of wild { BitBoard.BitBoard dt dt1 dt2 dt3 dt4 dt5 dt6 dt7 dt8 dt9 dt10 dt11 dt12 dt13 dt14 dt15 dt16 dt17 dt18 dt19 dt20 ->
                 BitBoard.AllColors @ 'BitBoard.Rooks dt6 dt7 dt8 }) -}
0209fc87a578eff868f1191f4604fc35
  white :: BitBoard.AllColors p -> GHC.Word.Word64
  RecSel BitBoard.AllColors
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(A,U,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ (p :: BitBoard.PieceType) ds :: BitBoard.AllColors p ->
                 case ds of wild { BitBoard.AllColors dt dt1 dt2 ->
                 GHC.Word.W64# dt1 }) -}
instance GHC.Enum.Enum [BitBoard.PieceType]
  = BitBoard.$fEnumPieceType
instance GHC.Classes.Eq [BitBoard.PieceType]
  = BitBoard.$fEqPieceType
instance GHC.Classes.Ord [BitBoard.PieceType]
  = BitBoard.$fOrdPieceType
instance GHC.Show.Show [BitBoard.BitBoard]
  = BitBoard.$fShowBitBoard
instance GHC.Show.Show [BitBoard.PieceType]
  = BitBoard.$fShowPieceType
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

