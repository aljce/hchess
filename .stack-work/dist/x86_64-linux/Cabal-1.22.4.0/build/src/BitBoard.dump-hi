
==================== FINAL INTERFACE ====================
2016-01-03 04:23:15.7855 UTC

interface hches_3PXdSEAhhp2JIrhYvA7RvZ:BitBoard 7102
  interface hash: 2184decac2b0f77b56b3b3c192c44638
  ABI hash: 1d34c765e2913aef164a6d247daf4736
  export-list hash: 6eb44feaf65c4fa3bf03a262b000e28d
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 613f9f74249a44145e3c1e766ddf802d
  sig of: Nothing
  used TH splices: False
  where
exports:
  BitBoard.bitBoardToDoc
  BitBoard.emptyBoard
  BitBoard.AllColors{BitBoard.AllColors BitBoard.black BitBoard.both BitBoard.white}
  BitBoard.BitBoard{BitBoard.BitBoard BitBoard.bishops BitBoard.kings BitBoard.knights BitBoard.pawns BitBoard.pieces BitBoard.queens BitBoard.rooks}
  BitBoard.PieceType{BitBoard.All BitBoard.Bishops BitBoard.Kings BitBoard.Knights BitBoard.Pawns BitBoard.Queens BitBoard.Rooks}
module dependencies:
package dependencies: ansi-terminal-0.6.2.3@ansit_KW0LUY2zB7JCYzE4ZYrwBg
                      ansi-wl-pprint-0.6.7.3@ansiw_KPlSW7tbqXS51Lj59n3FC4
                      array-0.5.1.0@array_E0sTtauuKsGDLZoT7lTbgZ base-4.8.1.0
                      containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN
                      deepseq-1.4.1.1@deeps_LbCWUlehDDeLxurARKDH5o ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
orphans: base-4.8.1.0:GHC.Base base-4.8.1.0:GHC.Float
family instance modules: base-4.8.1.0:Control.Applicative
                         base-4.8.1.0:Data.Either base-4.8.1.0:Data.Functor.Identity
                         base-4.8.1.0:Data.Monoid base-4.8.1.0:Data.Type.Equality
                         base-4.8.1.0:Data.Void base-4.8.1.0:GHC.Exts
                         base-4.8.1.0:GHC.Generics
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntMap.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntSet.Base
import  -/  ansi-wl-pprint-0.6.7.3@ansiw_KPlSW7tbqXS51Lj59n3FC4:Text.PrettyPrint.ANSI.Leijen 8c4176551c95005818f5e57d74e5ea69
import  -/  base-4.8.1.0:Data.Bits 5341167fdd5958c2b3f0dac8924f1efd
import  -/  base-4.8.1.0:Data.Word 448c480b98a0c18988a37db5ab829b22
import  -/  base-4.8.1.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.1.0:GHC.Enum d0db4d619cd8916cc7a23444816222af
import  -/  base-4.8.1.0:GHC.List f31ed8784b3e05f1397195751f7d74ea
import  -/  base-4.8.1.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.1.0:GHC.Show b8c65ca3124f92a166c9f05120382442
import  -/  base-4.8.1.0:GHC.Word ef6286c279d61931eb675109b4b93579
import  -/  base-4.8.1.0:Prelude 518f762991bc287d78f21a73c974da1f
import  -/  containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntMap.Base 41288a612f7bbd399bc0bb07f2f75738
import  -/  containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntMap.Strict 75157829e2fd1bf3aaf8a4fd3bd7d8f4
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  ghc-prim-0.4.0.0:GHC.Types 6b27fb3fdbd0e3f0925a4496c66513bb
34da54d75a2bd913b922a16a181dfcb6
  $fEnumPieceType :: GHC.Enum.Enum BitBoard.PieceType
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.PieceType
                  BitBoard.$fEnumPieceType_$csucc
                  BitBoard.$fEnumPieceType_$cpred
                  BitBoard.$fEnumPieceType_$ctoEnum
                  BitBoard.$fEnumPieceType_$cfromEnum
                  BitBoard.$fEnumPieceType_$cenumFrom
                  BitBoard.$fEnumPieceType_$cenumFromThen
                  BitBoard.$fEnumPieceType_$cenumFromTo
                  BitBoard.$fEnumPieceType_$cenumFromThenTo -}
34da54d75a2bd913b922a16a181dfcb6
  $fEnumPieceType1 :: [BitBoard.PieceType]
  {- Unfolding: (BitBoard.$fEnumPieceType_go7 6) -}
34da54d75a2bd913b922a16a181dfcb6
  $fEnumPieceType10 :: BitBoard.PieceType
  {- Strictness: b -}
34da54d75a2bd913b922a16a181dfcb6
  $fEnumPieceType2 :: [BitBoard.PieceType]
  {- Unfolding: (BitBoard.$fEnumPieceType_go8 5) -}
34da54d75a2bd913b922a16a181dfcb6
  $fEnumPieceType3 :: [BitBoard.PieceType]
  {- Unfolding: (BitBoard.$fEnumPieceType_go9 4) -}
34da54d75a2bd913b922a16a181dfcb6
  $fEnumPieceType4 :: [BitBoard.PieceType]
  {- Unfolding: (BitBoard.$fEnumPieceType_go10 3) -}
34da54d75a2bd913b922a16a181dfcb6
  $fEnumPieceType5 :: [BitBoard.PieceType]
  {- Unfolding: (BitBoard.$fEnumPieceType_go11 2) -}
34da54d75a2bd913b922a16a181dfcb6
  $fEnumPieceType6 :: [BitBoard.PieceType]
  {- Unfolding: (BitBoard.$fEnumPieceType_go12 1) -}
34da54d75a2bd913b922a16a181dfcb6
  $fEnumPieceType7 :: [BitBoard.PieceType]
  {- Unfolding: (BitBoard.$fEnumPieceType_go13 0) -}
34da54d75a2bd913b922a16a181dfcb6
  $fEnumPieceType8 :: GHC.Prim.Int# -> BitBoard.PieceType
  {- Arity: 1, Strictness: <L,U>b -}
34da54d75a2bd913b922a16a181dfcb6
  $fEnumPieceType9 :: BitBoard.PieceType
  {- Strictness: b -}
34da54d75a2bd913b922a16a181dfcb6
  $fEnumPieceType_$cenumFrom ::
    BitBoard.PieceType -> [BitBoard.PieceType]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a :: BitBoard.PieceType ->
                 case a of wild {
                   BitBoard.All -> BitBoard.$fEnumPieceType7
                   BitBoard.Pawns -> BitBoard.$fEnumPieceType6
                   BitBoard.Rooks -> BitBoard.$fEnumPieceType5
                   BitBoard.Knights -> BitBoard.$fEnumPieceType4
                   BitBoard.Bishops -> BitBoard.$fEnumPieceType3
                   BitBoard.Queens -> BitBoard.$fEnumPieceType2
                   BitBoard.Kings -> BitBoard.$fEnumPieceType1 }) -}
34da54d75a2bd913b922a16a181dfcb6
  $fEnumPieceType_$cenumFromThen ::
    BitBoard.PieceType -> BitBoard.PieceType -> [BitBoard.PieceType]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a :: BitBoard.PieceType b :: BitBoard.PieceType ->
                 let {
                   $j :: GHC.Prim.Int# -> [BitBoard.PieceType]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [BitBoard.PieceType]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [BitBoard.PieceType]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [BitBoard.PieceType]
                                    BitBoard.$fEnumPieceType_c
                                    (GHC.Types.[] @ BitBoard.PieceType)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [BitBoard.PieceType]
                                    BitBoard.$fEnumPieceType_c
                                    (GHC.Types.[] @ BitBoard.PieceType)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 6 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       BitBoard.All -> $j1 0
                       BitBoard.Pawns -> $j1 1
                       BitBoard.Rooks -> $j1 2
                       BitBoard.Knights -> $j1 3
                       BitBoard.Bishops -> $j1 4
                       BitBoard.Queens -> $j1 5
                       BitBoard.Kings -> $j1 6 }
                 } in
                 case a of wild {
                   BitBoard.All -> $j 0
                   BitBoard.Pawns -> $j 1
                   BitBoard.Rooks -> $j 2
                   BitBoard.Knights -> $j 3
                   BitBoard.Bishops -> $j 4
                   BitBoard.Queens -> $j 5
                   BitBoard.Kings -> $j 6 }) -}
34da54d75a2bd913b922a16a181dfcb6
  $fEnumPieceType_$cenumFromThenTo ::
    BitBoard.PieceType
    -> BitBoard.PieceType -> BitBoard.PieceType -> [BitBoard.PieceType]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U> -}
34da54d75a2bd913b922a16a181dfcb6
  $fEnumPieceType_$cenumFromTo ::
    BitBoard.PieceType -> BitBoard.PieceType -> [BitBoard.PieceType]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: BitBoard.PieceType y :: BitBoard.PieceType ->
                 let {
                   $j :: GHC.Prim.Int# -> [BitBoard.PieceType]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       BitBoard.All
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> BitBoard.$fEnumPieceType_go6 x1
                            GHC.Types.True -> GHC.Types.[] @ BitBoard.PieceType }
                       BitBoard.Pawns
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> BitBoard.$fEnumPieceType_go5 x1
                            GHC.Types.True -> GHC.Types.[] @ BitBoard.PieceType }
                       BitBoard.Rooks
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 2) of wild1 {
                            GHC.Types.False -> BitBoard.$fEnumPieceType_go4 x1
                            GHC.Types.True -> GHC.Types.[] @ BitBoard.PieceType }
                       BitBoard.Knights
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 3) of wild1 {
                            GHC.Types.False -> BitBoard.$fEnumPieceType_go3 x1
                            GHC.Types.True -> GHC.Types.[] @ BitBoard.PieceType }
                       BitBoard.Bishops
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 4) of wild1 {
                            GHC.Types.False -> BitBoard.$fEnumPieceType_go2 x1
                            GHC.Types.True -> GHC.Types.[] @ BitBoard.PieceType }
                       BitBoard.Queens
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 5) of wild1 {
                            GHC.Types.False -> BitBoard.$fEnumPieceType_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ BitBoard.PieceType }
                       BitBoard.Kings
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 6) of wild1 {
                            GHC.Types.False -> BitBoard.$fEnumPieceType_go x1
                            GHC.Types.True -> GHC.Types.[] @ BitBoard.PieceType } }
                 } in
                 case x of wild {
                   BitBoard.All -> $j 0
                   BitBoard.Pawns -> $j 1
                   BitBoard.Rooks -> $j 2
                   BitBoard.Knights -> $j 3
                   BitBoard.Bishops -> $j 4
                   BitBoard.Queens -> $j 5
                   BitBoard.Kings -> $j 6 }) -}
34da54d75a2bd913b922a16a181dfcb6
  $fEnumPieceType_$cfromEnum :: BitBoard.PieceType -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: BitBoard.PieceType ->
                 case w of wild {
                   BitBoard.All -> GHC.Types.I# 0
                   BitBoard.Pawns -> GHC.Types.I# 1
                   BitBoard.Rooks -> GHC.Types.I# 2
                   BitBoard.Knights -> GHC.Types.I# 3
                   BitBoard.Bishops -> GHC.Types.I# 4
                   BitBoard.Queens -> GHC.Types.I# 5
                   BitBoard.Kings -> GHC.Types.I# 6 }) -}
34da54d75a2bd913b922a16a181dfcb6
  $fEnumPieceType_$cpred :: BitBoard.PieceType -> BitBoard.PieceType
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a :: BitBoard.PieceType ->
                 case a of wild {
                   BitBoard.All -> BitBoard.$fEnumPieceType9
                   BitBoard.Pawns -> BitBoard.All
                   BitBoard.Rooks -> BitBoard.Pawns
                   BitBoard.Knights -> BitBoard.Rooks
                   BitBoard.Bishops -> BitBoard.Knights
                   BitBoard.Queens -> BitBoard.Bishops
                   BitBoard.Kings -> BitBoard.Queens }) -}
34da54d75a2bd913b922a16a181dfcb6
  $fEnumPieceType_$csucc :: BitBoard.PieceType -> BitBoard.PieceType
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a :: BitBoard.PieceType ->
                 case a of wild {
                   BitBoard.All -> BitBoard.Pawns
                   BitBoard.Pawns -> BitBoard.Rooks
                   BitBoard.Rooks -> BitBoard.Knights
                   BitBoard.Knights -> BitBoard.Bishops
                   BitBoard.Bishops -> BitBoard.Queens
                   BitBoard.Queens -> BitBoard.Kings
                   BitBoard.Kings -> BitBoard.$fEnumPieceType10 }) -}
34da54d75a2bd913b922a16a181dfcb6
  $fEnumPieceType_$ctoEnum :: GHC.Types.Int -> BitBoard.PieceType
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 -> BitBoard.$w$ctoEnum ww1 }) -}
34da54d75a2bd913b922a16a181dfcb6
  $fEnumPieceType_c ::
    GHC.Types.Int -> [BitBoard.PieceType] -> [BitBoard.PieceType]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [BitBoard.PieceType] ->
                 GHC.Types.:
                   @ BitBoard.PieceType
                   (case x of wild { GHC.Types.I# a ->
                    GHC.Prim.tagToEnum# @ BitBoard.PieceType a })
                   ys) -}
34da54d75a2bd913b922a16a181dfcb6
  $fEnumPieceType_go :: GHC.Prim.Int# -> [BitBoard.PieceType]
  {- Arity: 1, Strictness: <L,U> -}
34da54d75a2bd913b922a16a181dfcb6
  $fEnumPieceType_go1 :: GHC.Prim.Int# -> [BitBoard.PieceType]
  {- Arity: 1, Strictness: <L,U> -}
34da54d75a2bd913b922a16a181dfcb6
  $fEnumPieceType_go10 :: GHC.Prim.Int# -> [BitBoard.PieceType]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
34da54d75a2bd913b922a16a181dfcb6
  $fEnumPieceType_go11 :: GHC.Prim.Int# -> [BitBoard.PieceType]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
34da54d75a2bd913b922a16a181dfcb6
  $fEnumPieceType_go12 :: GHC.Prim.Int# -> [BitBoard.PieceType]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
34da54d75a2bd913b922a16a181dfcb6
  $fEnumPieceType_go13 :: GHC.Prim.Int# -> [BitBoard.PieceType]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
34da54d75a2bd913b922a16a181dfcb6
  $fEnumPieceType_go2 :: GHC.Prim.Int# -> [BitBoard.PieceType]
  {- Arity: 1, Strictness: <L,U> -}
34da54d75a2bd913b922a16a181dfcb6
  $fEnumPieceType_go3 :: GHC.Prim.Int# -> [BitBoard.PieceType]
  {- Arity: 1, Strictness: <L,U> -}
34da54d75a2bd913b922a16a181dfcb6
  $fEnumPieceType_go4 :: GHC.Prim.Int# -> [BitBoard.PieceType]
  {- Arity: 1, Strictness: <L,U> -}
34da54d75a2bd913b922a16a181dfcb6
  $fEnumPieceType_go5 :: GHC.Prim.Int# -> [BitBoard.PieceType]
  {- Arity: 1, Strictness: <L,U> -}
34da54d75a2bd913b922a16a181dfcb6
  $fEnumPieceType_go6 :: GHC.Prim.Int# -> [BitBoard.PieceType]
  {- Arity: 1, Strictness: <L,U> -}
34da54d75a2bd913b922a16a181dfcb6
  $fEnumPieceType_go7 :: GHC.Prim.Int# -> [BitBoard.PieceType]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
34da54d75a2bd913b922a16a181dfcb6
  $fEnumPieceType_go8 :: GHC.Prim.Int# -> [BitBoard.PieceType]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
34da54d75a2bd913b922a16a181dfcb6
  $fEnumPieceType_go9 :: GHC.Prim.Int# -> [BitBoard.PieceType]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
34da54d75a2bd913b922a16a181dfcb6
  $fEqPieceType :: GHC.Classes.Eq BitBoard.PieceType
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.PieceType
                  BitBoard.$fEqPieceType_$c==
                  BitBoard.$fEqPieceType_$c/= -}
34da54d75a2bd913b922a16a181dfcb6
  $fEqPieceType_$c/= ::
    BitBoard.PieceType -> BitBoard.PieceType -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a :: BitBoard.PieceType b :: BitBoard.PieceType ->
                 case a of wild {
                   BitBoard.All
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True BitBoard.All -> GHC.Types.False }
                   BitBoard.Pawns
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True BitBoard.Pawns -> GHC.Types.False }
                   BitBoard.Rooks
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True BitBoard.Rooks -> GHC.Types.False }
                   BitBoard.Knights
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True BitBoard.Knights -> GHC.Types.False }
                   BitBoard.Bishops
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True BitBoard.Bishops -> GHC.Types.False }
                   BitBoard.Queens
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True BitBoard.Queens -> GHC.Types.False }
                   BitBoard.Kings
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True BitBoard.Kings -> GHC.Types.False } }) -}
34da54d75a2bd913b922a16a181dfcb6
  $fEqPieceType_$c== ::
    BitBoard.PieceType -> BitBoard.PieceType -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: BitBoard.PieceType ds1 :: BitBoard.PieceType ->
                 case ds of wild {
                   BitBoard.All
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False BitBoard.All -> GHC.Types.True }
                   BitBoard.Pawns
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False BitBoard.Pawns -> GHC.Types.True }
                   BitBoard.Rooks
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False BitBoard.Rooks -> GHC.Types.True }
                   BitBoard.Knights
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False BitBoard.Knights -> GHC.Types.True }
                   BitBoard.Bishops
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False BitBoard.Bishops -> GHC.Types.True }
                   BitBoard.Queens
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False BitBoard.Queens -> GHC.Types.True }
                   BitBoard.Kings
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False BitBoard.Kings -> GHC.Types.True } }) -}
34da54d75a2bd913b922a16a181dfcb6
  $fOrdPieceType :: GHC.Classes.Ord BitBoard.PieceType
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.PieceType
                  BitBoard.$fEqPieceType
                  BitBoard.$fOrdPieceType_$ccompare
                  BitBoard.$fOrdPieceType_$c<
                  BitBoard.$fOrdPieceType_$c<=
                  BitBoard.$fOrdPieceType_$c>
                  BitBoard.$fOrdPieceType_$c>=
                  BitBoard.$fOrdPieceType_$cmax
                  BitBoard.$fOrdPieceType_$cmin -}
34da54d75a2bd913b922a16a181dfcb6
  $fOrdPieceType_$c< ::
    BitBoard.PieceType -> BitBoard.PieceType -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a :: BitBoard.PieceType b :: BitBoard.PieceType ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     case b of wild {
                       BitBoard.All
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 0)
                       BitBoard.Pawns
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 1)
                       BitBoard.Rooks
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 2)
                       BitBoard.Knights
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 3)
                       BitBoard.Bishops
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 4)
                       BitBoard.Queens
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 5)
                       BitBoard.Kings
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 6) }
                 } in
                 case a of wild {
                   BitBoard.All -> $j 0
                   BitBoard.Pawns -> $j 1
                   BitBoard.Rooks -> $j 2
                   BitBoard.Knights -> $j 3
                   BitBoard.Bishops -> $j 4
                   BitBoard.Queens -> $j 5
                   BitBoard.Kings -> $j 6 }) -}
34da54d75a2bd913b922a16a181dfcb6
  $fOrdPieceType_$c<= ::
    BitBoard.PieceType -> BitBoard.PieceType -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a :: BitBoard.PieceType b :: BitBoard.PieceType ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     case b of wild {
                       BitBoard.All
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 0)
                       BitBoard.Pawns
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 1)
                       BitBoard.Rooks
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 2)
                       BitBoard.Knights
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 3)
                       BitBoard.Bishops
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 4)
                       BitBoard.Queens
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 5)
                       BitBoard.Kings
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 6) }
                 } in
                 case a of wild {
                   BitBoard.All -> $j 0
                   BitBoard.Pawns -> $j 1
                   BitBoard.Rooks -> $j 2
                   BitBoard.Knights -> $j 3
                   BitBoard.Bishops -> $j 4
                   BitBoard.Queens -> $j 5
                   BitBoard.Kings -> $j 6 }) -}
34da54d75a2bd913b922a16a181dfcb6
  $fOrdPieceType_$c> ::
    BitBoard.PieceType -> BitBoard.PieceType -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a :: BitBoard.PieceType b :: BitBoard.PieceType ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     case b of wild {
                       BitBoard.All
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 0)
                       BitBoard.Pawns
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 1)
                       BitBoard.Rooks
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 2)
                       BitBoard.Knights
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 3)
                       BitBoard.Bishops
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 4)
                       BitBoard.Queens
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 5)
                       BitBoard.Kings
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 6) }
                 } in
                 case a of wild {
                   BitBoard.All -> $j 0
                   BitBoard.Pawns -> $j 1
                   BitBoard.Rooks -> $j 2
                   BitBoard.Knights -> $j 3
                   BitBoard.Bishops -> $j 4
                   BitBoard.Queens -> $j 5
                   BitBoard.Kings -> $j 6 }) -}
34da54d75a2bd913b922a16a181dfcb6
  $fOrdPieceType_$c>= ::
    BitBoard.PieceType -> BitBoard.PieceType -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a :: BitBoard.PieceType b :: BitBoard.PieceType ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     case b of wild {
                       BitBoard.All
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 0)
                       BitBoard.Pawns
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 1)
                       BitBoard.Rooks
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 2)
                       BitBoard.Knights
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 3)
                       BitBoard.Bishops
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 4)
                       BitBoard.Queens
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 5)
                       BitBoard.Kings
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 6) }
                 } in
                 case a of wild {
                   BitBoard.All -> $j 0
                   BitBoard.Pawns -> $j 1
                   BitBoard.Rooks -> $j 2
                   BitBoard.Knights -> $j 3
                   BitBoard.Bishops -> $j 4
                   BitBoard.Queens -> $j 5
                   BitBoard.Kings -> $j 6 }) -}
34da54d75a2bd913b922a16a181dfcb6
  $fOrdPieceType_$ccompare ::
    BitBoard.PieceType -> BitBoard.PieceType -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a :: BitBoard.PieceType b :: BitBoard.PieceType ->
                 case a of wild {
                   BitBoard.All
                   -> case b of wild1 {
                        BitBoard.All -> GHC.Types.EQ
                        BitBoard.Pawns -> GHC.Types.LT
                        BitBoard.Rooks -> GHC.Types.LT
                        BitBoard.Knights -> GHC.Types.LT
                        BitBoard.Bishops -> GHC.Types.LT
                        BitBoard.Queens -> GHC.Types.LT
                        BitBoard.Kings -> GHC.Types.LT }
                   BitBoard.Pawns
                   -> case b of wild1 {
                        BitBoard.All -> GHC.Types.GT
                        BitBoard.Pawns -> GHC.Types.EQ
                        BitBoard.Rooks -> GHC.Types.LT
                        BitBoard.Knights -> GHC.Types.LT
                        BitBoard.Bishops -> GHC.Types.LT
                        BitBoard.Queens -> GHC.Types.LT
                        BitBoard.Kings -> GHC.Types.LT }
                   BitBoard.Rooks
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        BitBoard.Rooks -> GHC.Types.EQ
                        BitBoard.Knights -> GHC.Types.LT
                        BitBoard.Bishops -> GHC.Types.LT
                        BitBoard.Queens -> GHC.Types.LT
                        BitBoard.Kings -> GHC.Types.LT }
                   BitBoard.Knights
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        BitBoard.Knights -> GHC.Types.EQ
                        BitBoard.Bishops -> GHC.Types.LT
                        BitBoard.Queens -> GHC.Types.LT
                        BitBoard.Kings -> GHC.Types.LT }
                   BitBoard.Bishops
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        BitBoard.Bishops -> GHC.Types.EQ
                        BitBoard.Queens -> GHC.Types.LT
                        BitBoard.Kings -> GHC.Types.LT }
                   BitBoard.Queens
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        BitBoard.Queens -> GHC.Types.EQ
                        BitBoard.Kings -> GHC.Types.LT }
                   BitBoard.Kings
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT BitBoard.Kings -> GHC.Types.EQ } }) -}
34da54d75a2bd913b922a16a181dfcb6
  $fOrdPieceType_$cmax ::
    BitBoard.PieceType -> BitBoard.PieceType -> BitBoard.PieceType
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: BitBoard.PieceType y :: BitBoard.PieceType ->
                 case BitBoard.$fOrdPieceType_$c<= x y of wild {
                   GHC.Types.False -> x GHC.Types.True -> y }) -}
34da54d75a2bd913b922a16a181dfcb6
  $fOrdPieceType_$cmin ::
    BitBoard.PieceType -> BitBoard.PieceType -> BitBoard.PieceType
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: BitBoard.PieceType y :: BitBoard.PieceType ->
                 case BitBoard.$fOrdPieceType_$c<= x y of wild {
                   GHC.Types.False -> y GHC.Types.True -> x }) -}
76ff291bd5559725ac43a513632ccddc
  $fShowBitBoard :: GHC.Show.Show BitBoard.BitBoard
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.BitBoard
                  BitBoard.$fShowBitBoard_$cshowsPrec
                  BitBoard.$fShowBitBoard_$cshow
                  BitBoard.$fShowBitBoard_$cshowList -}
76ff291bd5559725ac43a513632ccddc
  $fShowBitBoard1 :: BitBoard.BitBoard -> GHC.Show.ShowS
  {- Arity: 1,
     Strictness: <L,1*U(A,A,A,U,U,A,U,U,A,U,U,A,U,U,A,U,U,A,U,U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: BitBoard.BitBoard ->
                 GHC.Base.++ @ GHC.Types.Char (BitBoard.$fShowBitBoard_$cshow x)) -}
24c672e07a8701a5505d8b48b7d1f98b
  $fShowBitBoard10 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# 'q') -}
a57c7c0761cb946e95881b4ce3d5ae7f
  $fShowBitBoard11 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# 'B') -}
295473c88c92d9cb5db97cb5ad52de23
  $fShowBitBoard12 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# 'b') -}
4dff05fd496506d77c96131df6fe089a
  $fShowBitBoard13 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# 'N') -}
01283de488ea29f8cc57f93efebdb38a
  $fShowBitBoard14 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# 'n') -}
fd49ae45ce4caf93045341c01f1b12c5
  $fShowBitBoard15 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# 'R') -}
04e279458539e4244330f1a879ad1682
  $fShowBitBoard16 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# 'r') -}
a1de3bde87d926feaba5d3b4fe138931
  $fShowBitBoard17 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# 'P') -}
3e27f7a8bad584c93dcd5be93ce3c446
  $fShowBitBoard18 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# 'p') -}
09552921d46f2b01d7912880eab99d25
  $fShowBitBoard19 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (__integer 0) -}
39c3eda0b72c11af6378f549a92cdd75
  $fShowBitBoard2 :: [Data.IntMap.Base.IntMap GHC.Types.Char]
  {- Unfolding: (GHC.Types.:
                   @ (Data.IntMap.Base.IntMap GHC.Types.Char)
                   BitBoard.$fShowBitBoard3
                   (GHC.Types.[] @ (Data.IntMap.Base.IntMap GHC.Types.Char))) -}
49e11c3305040ef71ab278892ebfc7aa
  $fShowBitBoard20 ::
    [GHC.Types.Char] -> Text.PrettyPrint.ANSI.Leijen.Doc
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: [GHC.Types.Char] ->
                 Text.PrettyPrint.ANSI.Leijen.string
                   (GHC.List.reverse @ GHC.Types.Char x)) -}
1d3ed9abbe05a97d60d5764285591716
  $fShowBitBoard3 :: Data.IntMap.Base.IntMap GHC.Types.Char
  {- Unfolding: (BitBoard.$wlvl
                   BitBoard.$fShowBitBoard5
                   BitBoard.$fShowBitBoard4) -}
beceff0a51e76d95b23bc8421e8e2da9
  $fShowBitBoard4 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# ' ') -}
2331820862e29128e8cf3702761373c3
  $fShowBitBoard5 :: GHC.Word.Word64
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Word.W64# __word 18446744073709551615) -}
b7c5e7f41c77ef8d9eb390f130f27152
  $fShowBitBoard6 :: [GHC.Types.Int]
  {- Unfolding: (GHC.Enum.eftInt 0 63) -}
97cafe985e76b70e85e270faec4fda27
  $fShowBitBoard7 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# 'K') -}
36fb2d8b716454e9dee35f5ecd64be5d
  $fShowBitBoard8 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# 'k') -}
cde64a04f1a764fbf7437a3fca2862b4
  $fShowBitBoard9 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# 'Q') -}
76ff291bd5559725ac43a513632ccddc
  $fShowBitBoard_$cshow :: BitBoard.BitBoard -> GHC.Base.String
  {- Arity: 1,
     Strictness: <L,1*U(A,A,A,U,U,A,U,U,A,U,U,A,U,U,A,U,U,A,U,U,A)>,
     Unfolding: (\ x :: BitBoard.BitBoard ->
                 Text.PrettyPrint.ANSI.Leijen.displayS
                   (Text.PrettyPrint.ANSI.Leijen.renderFits
                      Text.PrettyPrint.ANSI.Leijen.fits1
                      Text.PrettyPrint.ANSI.Leijen.$fShowDoc3
                      Text.PrettyPrint.ANSI.Leijen.$fShowDoc2
                      (case x of ww { BitBoard.BitBoard ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ww11 ww12 ww13 ww14 ww15 ww16 ww17 ww18 ww19 ww20 ww21 ->
                       case BitBoard.$wbitBoardToDoc
                              ww4
                              ww5
                              ww7
                              ww8
                              ww10
                              ww11
                              ww13
                              ww14
                              ww16
                              ww17
                              ww19
                              ww20 of wild {
                         [] -> Text.PrettyPrint.ANSI.Leijen.Empty
                         : ipv ipv1
                         -> GHC.List.foldr1_$sfoldr1
                              @ Text.PrettyPrint.ANSI.Leijen.Doc
                              Text.PrettyPrint.ANSI.Leijen.<$>
                              ipv
                              ipv1 } }))
                   (GHC.Types.[] @ GHC.Types.Char)) -}
76ff291bd5559725ac43a513632ccddc
  $fShowBitBoard_$cshowList :: [BitBoard.BitBoard] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ ls :: [BitBoard.BitBoard] s :: GHC.Base.String ->
                 GHC.Show.showList__
                   @ BitBoard.BitBoard
                   BitBoard.$fShowBitBoard1
                   ls
                   s) -}
76ff291bd5559725ac43a513632ccddc
  $fShowBitBoard_$cshowsPrec ::
    GHC.Types.Int -> BitBoard.BitBoard -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ ds :: GHC.Types.Int eta :: BitBoard.BitBoard ->
                 BitBoard.$fShowBitBoard1 eta) -}
8b1dfe624b34a93a8c62d9c611128f3d
  $fShowBitBoard_splitEvery8 ::
    GHC.Integer.Type.Integer -> [GHC.Types.Char] -> [[GHC.Types.Char]]
  {- Arity: 2, Strictness: <S,U><L,U> -}
34da54d75a2bd913b922a16a181dfcb6
  $fShowPieceType :: GHC.Show.Show BitBoard.PieceType
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.PieceType
                  BitBoard.$fShowPieceType_$cshowsPrec
                  BitBoard.$fShowPieceType_$cshow
                  BitBoard.$fShowPieceType_$cshowList -}
bcc505f2e745ed739eed1456388361e2
  $fShowPieceType1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Kings"#) -}
d9bd60e791c2684f1974edf51ad908fc
  $fShowPieceType2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Queens"#) -}
9bdc56a7d5eca4ce303dfe6d32e63ab9
  $fShowPieceType3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Bishops"#) -}
0660e11e4023df89428991692334c096
  $fShowPieceType4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Knights"#) -}
5d5dd0e3534453d7f2c9902089420f51
  $fShowPieceType5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Rooks"#) -}
64184f0f570170446b91db0e572f93ac
  $fShowPieceType6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Pawns"#) -}
6d9ae9a6cb9548408573fa653da60acd
  $fShowPieceType7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "All"#) -}
34da54d75a2bd913b922a16a181dfcb6
  $fShowPieceType_$cshow :: BitBoard.PieceType -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: BitBoard.PieceType ->
                 BitBoard.$fShowPieceType_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
34da54d75a2bd913b922a16a181dfcb6
  $fShowPieceType_$cshowList ::
    [BitBoard.PieceType] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ BitBoard.PieceType
                   BitBoard.$w$cshowsPrec) -}
34da54d75a2bd913b922a16a181dfcb6
  $fShowPieceType_$cshowsPrec ::
    GHC.Types.Int -> BitBoard.PieceType -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: BitBoard.PieceType
                   w2 :: GHC.Base.String ->
                 BitBoard.$w$cshowsPrec w1 w2) -}
34da54d75a2bd913b922a16a181dfcb6
  $w$cshowsPrec ::
    BitBoard.PieceType -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: BitBoard.PieceType w1 :: GHC.Base.String ->
                 case w of wild {
                   BitBoard.All
                   -> GHC.Base.++ @ GHC.Types.Char BitBoard.$fShowPieceType7 w1
                   BitBoard.Pawns
                   -> GHC.Base.++ @ GHC.Types.Char BitBoard.$fShowPieceType6 w1
                   BitBoard.Rooks
                   -> GHC.Base.++ @ GHC.Types.Char BitBoard.$fShowPieceType5 w1
                   BitBoard.Knights
                   -> GHC.Base.++ @ GHC.Types.Char BitBoard.$fShowPieceType4 w1
                   BitBoard.Bishops
                   -> GHC.Base.++ @ GHC.Types.Char BitBoard.$fShowPieceType3 w1
                   BitBoard.Queens
                   -> GHC.Base.++ @ GHC.Types.Char BitBoard.$fShowPieceType2 w1
                   BitBoard.Kings
                   -> GHC.Base.++ @ GHC.Types.Char BitBoard.$fShowPieceType1 w1 }) -}
34da54d75a2bd913b922a16a181dfcb6
  $w$ctoEnum :: GHC.Prim.Int# -> BitBoard.PieceType
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> BitBoard.$fEnumPieceType8 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 6) of wild1 {
                        GHC.Types.False -> BitBoard.$fEnumPieceType8 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ BitBoard.PieceType ww } }) -}
bb384fbe9c5a6093f0a3369de64110c6
  $wbitBoardToDoc ::
    GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> [Text.PrettyPrint.ANSI.Leijen.Doc]
  {- Arity: 12,
     Strictness: <L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Word#
                   ww1 :: GHC.Prim.Word#
                   ww2 :: GHC.Prim.Word#
                   ww3 :: GHC.Prim.Word#
                   ww4 :: GHC.Prim.Word#
                   ww5 :: GHC.Prim.Word#
                   ww6 :: GHC.Prim.Word#
                   ww7 :: GHC.Prim.Word#
                   ww8 :: GHC.Prim.Word#
                   ww9 :: GHC.Prim.Word#
                   ww10 :: GHC.Prim.Word#
                   ww11 :: GHC.Prim.Word# ->
                 GHC.Base.map
                   @ [GHC.Types.Char]
                   @ Text.PrettyPrint.ANSI.Leijen.Doc
                   BitBoard.$fShowBitBoard20
                   (BitBoard.$fShowBitBoard_splitEvery8
                      BitBoard.$fShowBitBoard19
                      (GHC.List.reverse1
                         @ GHC.Types.Char
                         (Data.IntMap.Base.elems
                            @ GHC.Types.Char
                            (Data.IntMap.Base.unions1
                               @ GHC.Types.Char
                               (Data.IntMap.Base.Nil @ GHC.Types.Char)
                               (GHC.Types.:
                                  @ (Data.IntMap.Base.IntMap GHC.Types.Char)
                                  (BitBoard.$wlvl (GHC.Word.W64# ww) BitBoard.$fShowBitBoard18)
                                  (GHC.Types.:
                                     @ (Data.IntMap.Base.IntMap GHC.Types.Char)
                                     (BitBoard.$wlvl (GHC.Word.W64# ww1) BitBoard.$fShowBitBoard17)
                                     (GHC.Types.:
                                        @ (Data.IntMap.Base.IntMap GHC.Types.Char)
                                        (BitBoard.$wlvl
                                           (GHC.Word.W64# ww2)
                                           BitBoard.$fShowBitBoard16)
                                        (GHC.Types.:
                                           @ (Data.IntMap.Base.IntMap GHC.Types.Char)
                                           (BitBoard.$wlvl
                                              (GHC.Word.W64# ww3)
                                              BitBoard.$fShowBitBoard15)
                                           (GHC.Types.:
                                              @ (Data.IntMap.Base.IntMap GHC.Types.Char)
                                              (BitBoard.$wlvl
                                                 (GHC.Word.W64# ww4)
                                                 BitBoard.$fShowBitBoard14)
                                              (GHC.Types.:
                                                 @ (Data.IntMap.Base.IntMap GHC.Types.Char)
                                                 (BitBoard.$wlvl
                                                    (GHC.Word.W64# ww5)
                                                    BitBoard.$fShowBitBoard13)
                                                 (GHC.Types.:
                                                    @ (Data.IntMap.Base.IntMap GHC.Types.Char)
                                                    (BitBoard.$wlvl
                                                       (GHC.Word.W64# ww6)
                                                       BitBoard.$fShowBitBoard12)
                                                    (GHC.Types.:
                                                       @ (Data.IntMap.Base.IntMap GHC.Types.Char)
                                                       (BitBoard.$wlvl
                                                          (GHC.Word.W64# ww7)
                                                          BitBoard.$fShowBitBoard11)
                                                       (GHC.Types.:
                                                          @ (Data.IntMap.Base.IntMap GHC.Types.Char)
                                                          (BitBoard.$wlvl
                                                             (GHC.Word.W64# ww8)
                                                             BitBoard.$fShowBitBoard10)
                                                          (GHC.Types.:
                                                             @ (Data.IntMap.Base.IntMap
                                                                  GHC.Types.Char)
                                                             (BitBoard.$wlvl
                                                                (GHC.Word.W64# ww9)
                                                                BitBoard.$fShowBitBoard9)
                                                             (GHC.Types.:
                                                                @ (Data.IntMap.Base.IntMap
                                                                     GHC.Types.Char)
                                                                (BitBoard.$wlvl
                                                                   (GHC.Word.W64# ww10)
                                                                   BitBoard.$fShowBitBoard8)
                                                                (GHC.Types.:
                                                                   @ (Data.IntMap.Base.IntMap
                                                                        GHC.Types.Char)
                                                                   (BitBoard.$wlvl
                                                                      (GHC.Word.W64# ww11)
                                                                      BitBoard.$fShowBitBoard7)
                                                                   BitBoard.$fShowBitBoard2))))))))))))))
                         (GHC.Types.[] @ GHC.Types.Char)))) -}
fdd76e90dc5c324871434df9e54adfce
  $wlvl ::
    GHC.Word.Word64
    -> GHC.Types.Char -> Data.IntMap.Base.IntMap GHC.Types.Char
  {- Arity: 2, Strictness: <L,U(U)><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Word.Word64 ww1 :: GHC.Types.Char ->
                 letrec {
                   go7 :: [GHC.Types.Int] -> [(Data.IntSet.Base.Key, GHC.Types.Char)]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ ds :: [GHC.Types.Int] ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ (Data.IntSet.Base.Key, GHC.Types.Char)
                       : y ys
                       -> case ww of wild1 { GHC.Word.W64# x# ->
                          case y of wild2 { GHC.Types.I# i# ->
                          case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.>=# i# 64) of wild3 {
                            GHC.Types.False
                            -> case GHC.Prim.and#
                                      x#
                                      (GHC.Prim.uncheckedShiftL# __word 1 i#) of wild4 {
                                 DEFAULT
                                 -> GHC.Types.:
                                      @ (Data.IntSet.Base.Key, GHC.Types.Char)
                                      (wild2, ww1)
                                      (go7 ys)
                                 __word 0 -> go7 ys }
                            GHC.Types.True -> go7 ys } } } }
                 } in
                 case go7 BitBoard.$fShowBitBoard6 of wild {
                   [] -> Data.IntMap.Base.Nil @ GHC.Types.Char
                   : z0 zs0
                   -> case z0 of ww2 { (,) ww3 ww4 ->
                      case ww3 of ww5 { GHC.Types.I# ww6 ->
                      Data.IntMap.Strict.$wwork
                        @ GHC.Types.Char
                        ww6
                        ww4
                        zs0
                        (Data.IntMap.Strict.Nada @ GHC.Types.Char) } } }) -}
bd3c928fdda9b2653a392ef5b2ba3f68
  type role AllColors phantom
  data AllColors (p :: BitBoard.PieceType)
    = AllColors {black :: {-# UNPACK #-}GHC.Word.Word64,
                 white :: {-# UNPACK #-}GHC.Word.Word64,
                 both :: {-# UNPACK #-}GHC.Word.Word64}
76ff291bd5559725ac43a513632ccddc
  data BitBoard
    = BitBoard {pieces :: {-# UNPACK #-}BitBoard.AllColors
                                          'BitBoard.All,
                pawns :: {-# UNPACK #-}BitBoard.AllColors 'BitBoard.Pawns,
                rooks :: {-# UNPACK #-}BitBoard.AllColors 'BitBoard.Rooks,
                knights :: {-# UNPACK #-}BitBoard.AllColors 'BitBoard.Knights,
                bishops :: {-# UNPACK #-}BitBoard.AllColors 'BitBoard.Bishops,
                queens :: {-# UNPACK #-}BitBoard.AllColors 'BitBoard.Queens,
                kings :: {-# UNPACK #-}BitBoard.AllColors 'BitBoard.Kings}
34da54d75a2bd913b922a16a181dfcb6
  data PieceType
    = All | Pawns | Rooks | Knights | Bishops | Queens | Kings
    Promotable
ea78c6f9210fc6a7e5aebcdabcbed179
  bishops ::
    BitBoard.BitBoard -> BitBoard.AllColors 'BitBoard.Bishops
  RecSel BitBoard.BitBoard
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S,1*U(A,A,A,A,A,A,A,A,A,A,A,A,U,U,U,A,A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: BitBoard.BitBoard ->
                 case ds of wild { BitBoard.BitBoard dt dt1 dt2 dt3 dt4 dt5 dt6 dt7 dt8 dt9 dt10 dt11 dt12 dt13 dt14 dt15 dt16 dt17 dt18 dt19 dt20 ->
                 BitBoard.AllColors @ 'BitBoard.Bishops dt12 dt13 dt14 }) -}
ccda040b046814faa20de51e68847045
  bitBoardToDoc ::
    BitBoard.BitBoard -> [Text.PrettyPrint.ANSI.Leijen.Doc]
  {- Arity: 1,
     Strictness: <S,1*U(A,A,A,U,U,A,U,U,A,U,U,A,U,U,A,U,U,A,U,U,A)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: BitBoard.BitBoard ->
                 case w of ww { BitBoard.BitBoard ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ww11 ww12 ww13 ww14 ww15 ww16 ww17 ww18 ww19 ww20 ww21 ->
                 BitBoard.$wbitBoardToDoc
                   ww4
                   ww5
                   ww7
                   ww8
                   ww10
                   ww11
                   ww13
                   ww14
                   ww16
                   ww17
                   ww19
                   ww20 }) -}
93de7e4417326fde8d7fd70b0bedd77d
  black :: BitBoard.AllColors p -> GHC.Word.Word64
  RecSel BitBoard.AllColors
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ (p :: BitBoard.PieceType) ds :: BitBoard.AllColors p ->
                 case ds of wild { BitBoard.AllColors dt dt1 dt2 ->
                 GHC.Word.W64# dt }) -}
cbb0ff5a1a592aa59d4e63255ed0e7c8
  both :: BitBoard.AllColors p -> GHC.Word.Word64
  RecSel BitBoard.AllColors
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(A,A,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ (p :: BitBoard.PieceType) ds :: BitBoard.AllColors p ->
                 case ds of wild { BitBoard.AllColors dt dt1 dt2 ->
                 GHC.Word.W64# dt2 }) -}
756949e79230c1ed89f749600eb7ac4d
  emptyBoard :: BitBoard.BitBoard
  {- HasNoCafRefs,
     Unfolding: (BitBoard.BitBoard
                   __word 0
                   __word 0
                   __word 0
                   __word 0
                   __word 0
                   __word 0
                   __word 0
                   __word 0
                   __word 0
                   __word 0
                   __word 0
                   __word 0
                   __word 0
                   __word 0
                   __word 0
                   __word 0
                   __word 0
                   __word 0
                   __word 0
                   __word 0
                   __word 0) -}
8a7ed4ec82aa29aa264f0efbb0962cfd
  kings :: BitBoard.BitBoard -> BitBoard.AllColors 'BitBoard.Kings
  RecSel BitBoard.BitBoard
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S,1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: BitBoard.BitBoard ->
                 case ds of wild { BitBoard.BitBoard dt dt1 dt2 dt3 dt4 dt5 dt6 dt7 dt8 dt9 dt10 dt11 dt12 dt13 dt14 dt15 dt16 dt17 dt18 dt19 dt20 ->
                 BitBoard.AllColors @ 'BitBoard.Kings dt18 dt19 dt20 }) -}
a901742146a0cff61e376554bb5f24e4
  knights ::
    BitBoard.BitBoard -> BitBoard.AllColors 'BitBoard.Knights
  RecSel BitBoard.BitBoard
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S,1*U(A,A,A,A,A,A,A,A,A,U,U,U,A,A,A,A,A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: BitBoard.BitBoard ->
                 case ds of wild { BitBoard.BitBoard dt dt1 dt2 dt3 dt4 dt5 dt6 dt7 dt8 dt9 dt10 dt11 dt12 dt13 dt14 dt15 dt16 dt17 dt18 dt19 dt20 ->
                 BitBoard.AllColors @ 'BitBoard.Knights dt9 dt10 dt11 }) -}
13c4d1d9fa797f50df902028e361be89
  pawns :: BitBoard.BitBoard -> BitBoard.AllColors 'BitBoard.Pawns
  RecSel BitBoard.BitBoard
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S,1*U(A,A,A,U,U,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: BitBoard.BitBoard ->
                 case ds of wild { BitBoard.BitBoard dt dt1 dt2 dt3 dt4 dt5 dt6 dt7 dt8 dt9 dt10 dt11 dt12 dt13 dt14 dt15 dt16 dt17 dt18 dt19 dt20 ->
                 BitBoard.AllColors @ 'BitBoard.Pawns dt3 dt4 dt5 }) -}
ef6ca73b277942dc7d1bbb55050b2dcf
  pieces :: BitBoard.BitBoard -> BitBoard.AllColors 'BitBoard.All
  RecSel BitBoard.BitBoard
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S,1*U(U,U,U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: BitBoard.BitBoard ->
                 case ds of wild { BitBoard.BitBoard dt dt1 dt2 dt3 dt4 dt5 dt6 dt7 dt8 dt9 dt10 dt11 dt12 dt13 dt14 dt15 dt16 dt17 dt18 dt19 dt20 ->
                 BitBoard.AllColors @ 'BitBoard.All dt dt1 dt2 }) -}
540e8234875ba8d3af2e5548e3a2179f
  queens :: BitBoard.BitBoard -> BitBoard.AllColors 'BitBoard.Queens
  RecSel BitBoard.BitBoard
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S,1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,U,U,U,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: BitBoard.BitBoard ->
                 case ds of wild { BitBoard.BitBoard dt dt1 dt2 dt3 dt4 dt5 dt6 dt7 dt8 dt9 dt10 dt11 dt12 dt13 dt14 dt15 dt16 dt17 dt18 dt19 dt20 ->
                 BitBoard.AllColors @ 'BitBoard.Queens dt15 dt16 dt17 }) -}
69ad7972fc91adbe8a099867350d3a3f
  rooks :: BitBoard.BitBoard -> BitBoard.AllColors 'BitBoard.Rooks
  RecSel BitBoard.BitBoard
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S,1*U(A,A,A,A,A,A,U,U,U,A,A,A,A,A,A,A,A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: BitBoard.BitBoard ->
                 case ds of wild { BitBoard.BitBoard dt dt1 dt2 dt3 dt4 dt5 dt6 dt7 dt8 dt9 dt10 dt11 dt12 dt13 dt14 dt15 dt16 dt17 dt18 dt19 dt20 ->
                 BitBoard.AllColors @ 'BitBoard.Rooks dt6 dt7 dt8 }) -}
96ed533a682ea2fe7c49e56ce66c33f3
  white :: BitBoard.AllColors p -> GHC.Word.Word64
  RecSel BitBoard.AllColors
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(A,U,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ (p :: BitBoard.PieceType) ds :: BitBoard.AllColors p ->
                 case ds of wild { BitBoard.AllColors dt dt1 dt2 ->
                 GHC.Word.W64# dt1 }) -}
instance GHC.Enum.Enum [BitBoard.PieceType]
  = BitBoard.$fEnumPieceType
instance GHC.Classes.Eq [BitBoard.PieceType]
  = BitBoard.$fEqPieceType
instance GHC.Classes.Ord [BitBoard.PieceType]
  = BitBoard.$fOrdPieceType
instance GHC.Show.Show [BitBoard.BitBoard]
  = BitBoard.$fShowBitBoard
instance GHC.Show.Show [BitBoard.PieceType]
  = BitBoard.$fShowPieceType
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

