
==================== FINAL INTERFACE ====================
2015-12-22 19:40:21.469988 UTC

interface hches_KF6MDI5eODG4Q8cKhuw0mn:BitBoard 7102
  interface hash: f962f732a25456b9176c43aaccadf5b5
  ABI hash: 7e4576e6f7d0be2ca1ef0ad8232e27f7
  export-list hash: bdccb0548ea28b40cb7b32788872b4c3
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 60b0c5c5667f32509f7228bb0f134659
  sig of: Nothing
  used TH splices: False
  where
exports:
  BitBoard.emptyBoard
  BitBoard.Bishops{BitBoard.B BitBoard.unB}
  BitBoard.BitBoard{BitBoard.BitBoard}
  BitBoard.BlackPieces{BitBoard.BC BitBoard.unBC}
  BitBoard.Kings{BitBoard.K BitBoard.unK}
  BitBoard.Knights{BitBoard.N BitBoard.unN}
  BitBoard.Pawns{BitBoard.P BitBoard.unP}
  BitBoard.Queens{BitBoard.Q BitBoard.unQ}
  BitBoard.Rooks{BitBoard.R BitBoard.unR}
  BitBoard.WhitePieces{BitBoard.WC BitBoard.unWC}
module dependencies:
package dependencies: array-0.5.1.0@array_E0sTtauuKsGDLZoT7lTbgZ
                      base-4.8.1.0 containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN
                      deepseq-1.4.1.1@deeps_LbCWUlehDDeLxurARKDH5o ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
orphans: base-4.8.1.0:GHC.Base base-4.8.1.0:GHC.Float
family instance modules: base-4.8.1.0:Control.Applicative
                         base-4.8.1.0:Data.Either base-4.8.1.0:Data.Functor.Identity
                         base-4.8.1.0:Data.Monoid base-4.8.1.0:Data.Type.Equality
                         base-4.8.1.0:Data.Void base-4.8.1.0:GHC.Exts
                         base-4.8.1.0:GHC.Generics
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntMap.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntSet.Base
import  -/  base-4.8.1.0:Data.Bits 5341167fdd5958c2b3f0dac8924f1efd
import  -/  base-4.8.1.0:Data.Word 448c480b98a0c18988a37db5ab829b22
import  -/  base-4.8.1.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.1.0:GHC.Enum d0db4d619cd8916cc7a23444816222af
import  -/  base-4.8.1.0:GHC.List f31ed8784b3e05f1397195751f7d74ea
import  -/  base-4.8.1.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.1.0:GHC.Show b8c65ca3124f92a166c9f05120382442
import  -/  base-4.8.1.0:GHC.Word ef6286c279d61931eb675109b4b93579
import  -/  base-4.8.1.0:Prelude 518f762991bc287d78f21a73c974da1f
import  -/  containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntMap.Base 41288a612f7bbd399bc0bb07f2f75738
import  -/  containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntMap.Strict 75157829e2fd1bf3aaf8a4fd3bd7d8f4
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  ghc-prim-0.4.0.0:GHC.Types 6b27fb3fdbd0e3f0925a4496c66513bb
import  -/  integer-gmp-1.0.0.0:GHC.Integer.Type bf9b4d13b1dbe96a83786d2e47d2e8ca
2d4ec6b056380f1ff25960b1f4e0a6be
  $fBitsBishops :: Data.Bits.Bits BitBoard.Bishops
  DFunId[0]
  {- HasNoCafRefs, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Bishops
                  BitBoard.$fEqBishops
                  BitBoard.$fBitsBishops_$c.&.
                  BitBoard.$fBitsBishops_$c.|.
                  BitBoard.$fBitsBishops_$cxor
                  BitBoard.$fBitsBishops_$ccomplement
                  BitBoard.$fBitsBishops_$cshift
                  BitBoard.$fBitsBishops_$crotate
                  BitBoard.$fBitsBishops_$czeroBits
                  BitBoard.$fBitsBishops_$cbit
                  BitBoard.$fBitsBishops_$csetBit
                  BitBoard.$fBitsBishops_$cclearBit
                  BitBoard.$fBitsBishops_$ccomplementBit
                  BitBoard.$fBitsBishops_$ctestBit
                  BitBoard.$fBitsBishops_$cbitSizeMaybe
                  BitBoard.$fBitsBishops_$cfiniteBitSize
                  BitBoard.$fBitsBishops_$cisSigned
                  BitBoard.$fBitsBishops_$cshiftL
                  BitBoard.$fBitsBishops_$cunsafeShiftL
                  BitBoard.$fBitsBishops_$cshiftR
                  BitBoard.$fBitsBishops_$cunsafeShiftR
                  BitBoard.$fBitsBishops_$crotateL
                  BitBoard.$fBitsBishops_$crotateR
                  BitBoard.$fBitsBishops_$cpopCount -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fBitsBishops_$c.&. ::
    BitBoard.Bishops -> BitBoard.Bishops -> BitBoard.Bishops
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$c.&.3
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0])
                 ->_R Sym (BitBoard.NTCo:Bishops[0])
                 ->_R Sym (BitBoard.NTCo:Bishops[0])) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fBitsBishops_$c.|. ::
    BitBoard.Bishops -> BitBoard.Bishops -> BitBoard.Bishops
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$c.|.3
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0])
                 ->_R Sym (BitBoard.NTCo:Bishops[0])
                 ->_R Sym (BitBoard.NTCo:Bishops[0])) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fBitsBishops_$cbit :: GHC.Types.Int -> BitBoard.Bishops
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cbit
                  `cast`
                (<GHC.Types.Int>_R ->_R Sym (BitBoard.NTCo:Bishops[0])) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fBitsBishops_$cbitSizeMaybe ::
    BitBoard.Bishops -> GHC.Base.Maybe GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>m2,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cbitSizeMaybe
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0])
                 ->_R <GHC.Base.Maybe GHC.Types.Int>_R) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fBitsBishops_$cclearBit ::
    BitBoard.Bishops -> GHC.Types.Int -> BitBoard.Bishops
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cclearBit
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Bishops[0])) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fBitsBishops_$ccomplement :: BitBoard.Bishops -> BitBoard.Bishops
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$ccomplement3
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0])
                 ->_R Sym (BitBoard.NTCo:Bishops[0])) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fBitsBishops_$ccomplementBit ::
    BitBoard.Bishops -> GHC.Types.Int -> BitBoard.Bishops
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$ccomplementBit
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Bishops[0])) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fBitsBishops_$cfiniteBitSize :: BitBoard.Bishops -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cfiniteBitSize
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0]) ->_R <GHC.Types.Int>_R) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fBitsBishops_$cisSigned :: BitBoard.Bishops -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cisSigned
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0]) ->_R <GHC.Types.Bool>_R) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fBitsBishops_$cpopCount :: BitBoard.Bishops -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cpopCount
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0]) ->_R <GHC.Types.Int>_R) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fBitsBishops_$crotate ::
    BitBoard.Bishops -> GHC.Types.Int -> BitBoard.Bishops
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$crotate3
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Bishops[0])) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fBitsBishops_$crotateL ::
    BitBoard.Bishops -> GHC.Types.Int -> BitBoard.Bishops
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$crotateL
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Bishops[0])) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fBitsBishops_$crotateR ::
    BitBoard.Bishops -> GHC.Types.Int -> BitBoard.Bishops
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$crotateR
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Bishops[0])) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fBitsBishops_$csetBit ::
    BitBoard.Bishops -> GHC.Types.Int -> BitBoard.Bishops
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$csetBit
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Bishops[0])) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fBitsBishops_$cshift ::
    BitBoard.Bishops -> GHC.Types.Int -> BitBoard.Bishops
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cshift
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Bishops[0])) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fBitsBishops_$cshiftL ::
    BitBoard.Bishops -> GHC.Types.Int -> BitBoard.Bishops
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$cshiftL3
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Bishops[0])) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fBitsBishops_$cshiftR ::
    BitBoard.Bishops -> GHC.Types.Int -> BitBoard.Bishops
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cshiftR
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Bishops[0])) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fBitsBishops_$ctestBit ::
    BitBoard.Bishops -> GHC.Types.Int -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$ctestBit
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0])
                 ->_R <GHC.Types.Int -> GHC.Types.Bool>_R) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fBitsBishops_$cunsafeShiftL ::
    BitBoard.Bishops -> GHC.Types.Int -> BitBoard.Bishops
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cunsafeShiftL
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Bishops[0])) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fBitsBishops_$cunsafeShiftR ::
    BitBoard.Bishops -> GHC.Types.Int -> BitBoard.Bishops
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cunsafeShiftR
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Bishops[0])) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fBitsBishops_$cxor ::
    BitBoard.Bishops -> BitBoard.Bishops -> BitBoard.Bishops
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$cxor3
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0])
                 ->_R Sym (BitBoard.NTCo:Bishops[0])
                 ->_R Sym (BitBoard.NTCo:Bishops[0])) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fBitsBishops_$czeroBits :: BitBoard.Bishops
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord6 `cast` (Sym (BitBoard.NTCo:Bishops[0])) -}
9ddff55270133108c79e28dd74ad22ce
  $fBitsBlackPieces :: Data.Bits.Bits BitBoard.BlackPieces
  DFunId[0]
  {- HasNoCafRefs, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.BlackPieces
                  BitBoard.$fEqBlackPieces
                  BitBoard.$fBitsBlackPieces_$c.&.
                  BitBoard.$fBitsBlackPieces_$c.|.
                  BitBoard.$fBitsBlackPieces_$cxor
                  BitBoard.$fBitsBlackPieces_$ccomplement
                  BitBoard.$fBitsBlackPieces_$cshift
                  BitBoard.$fBitsBlackPieces_$crotate
                  BitBoard.$fBitsBlackPieces_$czeroBits
                  BitBoard.$fBitsBlackPieces_$cbit
                  BitBoard.$fBitsBlackPieces_$csetBit
                  BitBoard.$fBitsBlackPieces_$cclearBit
                  BitBoard.$fBitsBlackPieces_$ccomplementBit
                  BitBoard.$fBitsBlackPieces_$ctestBit
                  BitBoard.$fBitsBlackPieces_$cbitSizeMaybe
                  BitBoard.$fBitsBlackPieces_$cfiniteBitSize
                  BitBoard.$fBitsBlackPieces_$cisSigned
                  BitBoard.$fBitsBlackPieces_$cshiftL
                  BitBoard.$fBitsBlackPieces_$cunsafeShiftL
                  BitBoard.$fBitsBlackPieces_$cshiftR
                  BitBoard.$fBitsBlackPieces_$cunsafeShiftR
                  BitBoard.$fBitsBlackPieces_$crotateL
                  BitBoard.$fBitsBlackPieces_$crotateR
                  BitBoard.$fBitsBlackPieces_$cpopCount -}
9ddff55270133108c79e28dd74ad22ce
  $fBitsBlackPieces_$c.&. ::
    BitBoard.BlackPieces
    -> BitBoard.BlackPieces -> BitBoard.BlackPieces
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$c.&.3
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])) -}
9ddff55270133108c79e28dd74ad22ce
  $fBitsBlackPieces_$c.|. ::
    BitBoard.BlackPieces
    -> BitBoard.BlackPieces -> BitBoard.BlackPieces
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$c.|.3
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])) -}
9ddff55270133108c79e28dd74ad22ce
  $fBitsBlackPieces_$cbit :: GHC.Types.Int -> BitBoard.BlackPieces
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cbit
                  `cast`
                (<GHC.Types.Int>_R ->_R Sym (BitBoard.NTCo:BlackPieces[0])) -}
9ddff55270133108c79e28dd74ad22ce
  $fBitsBlackPieces_$cbitSizeMaybe ::
    BitBoard.BlackPieces -> GHC.Base.Maybe GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>m2,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cbitSizeMaybe
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R <GHC.Base.Maybe GHC.Types.Int>_R) -}
9ddff55270133108c79e28dd74ad22ce
  $fBitsBlackPieces_$cclearBit ::
    BitBoard.BlackPieces -> GHC.Types.Int -> BitBoard.BlackPieces
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cclearBit
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])) -}
9ddff55270133108c79e28dd74ad22ce
  $fBitsBlackPieces_$ccomplement ::
    BitBoard.BlackPieces -> BitBoard.BlackPieces
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$ccomplement3
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])) -}
9ddff55270133108c79e28dd74ad22ce
  $fBitsBlackPieces_$ccomplementBit ::
    BitBoard.BlackPieces -> GHC.Types.Int -> BitBoard.BlackPieces
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$ccomplementBit
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])) -}
9ddff55270133108c79e28dd74ad22ce
  $fBitsBlackPieces_$cfiniteBitSize ::
    BitBoard.BlackPieces -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cfiniteBitSize
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0]) ->_R <GHC.Types.Int>_R) -}
9ddff55270133108c79e28dd74ad22ce
  $fBitsBlackPieces_$cisSigned ::
    BitBoard.BlackPieces -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cisSigned
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0]) ->_R <GHC.Types.Bool>_R) -}
9ddff55270133108c79e28dd74ad22ce
  $fBitsBlackPieces_$cpopCount ::
    BitBoard.BlackPieces -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cpopCount
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0]) ->_R <GHC.Types.Int>_R) -}
9ddff55270133108c79e28dd74ad22ce
  $fBitsBlackPieces_$crotate ::
    BitBoard.BlackPieces -> GHC.Types.Int -> BitBoard.BlackPieces
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$crotate3
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])) -}
9ddff55270133108c79e28dd74ad22ce
  $fBitsBlackPieces_$crotateL ::
    BitBoard.BlackPieces -> GHC.Types.Int -> BitBoard.BlackPieces
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$crotateL
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])) -}
9ddff55270133108c79e28dd74ad22ce
  $fBitsBlackPieces_$crotateR ::
    BitBoard.BlackPieces -> GHC.Types.Int -> BitBoard.BlackPieces
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$crotateR
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])) -}
9ddff55270133108c79e28dd74ad22ce
  $fBitsBlackPieces_$csetBit ::
    BitBoard.BlackPieces -> GHC.Types.Int -> BitBoard.BlackPieces
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$csetBit
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])) -}
9ddff55270133108c79e28dd74ad22ce
  $fBitsBlackPieces_$cshift ::
    BitBoard.BlackPieces -> GHC.Types.Int -> BitBoard.BlackPieces
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cshift
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])) -}
9ddff55270133108c79e28dd74ad22ce
  $fBitsBlackPieces_$cshiftL ::
    BitBoard.BlackPieces -> GHC.Types.Int -> BitBoard.BlackPieces
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$cshiftL3
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])) -}
9ddff55270133108c79e28dd74ad22ce
  $fBitsBlackPieces_$cshiftR ::
    BitBoard.BlackPieces -> GHC.Types.Int -> BitBoard.BlackPieces
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cshiftR
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])) -}
9ddff55270133108c79e28dd74ad22ce
  $fBitsBlackPieces_$ctestBit ::
    BitBoard.BlackPieces -> GHC.Types.Int -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$ctestBit
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R <GHC.Types.Int -> GHC.Types.Bool>_R) -}
9ddff55270133108c79e28dd74ad22ce
  $fBitsBlackPieces_$cunsafeShiftL ::
    BitBoard.BlackPieces -> GHC.Types.Int -> BitBoard.BlackPieces
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cunsafeShiftL
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])) -}
9ddff55270133108c79e28dd74ad22ce
  $fBitsBlackPieces_$cunsafeShiftR ::
    BitBoard.BlackPieces -> GHC.Types.Int -> BitBoard.BlackPieces
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cunsafeShiftR
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])) -}
9ddff55270133108c79e28dd74ad22ce
  $fBitsBlackPieces_$cxor ::
    BitBoard.BlackPieces
    -> BitBoard.BlackPieces -> BitBoard.BlackPieces
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$cxor3
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])) -}
9ddff55270133108c79e28dd74ad22ce
  $fBitsBlackPieces_$czeroBits :: BitBoard.BlackPieces
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord6 `cast` (Sym (BitBoard.NTCo:BlackPieces[0])) -}
065b32ad76ea4a8b0402f332e197f31d
  $fBitsKings :: Data.Bits.Bits BitBoard.Kings
  DFunId[0]
  {- HasNoCafRefs, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Kings
                  BitBoard.$fEqKings
                  BitBoard.$fBitsKings_$c.&.
                  BitBoard.$fBitsKings_$c.|.
                  BitBoard.$fBitsKings_$cxor
                  BitBoard.$fBitsKings_$ccomplement
                  BitBoard.$fBitsKings_$cshift
                  BitBoard.$fBitsKings_$crotate
                  BitBoard.$fBitsKings_$czeroBits
                  BitBoard.$fBitsKings_$cbit
                  BitBoard.$fBitsKings_$csetBit
                  BitBoard.$fBitsKings_$cclearBit
                  BitBoard.$fBitsKings_$ccomplementBit
                  BitBoard.$fBitsKings_$ctestBit
                  BitBoard.$fBitsKings_$cbitSizeMaybe
                  BitBoard.$fBitsKings_$cfiniteBitSize
                  BitBoard.$fBitsKings_$cisSigned
                  BitBoard.$fBitsKings_$cshiftL
                  BitBoard.$fBitsKings_$cunsafeShiftL
                  BitBoard.$fBitsKings_$cshiftR
                  BitBoard.$fBitsKings_$cunsafeShiftR
                  BitBoard.$fBitsKings_$crotateL
                  BitBoard.$fBitsKings_$crotateR
                  BitBoard.$fBitsKings_$cpopCount -}
065b32ad76ea4a8b0402f332e197f31d
  $fBitsKings_$c.&. ::
    BitBoard.Kings -> BitBoard.Kings -> BitBoard.Kings
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$c.&.3
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0])
                 ->_R Sym (BitBoard.NTCo:Kings[0])
                 ->_R Sym (BitBoard.NTCo:Kings[0])) -}
065b32ad76ea4a8b0402f332e197f31d
  $fBitsKings_$c.|. ::
    BitBoard.Kings -> BitBoard.Kings -> BitBoard.Kings
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$c.|.3
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0])
                 ->_R Sym (BitBoard.NTCo:Kings[0])
                 ->_R Sym (BitBoard.NTCo:Kings[0])) -}
065b32ad76ea4a8b0402f332e197f31d
  $fBitsKings_$cbit :: GHC.Types.Int -> BitBoard.Kings
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cbit
                  `cast`
                (<GHC.Types.Int>_R ->_R Sym (BitBoard.NTCo:Kings[0])) -}
065b32ad76ea4a8b0402f332e197f31d
  $fBitsKings_$cbitSizeMaybe ::
    BitBoard.Kings -> GHC.Base.Maybe GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>m2,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cbitSizeMaybe
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0])
                 ->_R <GHC.Base.Maybe GHC.Types.Int>_R) -}
065b32ad76ea4a8b0402f332e197f31d
  $fBitsKings_$cclearBit ::
    BitBoard.Kings -> GHC.Types.Int -> BitBoard.Kings
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cclearBit
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Kings[0])) -}
065b32ad76ea4a8b0402f332e197f31d
  $fBitsKings_$ccomplement :: BitBoard.Kings -> BitBoard.Kings
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$ccomplement3
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0]) ->_R Sym (BitBoard.NTCo:Kings[0])) -}
065b32ad76ea4a8b0402f332e197f31d
  $fBitsKings_$ccomplementBit ::
    BitBoard.Kings -> GHC.Types.Int -> BitBoard.Kings
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$ccomplementBit
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Kings[0])) -}
065b32ad76ea4a8b0402f332e197f31d
  $fBitsKings_$cfiniteBitSize :: BitBoard.Kings -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cfiniteBitSize
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0]) ->_R <GHC.Types.Int>_R) -}
065b32ad76ea4a8b0402f332e197f31d
  $fBitsKings_$cisSigned :: BitBoard.Kings -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cisSigned
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0]) ->_R <GHC.Types.Bool>_R) -}
065b32ad76ea4a8b0402f332e197f31d
  $fBitsKings_$cpopCount :: BitBoard.Kings -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cpopCount
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0]) ->_R <GHC.Types.Int>_R) -}
065b32ad76ea4a8b0402f332e197f31d
  $fBitsKings_$crotate ::
    BitBoard.Kings -> GHC.Types.Int -> BitBoard.Kings
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$crotate3
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Kings[0])) -}
065b32ad76ea4a8b0402f332e197f31d
  $fBitsKings_$crotateL ::
    BitBoard.Kings -> GHC.Types.Int -> BitBoard.Kings
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$crotateL
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Kings[0])) -}
065b32ad76ea4a8b0402f332e197f31d
  $fBitsKings_$crotateR ::
    BitBoard.Kings -> GHC.Types.Int -> BitBoard.Kings
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$crotateR
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Kings[0])) -}
065b32ad76ea4a8b0402f332e197f31d
  $fBitsKings_$csetBit ::
    BitBoard.Kings -> GHC.Types.Int -> BitBoard.Kings
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$csetBit
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Kings[0])) -}
065b32ad76ea4a8b0402f332e197f31d
  $fBitsKings_$cshift ::
    BitBoard.Kings -> GHC.Types.Int -> BitBoard.Kings
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cshift
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Kings[0])) -}
065b32ad76ea4a8b0402f332e197f31d
  $fBitsKings_$cshiftL ::
    BitBoard.Kings -> GHC.Types.Int -> BitBoard.Kings
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$cshiftL3
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Kings[0])) -}
065b32ad76ea4a8b0402f332e197f31d
  $fBitsKings_$cshiftR ::
    BitBoard.Kings -> GHC.Types.Int -> BitBoard.Kings
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cshiftR
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Kings[0])) -}
065b32ad76ea4a8b0402f332e197f31d
  $fBitsKings_$ctestBit ::
    BitBoard.Kings -> GHC.Types.Int -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$ctestBit
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0])
                 ->_R <GHC.Types.Int -> GHC.Types.Bool>_R) -}
065b32ad76ea4a8b0402f332e197f31d
  $fBitsKings_$cunsafeShiftL ::
    BitBoard.Kings -> GHC.Types.Int -> BitBoard.Kings
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cunsafeShiftL
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Kings[0])) -}
065b32ad76ea4a8b0402f332e197f31d
  $fBitsKings_$cunsafeShiftR ::
    BitBoard.Kings -> GHC.Types.Int -> BitBoard.Kings
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cunsafeShiftR
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Kings[0])) -}
065b32ad76ea4a8b0402f332e197f31d
  $fBitsKings_$cxor ::
    BitBoard.Kings -> BitBoard.Kings -> BitBoard.Kings
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$cxor3
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0])
                 ->_R Sym (BitBoard.NTCo:Kings[0])
                 ->_R Sym (BitBoard.NTCo:Kings[0])) -}
065b32ad76ea4a8b0402f332e197f31d
  $fBitsKings_$czeroBits :: BitBoard.Kings
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord6 `cast` (Sym (BitBoard.NTCo:Kings[0])) -}
103282c86fd0df5e492207716e3fb109
  $fBitsKnights :: Data.Bits.Bits BitBoard.Knights
  DFunId[0]
  {- HasNoCafRefs, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Knights
                  BitBoard.$fEqKnights
                  BitBoard.$fBitsKnights_$c.&.
                  BitBoard.$fBitsKnights_$c.|.
                  BitBoard.$fBitsKnights_$cxor
                  BitBoard.$fBitsKnights_$ccomplement
                  BitBoard.$fBitsKnights_$cshift
                  BitBoard.$fBitsKnights_$crotate
                  BitBoard.$fBitsKnights_$czeroBits
                  BitBoard.$fBitsKnights_$cbit
                  BitBoard.$fBitsKnights_$csetBit
                  BitBoard.$fBitsKnights_$cclearBit
                  BitBoard.$fBitsKnights_$ccomplementBit
                  BitBoard.$fBitsKnights_$ctestBit
                  BitBoard.$fBitsKnights_$cbitSizeMaybe
                  BitBoard.$fBitsKnights_$cfiniteBitSize
                  BitBoard.$fBitsKnights_$cisSigned
                  BitBoard.$fBitsKnights_$cshiftL
                  BitBoard.$fBitsKnights_$cunsafeShiftL
                  BitBoard.$fBitsKnights_$cshiftR
                  BitBoard.$fBitsKnights_$cunsafeShiftR
                  BitBoard.$fBitsKnights_$crotateL
                  BitBoard.$fBitsKnights_$crotateR
                  BitBoard.$fBitsKnights_$cpopCount -}
103282c86fd0df5e492207716e3fb109
  $fBitsKnights_$c.&. ::
    BitBoard.Knights -> BitBoard.Knights -> BitBoard.Knights
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$c.&.3
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0])
                 ->_R Sym (BitBoard.NTCo:Knights[0])
                 ->_R Sym (BitBoard.NTCo:Knights[0])) -}
103282c86fd0df5e492207716e3fb109
  $fBitsKnights_$c.|. ::
    BitBoard.Knights -> BitBoard.Knights -> BitBoard.Knights
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$c.|.3
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0])
                 ->_R Sym (BitBoard.NTCo:Knights[0])
                 ->_R Sym (BitBoard.NTCo:Knights[0])) -}
103282c86fd0df5e492207716e3fb109
  $fBitsKnights_$cbit :: GHC.Types.Int -> BitBoard.Knights
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cbit
                  `cast`
                (<GHC.Types.Int>_R ->_R Sym (BitBoard.NTCo:Knights[0])) -}
103282c86fd0df5e492207716e3fb109
  $fBitsKnights_$cbitSizeMaybe ::
    BitBoard.Knights -> GHC.Base.Maybe GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>m2,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cbitSizeMaybe
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0])
                 ->_R <GHC.Base.Maybe GHC.Types.Int>_R) -}
103282c86fd0df5e492207716e3fb109
  $fBitsKnights_$cclearBit ::
    BitBoard.Knights -> GHC.Types.Int -> BitBoard.Knights
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cclearBit
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Knights[0])) -}
103282c86fd0df5e492207716e3fb109
  $fBitsKnights_$ccomplement :: BitBoard.Knights -> BitBoard.Knights
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$ccomplement3
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0])
                 ->_R Sym (BitBoard.NTCo:Knights[0])) -}
103282c86fd0df5e492207716e3fb109
  $fBitsKnights_$ccomplementBit ::
    BitBoard.Knights -> GHC.Types.Int -> BitBoard.Knights
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$ccomplementBit
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Knights[0])) -}
103282c86fd0df5e492207716e3fb109
  $fBitsKnights_$cfiniteBitSize :: BitBoard.Knights -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cfiniteBitSize
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0]) ->_R <GHC.Types.Int>_R) -}
103282c86fd0df5e492207716e3fb109
  $fBitsKnights_$cisSigned :: BitBoard.Knights -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cisSigned
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0]) ->_R <GHC.Types.Bool>_R) -}
103282c86fd0df5e492207716e3fb109
  $fBitsKnights_$cpopCount :: BitBoard.Knights -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cpopCount
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0]) ->_R <GHC.Types.Int>_R) -}
103282c86fd0df5e492207716e3fb109
  $fBitsKnights_$crotate ::
    BitBoard.Knights -> GHC.Types.Int -> BitBoard.Knights
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$crotate3
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Knights[0])) -}
103282c86fd0df5e492207716e3fb109
  $fBitsKnights_$crotateL ::
    BitBoard.Knights -> GHC.Types.Int -> BitBoard.Knights
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$crotateL
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Knights[0])) -}
103282c86fd0df5e492207716e3fb109
  $fBitsKnights_$crotateR ::
    BitBoard.Knights -> GHC.Types.Int -> BitBoard.Knights
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$crotateR
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Knights[0])) -}
103282c86fd0df5e492207716e3fb109
  $fBitsKnights_$csetBit ::
    BitBoard.Knights -> GHC.Types.Int -> BitBoard.Knights
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$csetBit
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Knights[0])) -}
103282c86fd0df5e492207716e3fb109
  $fBitsKnights_$cshift ::
    BitBoard.Knights -> GHC.Types.Int -> BitBoard.Knights
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cshift
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Knights[0])) -}
103282c86fd0df5e492207716e3fb109
  $fBitsKnights_$cshiftL ::
    BitBoard.Knights -> GHC.Types.Int -> BitBoard.Knights
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$cshiftL3
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Knights[0])) -}
103282c86fd0df5e492207716e3fb109
  $fBitsKnights_$cshiftR ::
    BitBoard.Knights -> GHC.Types.Int -> BitBoard.Knights
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cshiftR
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Knights[0])) -}
103282c86fd0df5e492207716e3fb109
  $fBitsKnights_$ctestBit ::
    BitBoard.Knights -> GHC.Types.Int -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$ctestBit
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0])
                 ->_R <GHC.Types.Int -> GHC.Types.Bool>_R) -}
103282c86fd0df5e492207716e3fb109
  $fBitsKnights_$cunsafeShiftL ::
    BitBoard.Knights -> GHC.Types.Int -> BitBoard.Knights
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cunsafeShiftL
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Knights[0])) -}
103282c86fd0df5e492207716e3fb109
  $fBitsKnights_$cunsafeShiftR ::
    BitBoard.Knights -> GHC.Types.Int -> BitBoard.Knights
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cunsafeShiftR
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Knights[0])) -}
103282c86fd0df5e492207716e3fb109
  $fBitsKnights_$cxor ::
    BitBoard.Knights -> BitBoard.Knights -> BitBoard.Knights
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$cxor3
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0])
                 ->_R Sym (BitBoard.NTCo:Knights[0])
                 ->_R Sym (BitBoard.NTCo:Knights[0])) -}
103282c86fd0df5e492207716e3fb109
  $fBitsKnights_$czeroBits :: BitBoard.Knights
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord6 `cast` (Sym (BitBoard.NTCo:Knights[0])) -}
d43d5bd6477b515f51d59101d16394b6
  $fBitsPawns :: Data.Bits.Bits BitBoard.Pawns
  DFunId[0]
  {- HasNoCafRefs, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Pawns
                  BitBoard.$fEqPawns
                  BitBoard.$fBitsPawns_$c.&.
                  BitBoard.$fBitsPawns_$c.|.
                  BitBoard.$fBitsPawns_$cxor
                  BitBoard.$fBitsPawns_$ccomplement
                  BitBoard.$fBitsPawns_$cshift
                  BitBoard.$fBitsPawns_$crotate
                  BitBoard.$fBitsPawns_$czeroBits
                  BitBoard.$fBitsPawns_$cbit
                  BitBoard.$fBitsPawns_$csetBit
                  BitBoard.$fBitsPawns_$cclearBit
                  BitBoard.$fBitsPawns_$ccomplementBit
                  BitBoard.$fBitsPawns_$ctestBit
                  BitBoard.$fBitsPawns_$cbitSizeMaybe
                  BitBoard.$fBitsPawns_$cfiniteBitSize
                  BitBoard.$fBitsPawns_$cisSigned
                  BitBoard.$fBitsPawns_$cshiftL
                  BitBoard.$fBitsPawns_$cunsafeShiftL
                  BitBoard.$fBitsPawns_$cshiftR
                  BitBoard.$fBitsPawns_$cunsafeShiftR
                  BitBoard.$fBitsPawns_$crotateL
                  BitBoard.$fBitsPawns_$crotateR
                  BitBoard.$fBitsPawns_$cpopCount -}
d43d5bd6477b515f51d59101d16394b6
  $fBitsPawns_$c.&. ::
    BitBoard.Pawns -> BitBoard.Pawns -> BitBoard.Pawns
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$c.&.3
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0])
                 ->_R Sym (BitBoard.NTCo:Pawns[0])
                 ->_R Sym (BitBoard.NTCo:Pawns[0])) -}
d43d5bd6477b515f51d59101d16394b6
  $fBitsPawns_$c.|. ::
    BitBoard.Pawns -> BitBoard.Pawns -> BitBoard.Pawns
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$c.|.3
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0])
                 ->_R Sym (BitBoard.NTCo:Pawns[0])
                 ->_R Sym (BitBoard.NTCo:Pawns[0])) -}
d43d5bd6477b515f51d59101d16394b6
  $fBitsPawns_$cbit :: GHC.Types.Int -> BitBoard.Pawns
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cbit
                  `cast`
                (<GHC.Types.Int>_R ->_R Sym (BitBoard.NTCo:Pawns[0])) -}
d43d5bd6477b515f51d59101d16394b6
  $fBitsPawns_$cbitSizeMaybe ::
    BitBoard.Pawns -> GHC.Base.Maybe GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>m2,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cbitSizeMaybe
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0])
                 ->_R <GHC.Base.Maybe GHC.Types.Int>_R) -}
d43d5bd6477b515f51d59101d16394b6
  $fBitsPawns_$cclearBit ::
    BitBoard.Pawns -> GHC.Types.Int -> BitBoard.Pawns
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cclearBit
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Pawns[0])) -}
d43d5bd6477b515f51d59101d16394b6
  $fBitsPawns_$ccomplement :: BitBoard.Pawns -> BitBoard.Pawns
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$ccomplement3
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0]) ->_R Sym (BitBoard.NTCo:Pawns[0])) -}
d43d5bd6477b515f51d59101d16394b6
  $fBitsPawns_$ccomplementBit ::
    BitBoard.Pawns -> GHC.Types.Int -> BitBoard.Pawns
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$ccomplementBit
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Pawns[0])) -}
d43d5bd6477b515f51d59101d16394b6
  $fBitsPawns_$cfiniteBitSize :: BitBoard.Pawns -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cfiniteBitSize
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0]) ->_R <GHC.Types.Int>_R) -}
d43d5bd6477b515f51d59101d16394b6
  $fBitsPawns_$cisSigned :: BitBoard.Pawns -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cisSigned
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0]) ->_R <GHC.Types.Bool>_R) -}
d43d5bd6477b515f51d59101d16394b6
  $fBitsPawns_$cpopCount :: BitBoard.Pawns -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cpopCount
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0]) ->_R <GHC.Types.Int>_R) -}
d43d5bd6477b515f51d59101d16394b6
  $fBitsPawns_$crotate ::
    BitBoard.Pawns -> GHC.Types.Int -> BitBoard.Pawns
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$crotate3
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Pawns[0])) -}
d43d5bd6477b515f51d59101d16394b6
  $fBitsPawns_$crotateL ::
    BitBoard.Pawns -> GHC.Types.Int -> BitBoard.Pawns
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$crotateL
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Pawns[0])) -}
d43d5bd6477b515f51d59101d16394b6
  $fBitsPawns_$crotateR ::
    BitBoard.Pawns -> GHC.Types.Int -> BitBoard.Pawns
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$crotateR
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Pawns[0])) -}
d43d5bd6477b515f51d59101d16394b6
  $fBitsPawns_$csetBit ::
    BitBoard.Pawns -> GHC.Types.Int -> BitBoard.Pawns
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$csetBit
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Pawns[0])) -}
d43d5bd6477b515f51d59101d16394b6
  $fBitsPawns_$cshift ::
    BitBoard.Pawns -> GHC.Types.Int -> BitBoard.Pawns
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cshift
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Pawns[0])) -}
d43d5bd6477b515f51d59101d16394b6
  $fBitsPawns_$cshiftL ::
    BitBoard.Pawns -> GHC.Types.Int -> BitBoard.Pawns
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$cshiftL3
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Pawns[0])) -}
d43d5bd6477b515f51d59101d16394b6
  $fBitsPawns_$cshiftR ::
    BitBoard.Pawns -> GHC.Types.Int -> BitBoard.Pawns
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cshiftR
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Pawns[0])) -}
d43d5bd6477b515f51d59101d16394b6
  $fBitsPawns_$ctestBit ::
    BitBoard.Pawns -> GHC.Types.Int -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$ctestBit
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0])
                 ->_R <GHC.Types.Int -> GHC.Types.Bool>_R) -}
d43d5bd6477b515f51d59101d16394b6
  $fBitsPawns_$cunsafeShiftL ::
    BitBoard.Pawns -> GHC.Types.Int -> BitBoard.Pawns
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cunsafeShiftL
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Pawns[0])) -}
d43d5bd6477b515f51d59101d16394b6
  $fBitsPawns_$cunsafeShiftR ::
    BitBoard.Pawns -> GHC.Types.Int -> BitBoard.Pawns
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cunsafeShiftR
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Pawns[0])) -}
d43d5bd6477b515f51d59101d16394b6
  $fBitsPawns_$cxor ::
    BitBoard.Pawns -> BitBoard.Pawns -> BitBoard.Pawns
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$cxor3
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0])
                 ->_R Sym (BitBoard.NTCo:Pawns[0])
                 ->_R Sym (BitBoard.NTCo:Pawns[0])) -}
d43d5bd6477b515f51d59101d16394b6
  $fBitsPawns_$czeroBits :: BitBoard.Pawns
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord6 `cast` (Sym (BitBoard.NTCo:Pawns[0])) -}
54dad9256b7d59d866b38b4bb67af31f
  $fBitsQueens :: Data.Bits.Bits BitBoard.Queens
  DFunId[0]
  {- HasNoCafRefs, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Queens
                  BitBoard.$fEqQueens
                  BitBoard.$fBitsQueens_$c.&.
                  BitBoard.$fBitsQueens_$c.|.
                  BitBoard.$fBitsQueens_$cxor
                  BitBoard.$fBitsQueens_$ccomplement
                  BitBoard.$fBitsQueens_$cshift
                  BitBoard.$fBitsQueens_$crotate
                  BitBoard.$fBitsQueens_$czeroBits
                  BitBoard.$fBitsQueens_$cbit
                  BitBoard.$fBitsQueens_$csetBit
                  BitBoard.$fBitsQueens_$cclearBit
                  BitBoard.$fBitsQueens_$ccomplementBit
                  BitBoard.$fBitsQueens_$ctestBit
                  BitBoard.$fBitsQueens_$cbitSizeMaybe
                  BitBoard.$fBitsQueens_$cfiniteBitSize
                  BitBoard.$fBitsQueens_$cisSigned
                  BitBoard.$fBitsQueens_$cshiftL
                  BitBoard.$fBitsQueens_$cunsafeShiftL
                  BitBoard.$fBitsQueens_$cshiftR
                  BitBoard.$fBitsQueens_$cunsafeShiftR
                  BitBoard.$fBitsQueens_$crotateL
                  BitBoard.$fBitsQueens_$crotateR
                  BitBoard.$fBitsQueens_$cpopCount -}
54dad9256b7d59d866b38b4bb67af31f
  $fBitsQueens_$c.&. ::
    BitBoard.Queens -> BitBoard.Queens -> BitBoard.Queens
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$c.&.3
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0])
                 ->_R Sym (BitBoard.NTCo:Queens[0])
                 ->_R Sym (BitBoard.NTCo:Queens[0])) -}
54dad9256b7d59d866b38b4bb67af31f
  $fBitsQueens_$c.|. ::
    BitBoard.Queens -> BitBoard.Queens -> BitBoard.Queens
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$c.|.3
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0])
                 ->_R Sym (BitBoard.NTCo:Queens[0])
                 ->_R Sym (BitBoard.NTCo:Queens[0])) -}
54dad9256b7d59d866b38b4bb67af31f
  $fBitsQueens_$cbit :: GHC.Types.Int -> BitBoard.Queens
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cbit
                  `cast`
                (<GHC.Types.Int>_R ->_R Sym (BitBoard.NTCo:Queens[0])) -}
54dad9256b7d59d866b38b4bb67af31f
  $fBitsQueens_$cbitSizeMaybe ::
    BitBoard.Queens -> GHC.Base.Maybe GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>m2,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cbitSizeMaybe
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0])
                 ->_R <GHC.Base.Maybe GHC.Types.Int>_R) -}
54dad9256b7d59d866b38b4bb67af31f
  $fBitsQueens_$cclearBit ::
    BitBoard.Queens -> GHC.Types.Int -> BitBoard.Queens
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cclearBit
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Queens[0])) -}
54dad9256b7d59d866b38b4bb67af31f
  $fBitsQueens_$ccomplement :: BitBoard.Queens -> BitBoard.Queens
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$ccomplement3
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0])
                 ->_R Sym (BitBoard.NTCo:Queens[0])) -}
54dad9256b7d59d866b38b4bb67af31f
  $fBitsQueens_$ccomplementBit ::
    BitBoard.Queens -> GHC.Types.Int -> BitBoard.Queens
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$ccomplementBit
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Queens[0])) -}
54dad9256b7d59d866b38b4bb67af31f
  $fBitsQueens_$cfiniteBitSize :: BitBoard.Queens -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cfiniteBitSize
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0]) ->_R <GHC.Types.Int>_R) -}
54dad9256b7d59d866b38b4bb67af31f
  $fBitsQueens_$cisSigned :: BitBoard.Queens -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cisSigned
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0]) ->_R <GHC.Types.Bool>_R) -}
54dad9256b7d59d866b38b4bb67af31f
  $fBitsQueens_$cpopCount :: BitBoard.Queens -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cpopCount
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0]) ->_R <GHC.Types.Int>_R) -}
54dad9256b7d59d866b38b4bb67af31f
  $fBitsQueens_$crotate ::
    BitBoard.Queens -> GHC.Types.Int -> BitBoard.Queens
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$crotate3
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Queens[0])) -}
54dad9256b7d59d866b38b4bb67af31f
  $fBitsQueens_$crotateL ::
    BitBoard.Queens -> GHC.Types.Int -> BitBoard.Queens
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$crotateL
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Queens[0])) -}
54dad9256b7d59d866b38b4bb67af31f
  $fBitsQueens_$crotateR ::
    BitBoard.Queens -> GHC.Types.Int -> BitBoard.Queens
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$crotateR
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Queens[0])) -}
54dad9256b7d59d866b38b4bb67af31f
  $fBitsQueens_$csetBit ::
    BitBoard.Queens -> GHC.Types.Int -> BitBoard.Queens
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$csetBit
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Queens[0])) -}
54dad9256b7d59d866b38b4bb67af31f
  $fBitsQueens_$cshift ::
    BitBoard.Queens -> GHC.Types.Int -> BitBoard.Queens
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cshift
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Queens[0])) -}
54dad9256b7d59d866b38b4bb67af31f
  $fBitsQueens_$cshiftL ::
    BitBoard.Queens -> GHC.Types.Int -> BitBoard.Queens
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$cshiftL3
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Queens[0])) -}
54dad9256b7d59d866b38b4bb67af31f
  $fBitsQueens_$cshiftR ::
    BitBoard.Queens -> GHC.Types.Int -> BitBoard.Queens
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cshiftR
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Queens[0])) -}
54dad9256b7d59d866b38b4bb67af31f
  $fBitsQueens_$ctestBit ::
    BitBoard.Queens -> GHC.Types.Int -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$ctestBit
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0])
                 ->_R <GHC.Types.Int -> GHC.Types.Bool>_R) -}
54dad9256b7d59d866b38b4bb67af31f
  $fBitsQueens_$cunsafeShiftL ::
    BitBoard.Queens -> GHC.Types.Int -> BitBoard.Queens
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cunsafeShiftL
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Queens[0])) -}
54dad9256b7d59d866b38b4bb67af31f
  $fBitsQueens_$cunsafeShiftR ::
    BitBoard.Queens -> GHC.Types.Int -> BitBoard.Queens
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cunsafeShiftR
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Queens[0])) -}
54dad9256b7d59d866b38b4bb67af31f
  $fBitsQueens_$cxor ::
    BitBoard.Queens -> BitBoard.Queens -> BitBoard.Queens
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$cxor3
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0])
                 ->_R Sym (BitBoard.NTCo:Queens[0])
                 ->_R Sym (BitBoard.NTCo:Queens[0])) -}
54dad9256b7d59d866b38b4bb67af31f
  $fBitsQueens_$czeroBits :: BitBoard.Queens
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord6 `cast` (Sym (BitBoard.NTCo:Queens[0])) -}
830f089678e37950d6554715dce54b27
  $fBitsRooks :: Data.Bits.Bits BitBoard.Rooks
  DFunId[0]
  {- HasNoCafRefs, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Rooks
                  BitBoard.$fEqRooks
                  BitBoard.$fBitsRooks_$c.&.
                  BitBoard.$fBitsRooks_$c.|.
                  BitBoard.$fBitsRooks_$cxor
                  BitBoard.$fBitsRooks_$ccomplement
                  BitBoard.$fBitsRooks_$cshift
                  BitBoard.$fBitsRooks_$crotate
                  BitBoard.$fBitsRooks_$czeroBits
                  BitBoard.$fBitsRooks_$cbit
                  BitBoard.$fBitsRooks_$csetBit
                  BitBoard.$fBitsRooks_$cclearBit
                  BitBoard.$fBitsRooks_$ccomplementBit
                  BitBoard.$fBitsRooks_$ctestBit
                  BitBoard.$fBitsRooks_$cbitSizeMaybe
                  BitBoard.$fBitsRooks_$cfiniteBitSize
                  BitBoard.$fBitsRooks_$cisSigned
                  BitBoard.$fBitsRooks_$cshiftL
                  BitBoard.$fBitsRooks_$cunsafeShiftL
                  BitBoard.$fBitsRooks_$cshiftR
                  BitBoard.$fBitsRooks_$cunsafeShiftR
                  BitBoard.$fBitsRooks_$crotateL
                  BitBoard.$fBitsRooks_$crotateR
                  BitBoard.$fBitsRooks_$cpopCount -}
830f089678e37950d6554715dce54b27
  $fBitsRooks_$c.&. ::
    BitBoard.Rooks -> BitBoard.Rooks -> BitBoard.Rooks
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$c.&.3
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0])
                 ->_R Sym (BitBoard.NTCo:Rooks[0])
                 ->_R Sym (BitBoard.NTCo:Rooks[0])) -}
830f089678e37950d6554715dce54b27
  $fBitsRooks_$c.|. ::
    BitBoard.Rooks -> BitBoard.Rooks -> BitBoard.Rooks
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$c.|.3
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0])
                 ->_R Sym (BitBoard.NTCo:Rooks[0])
                 ->_R Sym (BitBoard.NTCo:Rooks[0])) -}
830f089678e37950d6554715dce54b27
  $fBitsRooks_$cbit :: GHC.Types.Int -> BitBoard.Rooks
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cbit
                  `cast`
                (<GHC.Types.Int>_R ->_R Sym (BitBoard.NTCo:Rooks[0])) -}
830f089678e37950d6554715dce54b27
  $fBitsRooks_$cbitSizeMaybe ::
    BitBoard.Rooks -> GHC.Base.Maybe GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>m2,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cbitSizeMaybe
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0])
                 ->_R <GHC.Base.Maybe GHC.Types.Int>_R) -}
830f089678e37950d6554715dce54b27
  $fBitsRooks_$cclearBit ::
    BitBoard.Rooks -> GHC.Types.Int -> BitBoard.Rooks
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cclearBit
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Rooks[0])) -}
830f089678e37950d6554715dce54b27
  $fBitsRooks_$ccomplement :: BitBoard.Rooks -> BitBoard.Rooks
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$ccomplement3
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0]) ->_R Sym (BitBoard.NTCo:Rooks[0])) -}
830f089678e37950d6554715dce54b27
  $fBitsRooks_$ccomplementBit ::
    BitBoard.Rooks -> GHC.Types.Int -> BitBoard.Rooks
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$ccomplementBit
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Rooks[0])) -}
830f089678e37950d6554715dce54b27
  $fBitsRooks_$cfiniteBitSize :: BitBoard.Rooks -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cfiniteBitSize
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0]) ->_R <GHC.Types.Int>_R) -}
830f089678e37950d6554715dce54b27
  $fBitsRooks_$cisSigned :: BitBoard.Rooks -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cisSigned
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0]) ->_R <GHC.Types.Bool>_R) -}
830f089678e37950d6554715dce54b27
  $fBitsRooks_$cpopCount :: BitBoard.Rooks -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cpopCount
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0]) ->_R <GHC.Types.Int>_R) -}
830f089678e37950d6554715dce54b27
  $fBitsRooks_$crotate ::
    BitBoard.Rooks -> GHC.Types.Int -> BitBoard.Rooks
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$crotate3
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Rooks[0])) -}
830f089678e37950d6554715dce54b27
  $fBitsRooks_$crotateL ::
    BitBoard.Rooks -> GHC.Types.Int -> BitBoard.Rooks
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$crotateL
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Rooks[0])) -}
830f089678e37950d6554715dce54b27
  $fBitsRooks_$crotateR ::
    BitBoard.Rooks -> GHC.Types.Int -> BitBoard.Rooks
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$crotateR
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Rooks[0])) -}
830f089678e37950d6554715dce54b27
  $fBitsRooks_$csetBit ::
    BitBoard.Rooks -> GHC.Types.Int -> BitBoard.Rooks
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$csetBit
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Rooks[0])) -}
830f089678e37950d6554715dce54b27
  $fBitsRooks_$cshift ::
    BitBoard.Rooks -> GHC.Types.Int -> BitBoard.Rooks
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cshift
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Rooks[0])) -}
830f089678e37950d6554715dce54b27
  $fBitsRooks_$cshiftL ::
    BitBoard.Rooks -> GHC.Types.Int -> BitBoard.Rooks
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$cshiftL3
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Rooks[0])) -}
830f089678e37950d6554715dce54b27
  $fBitsRooks_$cshiftR ::
    BitBoard.Rooks -> GHC.Types.Int -> BitBoard.Rooks
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cshiftR
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Rooks[0])) -}
830f089678e37950d6554715dce54b27
  $fBitsRooks_$ctestBit ::
    BitBoard.Rooks -> GHC.Types.Int -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$ctestBit
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0])
                 ->_R <GHC.Types.Int -> GHC.Types.Bool>_R) -}
830f089678e37950d6554715dce54b27
  $fBitsRooks_$cunsafeShiftL ::
    BitBoard.Rooks -> GHC.Types.Int -> BitBoard.Rooks
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cunsafeShiftL
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Rooks[0])) -}
830f089678e37950d6554715dce54b27
  $fBitsRooks_$cunsafeShiftR ::
    BitBoard.Rooks -> GHC.Types.Int -> BitBoard.Rooks
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cunsafeShiftR
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:Rooks[0])) -}
830f089678e37950d6554715dce54b27
  $fBitsRooks_$cxor ::
    BitBoard.Rooks -> BitBoard.Rooks -> BitBoard.Rooks
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$cxor3
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0])
                 ->_R Sym (BitBoard.NTCo:Rooks[0])
                 ->_R Sym (BitBoard.NTCo:Rooks[0])) -}
830f089678e37950d6554715dce54b27
  $fBitsRooks_$czeroBits :: BitBoard.Rooks
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord6 `cast` (Sym (BitBoard.NTCo:Rooks[0])) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fBitsWhitePieces :: Data.Bits.Bits BitBoard.WhitePieces
  DFunId[0]
  {- HasNoCafRefs, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.WhitePieces
                  BitBoard.$fEqWhitePieces
                  BitBoard.$fBitsWhitePieces_$c.&.
                  BitBoard.$fBitsWhitePieces_$c.|.
                  BitBoard.$fBitsWhitePieces_$cxor
                  BitBoard.$fBitsWhitePieces_$ccomplement
                  BitBoard.$fBitsWhitePieces_$cshift
                  BitBoard.$fBitsWhitePieces_$crotate
                  BitBoard.$fBitsWhitePieces_$czeroBits
                  BitBoard.$fBitsWhitePieces_$cbit
                  BitBoard.$fBitsWhitePieces_$csetBit
                  BitBoard.$fBitsWhitePieces_$cclearBit
                  BitBoard.$fBitsWhitePieces_$ccomplementBit
                  BitBoard.$fBitsWhitePieces_$ctestBit
                  BitBoard.$fBitsWhitePieces_$cbitSizeMaybe
                  BitBoard.$fBitsWhitePieces_$cfiniteBitSize
                  BitBoard.$fBitsWhitePieces_$cisSigned
                  BitBoard.$fBitsWhitePieces_$cshiftL
                  BitBoard.$fBitsWhitePieces_$cunsafeShiftL
                  BitBoard.$fBitsWhitePieces_$cshiftR
                  BitBoard.$fBitsWhitePieces_$cunsafeShiftR
                  BitBoard.$fBitsWhitePieces_$crotateL
                  BitBoard.$fBitsWhitePieces_$crotateR
                  BitBoard.$fBitsWhitePieces_$cpopCount -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fBitsWhitePieces_$c.&. ::
    BitBoard.WhitePieces
    -> BitBoard.WhitePieces -> BitBoard.WhitePieces
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$c.&.3
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fBitsWhitePieces_$c.|. ::
    BitBoard.WhitePieces
    -> BitBoard.WhitePieces -> BitBoard.WhitePieces
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$c.|.3
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fBitsWhitePieces_$cbit :: GHC.Types.Int -> BitBoard.WhitePieces
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cbit
                  `cast`
                (<GHC.Types.Int>_R ->_R Sym (BitBoard.NTCo:WhitePieces[0])) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fBitsWhitePieces_$cbitSizeMaybe ::
    BitBoard.WhitePieces -> GHC.Base.Maybe GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>m2,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cbitSizeMaybe
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R <GHC.Base.Maybe GHC.Types.Int>_R) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fBitsWhitePieces_$cclearBit ::
    BitBoard.WhitePieces -> GHC.Types.Int -> BitBoard.WhitePieces
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cclearBit
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fBitsWhitePieces_$ccomplement ::
    BitBoard.WhitePieces -> BitBoard.WhitePieces
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$ccomplement3
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fBitsWhitePieces_$ccomplementBit ::
    BitBoard.WhitePieces -> GHC.Types.Int -> BitBoard.WhitePieces
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$ccomplementBit
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fBitsWhitePieces_$cfiniteBitSize ::
    BitBoard.WhitePieces -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cfiniteBitSize
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0]) ->_R <GHC.Types.Int>_R) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fBitsWhitePieces_$cisSigned ::
    BitBoard.WhitePieces -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cisSigned
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0]) ->_R <GHC.Types.Bool>_R) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fBitsWhitePieces_$cpopCount ::
    BitBoard.WhitePieces -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cpopCount
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0]) ->_R <GHC.Types.Int>_R) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fBitsWhitePieces_$crotate ::
    BitBoard.WhitePieces -> GHC.Types.Int -> BitBoard.WhitePieces
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$crotate3
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fBitsWhitePieces_$crotateL ::
    BitBoard.WhitePieces -> GHC.Types.Int -> BitBoard.WhitePieces
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$crotateL
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fBitsWhitePieces_$crotateR ::
    BitBoard.WhitePieces -> GHC.Types.Int -> BitBoard.WhitePieces
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$crotateR
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fBitsWhitePieces_$csetBit ::
    BitBoard.WhitePieces -> GHC.Types.Int -> BitBoard.WhitePieces
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$csetBit
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fBitsWhitePieces_$cshift ::
    BitBoard.WhitePieces -> GHC.Types.Int -> BitBoard.WhitePieces
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cshift
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fBitsWhitePieces_$cshiftL ::
    BitBoard.WhitePieces -> GHC.Types.Int -> BitBoard.WhitePieces
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$cshiftL3
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fBitsWhitePieces_$cshiftR ::
    BitBoard.WhitePieces -> GHC.Types.Int -> BitBoard.WhitePieces
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cshiftR
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fBitsWhitePieces_$ctestBit ::
    BitBoard.WhitePieces -> GHC.Types.Int -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$ctestBit
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R <GHC.Types.Int -> GHC.Types.Bool>_R) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fBitsWhitePieces_$cunsafeShiftL ::
    BitBoard.WhitePieces -> GHC.Types.Int -> BitBoard.WhitePieces
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cunsafeShiftL
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fBitsWhitePieces_$cunsafeShiftR ::
    BitBoard.WhitePieces -> GHC.Types.Int -> BitBoard.WhitePieces
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$cunsafeShiftR
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fBitsWhitePieces_$cxor ::
    BitBoard.WhitePieces
    -> BitBoard.WhitePieces -> BitBoard.WhitePieces
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$cxor3
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fBitsWhitePieces_$czeroBits :: BitBoard.WhitePieces
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord6 `cast` (Sym (BitBoard.NTCo:WhitePieces[0])) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fEnumBishops :: GHC.Enum.Enum BitBoard.Bishops
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Bishops
                  BitBoard.$fEnumBishops_$csucc
                  BitBoard.$fEnumBishops_$cpred
                  BitBoard.$fEnumBishops_$ctoEnum
                  BitBoard.$fEnumBishops_$cfromEnum
                  BitBoard.$fEnumBishops_$cenumFrom
                  BitBoard.$fEnumBishops_$cenumFromThen
                  BitBoard.$fEnumBishops_$cenumFromTo
                  BitBoard.$fEnumBishops_$cenumFromThenTo -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fEnumBishops_$cenumFrom :: BitBoard.Bishops -> [BitBoard.Bishops]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cenumFrom
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0])
                 ->_R ([Sym (BitBoard.NTCo:Bishops[0])])_R) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fEnumBishops_$cenumFromThen ::
    BitBoard.Bishops -> BitBoard.Bishops -> [BitBoard.Bishops]
  {- Arity: 2,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cenumFromThen
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0])
                 ->_R Sym (BitBoard.NTCo:Bishops[0])
                 ->_R ([Sym (BitBoard.NTCo:Bishops[0])])_R) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fEnumBishops_$cenumFromThenTo ::
    BitBoard.Bishops
    -> BitBoard.Bishops -> BitBoard.Bishops -> [BitBoard.Bishops]
  {- Arity: 3,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cenumFromThenTo
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0])
                 ->_R Sym (BitBoard.NTCo:Bishops[0])
                 ->_R Sym (BitBoard.NTCo:Bishops[0])
                 ->_R ([Sym (BitBoard.NTCo:Bishops[0])])_R) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fEnumBishops_$cenumFromTo ::
    BitBoard.Bishops -> BitBoard.Bishops -> [BitBoard.Bishops]
  {- Arity: 2,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cenumFromTo
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0])
                 ->_R Sym (BitBoard.NTCo:Bishops[0])
                 ->_R ([Sym (BitBoard.NTCo:Bishops[0])])_R) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fEnumBishops_$cfromEnum :: BitBoard.Bishops -> GHC.Types.Int
  {- Arity: 1, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cfromEnum
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0]) ->_R <GHC.Types.Int>_R) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fEnumBishops_$cpred :: BitBoard.Bishops -> BitBoard.Bishops
  {- Arity: 1, Strictness: <S(S),1*U(1*U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cpred
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0])
                 ->_R Sym (BitBoard.NTCo:Bishops[0])) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fEnumBishops_$csucc :: BitBoard.Bishops -> BitBoard.Bishops
  {- Arity: 1, Strictness: <S(S),1*U(1*U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$csucc
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0])
                 ->_R Sym (BitBoard.NTCo:Bishops[0])) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fEnumBishops_$ctoEnum :: GHC.Types.Int -> BitBoard.Bishops
  {- Arity: 1, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$ctoEnum
                  `cast`
                (<GHC.Types.Int>_R ->_R Sym (BitBoard.NTCo:Bishops[0])) -}
9ddff55270133108c79e28dd74ad22ce
  $fEnumBlackPieces :: GHC.Enum.Enum BitBoard.BlackPieces
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.BlackPieces
                  BitBoard.$fEnumBlackPieces_$csucc
                  BitBoard.$fEnumBlackPieces_$cpred
                  BitBoard.$fEnumBlackPieces_$ctoEnum
                  BitBoard.$fEnumBlackPieces_$cfromEnum
                  BitBoard.$fEnumBlackPieces_$cenumFrom
                  BitBoard.$fEnumBlackPieces_$cenumFromThen
                  BitBoard.$fEnumBlackPieces_$cenumFromTo
                  BitBoard.$fEnumBlackPieces_$cenumFromThenTo -}
9ddff55270133108c79e28dd74ad22ce
  $fEnumBlackPieces_$cenumFrom ::
    BitBoard.BlackPieces -> [BitBoard.BlackPieces]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cenumFrom
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R ([Sym (BitBoard.NTCo:BlackPieces[0])])_R) -}
9ddff55270133108c79e28dd74ad22ce
  $fEnumBlackPieces_$cenumFromThen ::
    BitBoard.BlackPieces
    -> BitBoard.BlackPieces -> [BitBoard.BlackPieces]
  {- Arity: 2,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cenumFromThen
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R ([Sym (BitBoard.NTCo:BlackPieces[0])])_R) -}
9ddff55270133108c79e28dd74ad22ce
  $fEnumBlackPieces_$cenumFromThenTo ::
    BitBoard.BlackPieces
    -> BitBoard.BlackPieces
    -> BitBoard.BlackPieces
    -> [BitBoard.BlackPieces]
  {- Arity: 3,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cenumFromThenTo
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R ([Sym (BitBoard.NTCo:BlackPieces[0])])_R) -}
9ddff55270133108c79e28dd74ad22ce
  $fEnumBlackPieces_$cenumFromTo ::
    BitBoard.BlackPieces
    -> BitBoard.BlackPieces -> [BitBoard.BlackPieces]
  {- Arity: 2,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cenumFromTo
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R ([Sym (BitBoard.NTCo:BlackPieces[0])])_R) -}
9ddff55270133108c79e28dd74ad22ce
  $fEnumBlackPieces_$cfromEnum ::
    BitBoard.BlackPieces -> GHC.Types.Int
  {- Arity: 1, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cfromEnum
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0]) ->_R <GHC.Types.Int>_R) -}
9ddff55270133108c79e28dd74ad22ce
  $fEnumBlackPieces_$cpred ::
    BitBoard.BlackPieces -> BitBoard.BlackPieces
  {- Arity: 1, Strictness: <S(S),1*U(1*U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cpred
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])) -}
9ddff55270133108c79e28dd74ad22ce
  $fEnumBlackPieces_$csucc ::
    BitBoard.BlackPieces -> BitBoard.BlackPieces
  {- Arity: 1, Strictness: <S(S),1*U(1*U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$csucc
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])) -}
9ddff55270133108c79e28dd74ad22ce
  $fEnumBlackPieces_$ctoEnum :: GHC.Types.Int -> BitBoard.BlackPieces
  {- Arity: 1, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$ctoEnum
                  `cast`
                (<GHC.Types.Int>_R ->_R Sym (BitBoard.NTCo:BlackPieces[0])) -}
065b32ad76ea4a8b0402f332e197f31d
  $fEnumKings :: GHC.Enum.Enum BitBoard.Kings
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Kings
                  BitBoard.$fEnumKings_$csucc
                  BitBoard.$fEnumKings_$cpred
                  BitBoard.$fEnumKings_$ctoEnum
                  BitBoard.$fEnumKings_$cfromEnum
                  BitBoard.$fEnumKings_$cenumFrom
                  BitBoard.$fEnumKings_$cenumFromThen
                  BitBoard.$fEnumKings_$cenumFromTo
                  BitBoard.$fEnumKings_$cenumFromThenTo -}
065b32ad76ea4a8b0402f332e197f31d
  $fEnumKings_$cenumFrom :: BitBoard.Kings -> [BitBoard.Kings]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cenumFrom
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0])
                 ->_R ([Sym (BitBoard.NTCo:Kings[0])])_R) -}
065b32ad76ea4a8b0402f332e197f31d
  $fEnumKings_$cenumFromThen ::
    BitBoard.Kings -> BitBoard.Kings -> [BitBoard.Kings]
  {- Arity: 2,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cenumFromThen
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0])
                 ->_R Sym (BitBoard.NTCo:Kings[0])
                 ->_R ([Sym (BitBoard.NTCo:Kings[0])])_R) -}
065b32ad76ea4a8b0402f332e197f31d
  $fEnumKings_$cenumFromThenTo ::
    BitBoard.Kings
    -> BitBoard.Kings -> BitBoard.Kings -> [BitBoard.Kings]
  {- Arity: 3,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cenumFromThenTo
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0])
                 ->_R Sym (BitBoard.NTCo:Kings[0])
                 ->_R Sym (BitBoard.NTCo:Kings[0])
                 ->_R ([Sym (BitBoard.NTCo:Kings[0])])_R) -}
065b32ad76ea4a8b0402f332e197f31d
  $fEnumKings_$cenumFromTo ::
    BitBoard.Kings -> BitBoard.Kings -> [BitBoard.Kings]
  {- Arity: 2,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cenumFromTo
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0])
                 ->_R Sym (BitBoard.NTCo:Kings[0])
                 ->_R ([Sym (BitBoard.NTCo:Kings[0])])_R) -}
065b32ad76ea4a8b0402f332e197f31d
  $fEnumKings_$cfromEnum :: BitBoard.Kings -> GHC.Types.Int
  {- Arity: 1, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cfromEnum
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0]) ->_R <GHC.Types.Int>_R) -}
065b32ad76ea4a8b0402f332e197f31d
  $fEnumKings_$cpred :: BitBoard.Kings -> BitBoard.Kings
  {- Arity: 1, Strictness: <S(S),1*U(1*U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cpred
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0]) ->_R Sym (BitBoard.NTCo:Kings[0])) -}
065b32ad76ea4a8b0402f332e197f31d
  $fEnumKings_$csucc :: BitBoard.Kings -> BitBoard.Kings
  {- Arity: 1, Strictness: <S(S),1*U(1*U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$csucc
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0]) ->_R Sym (BitBoard.NTCo:Kings[0])) -}
065b32ad76ea4a8b0402f332e197f31d
  $fEnumKings_$ctoEnum :: GHC.Types.Int -> BitBoard.Kings
  {- Arity: 1, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$ctoEnum
                  `cast`
                (<GHC.Types.Int>_R ->_R Sym (BitBoard.NTCo:Kings[0])) -}
103282c86fd0df5e492207716e3fb109
  $fEnumKnights :: GHC.Enum.Enum BitBoard.Knights
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Knights
                  BitBoard.$fEnumKnights_$csucc
                  BitBoard.$fEnumKnights_$cpred
                  BitBoard.$fEnumKnights_$ctoEnum
                  BitBoard.$fEnumKnights_$cfromEnum
                  BitBoard.$fEnumKnights_$cenumFrom
                  BitBoard.$fEnumKnights_$cenumFromThen
                  BitBoard.$fEnumKnights_$cenumFromTo
                  BitBoard.$fEnumKnights_$cenumFromThenTo -}
103282c86fd0df5e492207716e3fb109
  $fEnumKnights_$cenumFrom :: BitBoard.Knights -> [BitBoard.Knights]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cenumFrom
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0])
                 ->_R ([Sym (BitBoard.NTCo:Knights[0])])_R) -}
103282c86fd0df5e492207716e3fb109
  $fEnumKnights_$cenumFromThen ::
    BitBoard.Knights -> BitBoard.Knights -> [BitBoard.Knights]
  {- Arity: 2,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cenumFromThen
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0])
                 ->_R Sym (BitBoard.NTCo:Knights[0])
                 ->_R ([Sym (BitBoard.NTCo:Knights[0])])_R) -}
103282c86fd0df5e492207716e3fb109
  $fEnumKnights_$cenumFromThenTo ::
    BitBoard.Knights
    -> BitBoard.Knights -> BitBoard.Knights -> [BitBoard.Knights]
  {- Arity: 3,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cenumFromThenTo
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0])
                 ->_R Sym (BitBoard.NTCo:Knights[0])
                 ->_R Sym (BitBoard.NTCo:Knights[0])
                 ->_R ([Sym (BitBoard.NTCo:Knights[0])])_R) -}
103282c86fd0df5e492207716e3fb109
  $fEnumKnights_$cenumFromTo ::
    BitBoard.Knights -> BitBoard.Knights -> [BitBoard.Knights]
  {- Arity: 2,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cenumFromTo
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0])
                 ->_R Sym (BitBoard.NTCo:Knights[0])
                 ->_R ([Sym (BitBoard.NTCo:Knights[0])])_R) -}
103282c86fd0df5e492207716e3fb109
  $fEnumKnights_$cfromEnum :: BitBoard.Knights -> GHC.Types.Int
  {- Arity: 1, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cfromEnum
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0]) ->_R <GHC.Types.Int>_R) -}
103282c86fd0df5e492207716e3fb109
  $fEnumKnights_$cpred :: BitBoard.Knights -> BitBoard.Knights
  {- Arity: 1, Strictness: <S(S),1*U(1*U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cpred
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0])
                 ->_R Sym (BitBoard.NTCo:Knights[0])) -}
103282c86fd0df5e492207716e3fb109
  $fEnumKnights_$csucc :: BitBoard.Knights -> BitBoard.Knights
  {- Arity: 1, Strictness: <S(S),1*U(1*U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$csucc
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0])
                 ->_R Sym (BitBoard.NTCo:Knights[0])) -}
103282c86fd0df5e492207716e3fb109
  $fEnumKnights_$ctoEnum :: GHC.Types.Int -> BitBoard.Knights
  {- Arity: 1, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$ctoEnum
                  `cast`
                (<GHC.Types.Int>_R ->_R Sym (BitBoard.NTCo:Knights[0])) -}
d43d5bd6477b515f51d59101d16394b6
  $fEnumPawns :: GHC.Enum.Enum BitBoard.Pawns
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Pawns
                  BitBoard.$fEnumPawns_$csucc
                  BitBoard.$fEnumPawns_$cpred
                  BitBoard.$fEnumPawns_$ctoEnum
                  BitBoard.$fEnumPawns_$cfromEnum
                  BitBoard.$fEnumPawns_$cenumFrom
                  BitBoard.$fEnumPawns_$cenumFromThen
                  BitBoard.$fEnumPawns_$cenumFromTo
                  BitBoard.$fEnumPawns_$cenumFromThenTo -}
d43d5bd6477b515f51d59101d16394b6
  $fEnumPawns_$cenumFrom :: BitBoard.Pawns -> [BitBoard.Pawns]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cenumFrom
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0])
                 ->_R ([Sym (BitBoard.NTCo:Pawns[0])])_R) -}
d43d5bd6477b515f51d59101d16394b6
  $fEnumPawns_$cenumFromThen ::
    BitBoard.Pawns -> BitBoard.Pawns -> [BitBoard.Pawns]
  {- Arity: 2,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cenumFromThen
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0])
                 ->_R Sym (BitBoard.NTCo:Pawns[0])
                 ->_R ([Sym (BitBoard.NTCo:Pawns[0])])_R) -}
d43d5bd6477b515f51d59101d16394b6
  $fEnumPawns_$cenumFromThenTo ::
    BitBoard.Pawns
    -> BitBoard.Pawns -> BitBoard.Pawns -> [BitBoard.Pawns]
  {- Arity: 3,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cenumFromThenTo
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0])
                 ->_R Sym (BitBoard.NTCo:Pawns[0])
                 ->_R Sym (BitBoard.NTCo:Pawns[0])
                 ->_R ([Sym (BitBoard.NTCo:Pawns[0])])_R) -}
d43d5bd6477b515f51d59101d16394b6
  $fEnumPawns_$cenumFromTo ::
    BitBoard.Pawns -> BitBoard.Pawns -> [BitBoard.Pawns]
  {- Arity: 2,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cenumFromTo
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0])
                 ->_R Sym (BitBoard.NTCo:Pawns[0])
                 ->_R ([Sym (BitBoard.NTCo:Pawns[0])])_R) -}
d43d5bd6477b515f51d59101d16394b6
  $fEnumPawns_$cfromEnum :: BitBoard.Pawns -> GHC.Types.Int
  {- Arity: 1, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cfromEnum
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0]) ->_R <GHC.Types.Int>_R) -}
d43d5bd6477b515f51d59101d16394b6
  $fEnumPawns_$cpred :: BitBoard.Pawns -> BitBoard.Pawns
  {- Arity: 1, Strictness: <S(S),1*U(1*U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cpred
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0]) ->_R Sym (BitBoard.NTCo:Pawns[0])) -}
d43d5bd6477b515f51d59101d16394b6
  $fEnumPawns_$csucc :: BitBoard.Pawns -> BitBoard.Pawns
  {- Arity: 1, Strictness: <S(S),1*U(1*U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$csucc
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0]) ->_R Sym (BitBoard.NTCo:Pawns[0])) -}
d43d5bd6477b515f51d59101d16394b6
  $fEnumPawns_$ctoEnum :: GHC.Types.Int -> BitBoard.Pawns
  {- Arity: 1, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$ctoEnum
                  `cast`
                (<GHC.Types.Int>_R ->_R Sym (BitBoard.NTCo:Pawns[0])) -}
54dad9256b7d59d866b38b4bb67af31f
  $fEnumQueens :: GHC.Enum.Enum BitBoard.Queens
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Queens
                  BitBoard.$fEnumQueens_$csucc
                  BitBoard.$fEnumQueens_$cpred
                  BitBoard.$fEnumQueens_$ctoEnum
                  BitBoard.$fEnumQueens_$cfromEnum
                  BitBoard.$fEnumQueens_$cenumFrom
                  BitBoard.$fEnumQueens_$cenumFromThen
                  BitBoard.$fEnumQueens_$cenumFromTo
                  BitBoard.$fEnumQueens_$cenumFromThenTo -}
54dad9256b7d59d866b38b4bb67af31f
  $fEnumQueens_$cenumFrom :: BitBoard.Queens -> [BitBoard.Queens]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cenumFrom
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0])
                 ->_R ([Sym (BitBoard.NTCo:Queens[0])])_R) -}
54dad9256b7d59d866b38b4bb67af31f
  $fEnumQueens_$cenumFromThen ::
    BitBoard.Queens -> BitBoard.Queens -> [BitBoard.Queens]
  {- Arity: 2,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cenumFromThen
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0])
                 ->_R Sym (BitBoard.NTCo:Queens[0])
                 ->_R ([Sym (BitBoard.NTCo:Queens[0])])_R) -}
54dad9256b7d59d866b38b4bb67af31f
  $fEnumQueens_$cenumFromThenTo ::
    BitBoard.Queens
    -> BitBoard.Queens -> BitBoard.Queens -> [BitBoard.Queens]
  {- Arity: 3,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cenumFromThenTo
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0])
                 ->_R Sym (BitBoard.NTCo:Queens[0])
                 ->_R Sym (BitBoard.NTCo:Queens[0])
                 ->_R ([Sym (BitBoard.NTCo:Queens[0])])_R) -}
54dad9256b7d59d866b38b4bb67af31f
  $fEnumQueens_$cenumFromTo ::
    BitBoard.Queens -> BitBoard.Queens -> [BitBoard.Queens]
  {- Arity: 2,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cenumFromTo
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0])
                 ->_R Sym (BitBoard.NTCo:Queens[0])
                 ->_R ([Sym (BitBoard.NTCo:Queens[0])])_R) -}
54dad9256b7d59d866b38b4bb67af31f
  $fEnumQueens_$cfromEnum :: BitBoard.Queens -> GHC.Types.Int
  {- Arity: 1, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cfromEnum
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0]) ->_R <GHC.Types.Int>_R) -}
54dad9256b7d59d866b38b4bb67af31f
  $fEnumQueens_$cpred :: BitBoard.Queens -> BitBoard.Queens
  {- Arity: 1, Strictness: <S(S),1*U(1*U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cpred
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0])
                 ->_R Sym (BitBoard.NTCo:Queens[0])) -}
54dad9256b7d59d866b38b4bb67af31f
  $fEnumQueens_$csucc :: BitBoard.Queens -> BitBoard.Queens
  {- Arity: 1, Strictness: <S(S),1*U(1*U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$csucc
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0])
                 ->_R Sym (BitBoard.NTCo:Queens[0])) -}
54dad9256b7d59d866b38b4bb67af31f
  $fEnumQueens_$ctoEnum :: GHC.Types.Int -> BitBoard.Queens
  {- Arity: 1, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$ctoEnum
                  `cast`
                (<GHC.Types.Int>_R ->_R Sym (BitBoard.NTCo:Queens[0])) -}
830f089678e37950d6554715dce54b27
  $fEnumRooks :: GHC.Enum.Enum BitBoard.Rooks
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Rooks
                  BitBoard.$fEnumRooks_$csucc
                  BitBoard.$fEnumRooks_$cpred
                  BitBoard.$fEnumRooks_$ctoEnum
                  BitBoard.$fEnumRooks_$cfromEnum
                  BitBoard.$fEnumRooks_$cenumFrom
                  BitBoard.$fEnumRooks_$cenumFromThen
                  BitBoard.$fEnumRooks_$cenumFromTo
                  BitBoard.$fEnumRooks_$cenumFromThenTo -}
830f089678e37950d6554715dce54b27
  $fEnumRooks_$cenumFrom :: BitBoard.Rooks -> [BitBoard.Rooks]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cenumFrom
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0])
                 ->_R ([Sym (BitBoard.NTCo:Rooks[0])])_R) -}
830f089678e37950d6554715dce54b27
  $fEnumRooks_$cenumFromThen ::
    BitBoard.Rooks -> BitBoard.Rooks -> [BitBoard.Rooks]
  {- Arity: 2,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cenumFromThen
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0])
                 ->_R Sym (BitBoard.NTCo:Rooks[0])
                 ->_R ([Sym (BitBoard.NTCo:Rooks[0])])_R) -}
830f089678e37950d6554715dce54b27
  $fEnumRooks_$cenumFromThenTo ::
    BitBoard.Rooks
    -> BitBoard.Rooks -> BitBoard.Rooks -> [BitBoard.Rooks]
  {- Arity: 3,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cenumFromThenTo
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0])
                 ->_R Sym (BitBoard.NTCo:Rooks[0])
                 ->_R Sym (BitBoard.NTCo:Rooks[0])
                 ->_R ([Sym (BitBoard.NTCo:Rooks[0])])_R) -}
830f089678e37950d6554715dce54b27
  $fEnumRooks_$cenumFromTo ::
    BitBoard.Rooks -> BitBoard.Rooks -> [BitBoard.Rooks]
  {- Arity: 2,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cenumFromTo
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0])
                 ->_R Sym (BitBoard.NTCo:Rooks[0])
                 ->_R ([Sym (BitBoard.NTCo:Rooks[0])])_R) -}
830f089678e37950d6554715dce54b27
  $fEnumRooks_$cfromEnum :: BitBoard.Rooks -> GHC.Types.Int
  {- Arity: 1, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cfromEnum
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0]) ->_R <GHC.Types.Int>_R) -}
830f089678e37950d6554715dce54b27
  $fEnumRooks_$cpred :: BitBoard.Rooks -> BitBoard.Rooks
  {- Arity: 1, Strictness: <S(S),1*U(1*U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cpred
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0]) ->_R Sym (BitBoard.NTCo:Rooks[0])) -}
830f089678e37950d6554715dce54b27
  $fEnumRooks_$csucc :: BitBoard.Rooks -> BitBoard.Rooks
  {- Arity: 1, Strictness: <S(S),1*U(1*U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$csucc
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0]) ->_R Sym (BitBoard.NTCo:Rooks[0])) -}
830f089678e37950d6554715dce54b27
  $fEnumRooks_$ctoEnum :: GHC.Types.Int -> BitBoard.Rooks
  {- Arity: 1, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$ctoEnum
                  `cast`
                (<GHC.Types.Int>_R ->_R Sym (BitBoard.NTCo:Rooks[0])) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fEnumWhitePieces :: GHC.Enum.Enum BitBoard.WhitePieces
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.WhitePieces
                  BitBoard.$fEnumWhitePieces_$csucc
                  BitBoard.$fEnumWhitePieces_$cpred
                  BitBoard.$fEnumWhitePieces_$ctoEnum
                  BitBoard.$fEnumWhitePieces_$cfromEnum
                  BitBoard.$fEnumWhitePieces_$cenumFrom
                  BitBoard.$fEnumWhitePieces_$cenumFromThen
                  BitBoard.$fEnumWhitePieces_$cenumFromTo
                  BitBoard.$fEnumWhitePieces_$cenumFromThenTo -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fEnumWhitePieces_$cenumFrom ::
    BitBoard.WhitePieces -> [BitBoard.WhitePieces]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cenumFrom
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R ([Sym (BitBoard.NTCo:WhitePieces[0])])_R) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fEnumWhitePieces_$cenumFromThen ::
    BitBoard.WhitePieces
    -> BitBoard.WhitePieces -> [BitBoard.WhitePieces]
  {- Arity: 2,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cenumFromThen
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R ([Sym (BitBoard.NTCo:WhitePieces[0])])_R) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fEnumWhitePieces_$cenumFromThenTo ::
    BitBoard.WhitePieces
    -> BitBoard.WhitePieces
    -> BitBoard.WhitePieces
    -> [BitBoard.WhitePieces]
  {- Arity: 3,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cenumFromThenTo
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R ([Sym (BitBoard.NTCo:WhitePieces[0])])_R) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fEnumWhitePieces_$cenumFromTo ::
    BitBoard.WhitePieces
    -> BitBoard.WhitePieces -> [BitBoard.WhitePieces]
  {- Arity: 2,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cenumFromTo
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R ([Sym (BitBoard.NTCo:WhitePieces[0])])_R) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fEnumWhitePieces_$cfromEnum ::
    BitBoard.WhitePieces -> GHC.Types.Int
  {- Arity: 1, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cfromEnum
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0]) ->_R <GHC.Types.Int>_R) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fEnumWhitePieces_$cpred ::
    BitBoard.WhitePieces -> BitBoard.WhitePieces
  {- Arity: 1, Strictness: <S(S),1*U(1*U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$cpred
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fEnumWhitePieces_$csucc ::
    BitBoard.WhitePieces -> BitBoard.WhitePieces
  {- Arity: 1, Strictness: <S(S),1*U(1*U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$csucc
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fEnumWhitePieces_$ctoEnum :: GHC.Types.Int -> BitBoard.WhitePieces
  {- Arity: 1, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEnumWord64_$ctoEnum
                  `cast`
                (<GHC.Types.Int>_R ->_R Sym (BitBoard.NTCo:WhitePieces[0])) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fEqBishops :: GHC.Classes.Eq BitBoard.Bishops
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Bishops
                  BitBoard.$fEqBishops_$c==
                  BitBoard.$fEqBishops_$c/= -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fEqBishops_$c/= ::
    BitBoard.Bishops -> BitBoard.Bishops -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$c/=
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0])
                 ->_R Sym (BitBoard.NTCo:Bishops[0])
                 ->_R <GHC.Types.Bool>_R) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fEqBishops_$c== ::
    BitBoard.Bishops -> BitBoard.Bishops -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEqWord64_$c==
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0])
                 ->_R Sym (BitBoard.NTCo:Bishops[0])
                 ->_R <GHC.Types.Bool>_R) -}
9ddff55270133108c79e28dd74ad22ce
  $fEqBlackPieces :: GHC.Classes.Eq BitBoard.BlackPieces
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.BlackPieces
                  BitBoard.$fEqBlackPieces_$c==
                  BitBoard.$fEqBlackPieces_$c/= -}
9ddff55270133108c79e28dd74ad22ce
  $fEqBlackPieces_$c/= ::
    BitBoard.BlackPieces -> BitBoard.BlackPieces -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$c/=
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R <GHC.Types.Bool>_R) -}
9ddff55270133108c79e28dd74ad22ce
  $fEqBlackPieces_$c== ::
    BitBoard.BlackPieces -> BitBoard.BlackPieces -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEqWord64_$c==
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R <GHC.Types.Bool>_R) -}
065b32ad76ea4a8b0402f332e197f31d
  $fEqKings :: GHC.Classes.Eq BitBoard.Kings
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Kings BitBoard.$fEqKings_$c== BitBoard.$fEqKings_$c/= -}
065b32ad76ea4a8b0402f332e197f31d
  $fEqKings_$c/= ::
    BitBoard.Kings -> BitBoard.Kings -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$c/=
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0])
                 ->_R Sym (BitBoard.NTCo:Kings[0])
                 ->_R <GHC.Types.Bool>_R) -}
065b32ad76ea4a8b0402f332e197f31d
  $fEqKings_$c== ::
    BitBoard.Kings -> BitBoard.Kings -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEqWord64_$c==
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0])
                 ->_R Sym (BitBoard.NTCo:Kings[0])
                 ->_R <GHC.Types.Bool>_R) -}
103282c86fd0df5e492207716e3fb109
  $fEqKnights :: GHC.Classes.Eq BitBoard.Knights
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Knights
                  BitBoard.$fEqKnights_$c==
                  BitBoard.$fEqKnights_$c/= -}
103282c86fd0df5e492207716e3fb109
  $fEqKnights_$c/= ::
    BitBoard.Knights -> BitBoard.Knights -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$c/=
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0])
                 ->_R Sym (BitBoard.NTCo:Knights[0])
                 ->_R <GHC.Types.Bool>_R) -}
103282c86fd0df5e492207716e3fb109
  $fEqKnights_$c== ::
    BitBoard.Knights -> BitBoard.Knights -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEqWord64_$c==
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0])
                 ->_R Sym (BitBoard.NTCo:Knights[0])
                 ->_R <GHC.Types.Bool>_R) -}
d43d5bd6477b515f51d59101d16394b6
  $fEqPawns :: GHC.Classes.Eq BitBoard.Pawns
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Pawns BitBoard.$fEqPawns_$c== BitBoard.$fEqPawns_$c/= -}
d43d5bd6477b515f51d59101d16394b6
  $fEqPawns_$c/= ::
    BitBoard.Pawns -> BitBoard.Pawns -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$c/=
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0])
                 ->_R Sym (BitBoard.NTCo:Pawns[0])
                 ->_R <GHC.Types.Bool>_R) -}
d43d5bd6477b515f51d59101d16394b6
  $fEqPawns_$c== ::
    BitBoard.Pawns -> BitBoard.Pawns -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEqWord64_$c==
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0])
                 ->_R Sym (BitBoard.NTCo:Pawns[0])
                 ->_R <GHC.Types.Bool>_R) -}
54dad9256b7d59d866b38b4bb67af31f
  $fEqQueens :: GHC.Classes.Eq BitBoard.Queens
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Queens
                  BitBoard.$fEqQueens_$c==
                  BitBoard.$fEqQueens_$c/= -}
54dad9256b7d59d866b38b4bb67af31f
  $fEqQueens_$c/= ::
    BitBoard.Queens -> BitBoard.Queens -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$c/=
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0])
                 ->_R Sym (BitBoard.NTCo:Queens[0])
                 ->_R <GHC.Types.Bool>_R) -}
54dad9256b7d59d866b38b4bb67af31f
  $fEqQueens_$c== ::
    BitBoard.Queens -> BitBoard.Queens -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEqWord64_$c==
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0])
                 ->_R Sym (BitBoard.NTCo:Queens[0])
                 ->_R <GHC.Types.Bool>_R) -}
830f089678e37950d6554715dce54b27
  $fEqRooks :: GHC.Classes.Eq BitBoard.Rooks
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Rooks BitBoard.$fEqRooks_$c== BitBoard.$fEqRooks_$c/= -}
830f089678e37950d6554715dce54b27
  $fEqRooks_$c/= ::
    BitBoard.Rooks -> BitBoard.Rooks -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$c/=
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0])
                 ->_R Sym (BitBoard.NTCo:Rooks[0])
                 ->_R <GHC.Types.Bool>_R) -}
830f089678e37950d6554715dce54b27
  $fEqRooks_$c== ::
    BitBoard.Rooks -> BitBoard.Rooks -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEqWord64_$c==
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0])
                 ->_R Sym (BitBoard.NTCo:Rooks[0])
                 ->_R <GHC.Types.Bool>_R) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fEqWhitePieces :: GHC.Classes.Eq BitBoard.WhitePieces
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.WhitePieces
                  BitBoard.$fEqWhitePieces_$c==
                  BitBoard.$fEqWhitePieces_$c/= -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fEqWhitePieces_$c/= ::
    BitBoard.WhitePieces -> BitBoard.WhitePieces -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fBitsWord64_$c/=
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R <GHC.Types.Bool>_R) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fEqWhitePieces_$c== ::
    BitBoard.WhitePieces -> BitBoard.WhitePieces -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fEqWord64_$c==
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R <GHC.Types.Bool>_R) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fFiniteBitsBishops :: Data.Bits.FiniteBits BitBoard.Bishops
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Bishops
                  BitBoard.$fBitsBishops
                  BitBoard.$fBitsBishops_$cfiniteBitSize
                  BitBoard.$fFiniteBitsBishops_$ccountLeadingZeros
                  BitBoard.$fFiniteBitsBishops_$ccountTrailingZeros -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fFiniteBitsBishops_$ccountLeadingZeros ::
    BitBoard.Bishops -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0]) ->_R <GHC.Types.Int>_R) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fFiniteBitsBishops_$ccountTrailingZeros ::
    BitBoard.Bishops -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0]) ->_R <GHC.Types.Int>_R) -}
9ddff55270133108c79e28dd74ad22ce
  $fFiniteBitsBlackPieces ::
    Data.Bits.FiniteBits BitBoard.BlackPieces
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.BlackPieces
                  BitBoard.$fBitsBlackPieces
                  BitBoard.$fBitsBlackPieces_$cfiniteBitSize
                  BitBoard.$fFiniteBitsBlackPieces_$ccountLeadingZeros
                  BitBoard.$fFiniteBitsBlackPieces_$ccountTrailingZeros -}
9ddff55270133108c79e28dd74ad22ce
  $fFiniteBitsBlackPieces_$ccountLeadingZeros ::
    BitBoard.BlackPieces -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0]) ->_R <GHC.Types.Int>_R) -}
9ddff55270133108c79e28dd74ad22ce
  $fFiniteBitsBlackPieces_$ccountTrailingZeros ::
    BitBoard.BlackPieces -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0]) ->_R <GHC.Types.Int>_R) -}
065b32ad76ea4a8b0402f332e197f31d
  $fFiniteBitsKings :: Data.Bits.FiniteBits BitBoard.Kings
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Kings
                  BitBoard.$fBitsKings
                  BitBoard.$fBitsKings_$cfiniteBitSize
                  BitBoard.$fFiniteBitsKings_$ccountLeadingZeros
                  BitBoard.$fFiniteBitsKings_$ccountTrailingZeros -}
065b32ad76ea4a8b0402f332e197f31d
  $fFiniteBitsKings_$ccountLeadingZeros ::
    BitBoard.Kings -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0]) ->_R <GHC.Types.Int>_R) -}
065b32ad76ea4a8b0402f332e197f31d
  $fFiniteBitsKings_$ccountTrailingZeros ::
    BitBoard.Kings -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0]) ->_R <GHC.Types.Int>_R) -}
103282c86fd0df5e492207716e3fb109
  $fFiniteBitsKnights :: Data.Bits.FiniteBits BitBoard.Knights
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Knights
                  BitBoard.$fBitsKnights
                  BitBoard.$fBitsKnights_$cfiniteBitSize
                  BitBoard.$fFiniteBitsKnights_$ccountLeadingZeros
                  BitBoard.$fFiniteBitsKnights_$ccountTrailingZeros -}
103282c86fd0df5e492207716e3fb109
  $fFiniteBitsKnights_$ccountLeadingZeros ::
    BitBoard.Knights -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0]) ->_R <GHC.Types.Int>_R) -}
103282c86fd0df5e492207716e3fb109
  $fFiniteBitsKnights_$ccountTrailingZeros ::
    BitBoard.Knights -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0]) ->_R <GHC.Types.Int>_R) -}
d43d5bd6477b515f51d59101d16394b6
  $fFiniteBitsPawns :: Data.Bits.FiniteBits BitBoard.Pawns
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Pawns
                  BitBoard.$fBitsPawns
                  BitBoard.$fBitsPawns_$cfiniteBitSize
                  BitBoard.$fFiniteBitsPawns_$ccountLeadingZeros
                  BitBoard.$fFiniteBitsPawns_$ccountTrailingZeros -}
d43d5bd6477b515f51d59101d16394b6
  $fFiniteBitsPawns_$ccountLeadingZeros ::
    BitBoard.Pawns -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0]) ->_R <GHC.Types.Int>_R) -}
d43d5bd6477b515f51d59101d16394b6
  $fFiniteBitsPawns_$ccountTrailingZeros ::
    BitBoard.Pawns -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0]) ->_R <GHC.Types.Int>_R) -}
54dad9256b7d59d866b38b4bb67af31f
  $fFiniteBitsQueens :: Data.Bits.FiniteBits BitBoard.Queens
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Queens
                  BitBoard.$fBitsQueens
                  BitBoard.$fBitsQueens_$cfiniteBitSize
                  BitBoard.$fFiniteBitsQueens_$ccountLeadingZeros
                  BitBoard.$fFiniteBitsQueens_$ccountTrailingZeros -}
54dad9256b7d59d866b38b4bb67af31f
  $fFiniteBitsQueens_$ccountLeadingZeros ::
    BitBoard.Queens -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0]) ->_R <GHC.Types.Int>_R) -}
54dad9256b7d59d866b38b4bb67af31f
  $fFiniteBitsQueens_$ccountTrailingZeros ::
    BitBoard.Queens -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0]) ->_R <GHC.Types.Int>_R) -}
830f089678e37950d6554715dce54b27
  $fFiniteBitsRooks :: Data.Bits.FiniteBits BitBoard.Rooks
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Rooks
                  BitBoard.$fBitsRooks
                  BitBoard.$fBitsRooks_$cfiniteBitSize
                  BitBoard.$fFiniteBitsRooks_$ccountLeadingZeros
                  BitBoard.$fFiniteBitsRooks_$ccountTrailingZeros -}
830f089678e37950d6554715dce54b27
  $fFiniteBitsRooks_$ccountLeadingZeros ::
    BitBoard.Rooks -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0]) ->_R <GHC.Types.Int>_R) -}
830f089678e37950d6554715dce54b27
  $fFiniteBitsRooks_$ccountTrailingZeros ::
    BitBoard.Rooks -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0]) ->_R <GHC.Types.Int>_R) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fFiniteBitsWhitePieces ::
    Data.Bits.FiniteBits BitBoard.WhitePieces
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.WhitePieces
                  BitBoard.$fBitsWhitePieces
                  BitBoard.$fBitsWhitePieces_$cfiniteBitSize
                  BitBoard.$fFiniteBitsWhitePieces_$ccountLeadingZeros
                  BitBoard.$fFiniteBitsWhitePieces_$ccountTrailingZeros -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fFiniteBitsWhitePieces_$ccountLeadingZeros ::
    BitBoard.WhitePieces -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0]) ->_R <GHC.Types.Int>_R) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fFiniteBitsWhitePieces_$ccountTrailingZeros ::
    BitBoard.WhitePieces -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0]) ->_R <GHC.Types.Int>_R) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fNumBishops :: GHC.Num.Num BitBoard.Bishops
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Bishops
                  BitBoard.$fNumBishops_$c+
                  BitBoard.$fNumBishops_$c-
                  BitBoard.$fNumBishops_$c*
                  BitBoard.$fNumBishops_$cnegate
                  BitBoard.$fNumBishops_$cabs
                  BitBoard.$fNumBishops_$csignum
                  BitBoard.$fNumBishops_$cfromInteger -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fNumBishops_$c* ::
    BitBoard.Bishops -> BitBoard.Bishops -> BitBoard.Bishops
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$c*
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0])
                 ->_R Sym (BitBoard.NTCo:Bishops[0])
                 ->_R Sym (BitBoard.NTCo:Bishops[0])) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fNumBishops_$c+ ::
    BitBoard.Bishops -> BitBoard.Bishops -> BitBoard.Bishops
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$c+
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0])
                 ->_R Sym (BitBoard.NTCo:Bishops[0])
                 ->_R Sym (BitBoard.NTCo:Bishops[0])) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fNumBishops_$c- ::
    BitBoard.Bishops -> BitBoard.Bishops -> BitBoard.Bishops
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$c-
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0])
                 ->_R Sym (BitBoard.NTCo:Bishops[0])
                 ->_R Sym (BitBoard.NTCo:Bishops[0])) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fNumBishops_$cabs :: BitBoard.Bishops -> BitBoard.Bishops
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$cabs
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0])
                 ->_R Sym (BitBoard.NTCo:Bishops[0])) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fNumBishops_$cfromInteger ::
    GHC.Integer.Type.Integer -> BitBoard.Bishops
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$cfromInteger3
                  `cast`
                (<GHC.Integer.Type.Integer>_R
                 ->_R Sym (BitBoard.NTCo:Bishops[0])) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fNumBishops_$cnegate :: BitBoard.Bishops -> BitBoard.Bishops
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$cnegate
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0])
                 ->_R Sym (BitBoard.NTCo:Bishops[0])) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fNumBishops_$csignum :: BitBoard.Bishops -> BitBoard.Bishops
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(1*U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$csignum
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0])
                 ->_R Sym (BitBoard.NTCo:Bishops[0])) -}
9ddff55270133108c79e28dd74ad22ce
  $fNumBlackPieces :: GHC.Num.Num BitBoard.BlackPieces
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.BlackPieces
                  BitBoard.$fNumBlackPieces_$c+
                  BitBoard.$fNumBlackPieces_$c-
                  BitBoard.$fNumBlackPieces_$c*
                  BitBoard.$fNumBlackPieces_$cnegate
                  BitBoard.$fNumBlackPieces_$cabs
                  BitBoard.$fNumBlackPieces_$csignum
                  BitBoard.$fNumBlackPieces_$cfromInteger -}
9ddff55270133108c79e28dd74ad22ce
  $fNumBlackPieces_$c* ::
    BitBoard.BlackPieces
    -> BitBoard.BlackPieces -> BitBoard.BlackPieces
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$c*
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])) -}
9ddff55270133108c79e28dd74ad22ce
  $fNumBlackPieces_$c+ ::
    BitBoard.BlackPieces
    -> BitBoard.BlackPieces -> BitBoard.BlackPieces
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$c+
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])) -}
9ddff55270133108c79e28dd74ad22ce
  $fNumBlackPieces_$c- ::
    BitBoard.BlackPieces
    -> BitBoard.BlackPieces -> BitBoard.BlackPieces
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$c-
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])) -}
9ddff55270133108c79e28dd74ad22ce
  $fNumBlackPieces_$cabs ::
    BitBoard.BlackPieces -> BitBoard.BlackPieces
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$cabs
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])) -}
9ddff55270133108c79e28dd74ad22ce
  $fNumBlackPieces_$cfromInteger ::
    GHC.Integer.Type.Integer -> BitBoard.BlackPieces
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$cfromInteger3
                  `cast`
                (<GHC.Integer.Type.Integer>_R
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])) -}
9ddff55270133108c79e28dd74ad22ce
  $fNumBlackPieces_$cnegate ::
    BitBoard.BlackPieces -> BitBoard.BlackPieces
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$cnegate
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])) -}
9ddff55270133108c79e28dd74ad22ce
  $fNumBlackPieces_$csignum ::
    BitBoard.BlackPieces -> BitBoard.BlackPieces
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(1*U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$csignum
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])) -}
065b32ad76ea4a8b0402f332e197f31d
  $fNumKings :: GHC.Num.Num BitBoard.Kings
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Kings
                  BitBoard.$fNumKings_$c+
                  BitBoard.$fNumKings_$c-
                  BitBoard.$fNumKings_$c*
                  BitBoard.$fNumKings_$cnegate
                  BitBoard.$fNumKings_$cabs
                  BitBoard.$fNumKings_$csignum
                  BitBoard.$fNumKings_$cfromInteger -}
065b32ad76ea4a8b0402f332e197f31d
  $fNumKings_$c* ::
    BitBoard.Kings -> BitBoard.Kings -> BitBoard.Kings
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$c*
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0])
                 ->_R Sym (BitBoard.NTCo:Kings[0])
                 ->_R Sym (BitBoard.NTCo:Kings[0])) -}
065b32ad76ea4a8b0402f332e197f31d
  $fNumKings_$c+ ::
    BitBoard.Kings -> BitBoard.Kings -> BitBoard.Kings
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$c+
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0])
                 ->_R Sym (BitBoard.NTCo:Kings[0])
                 ->_R Sym (BitBoard.NTCo:Kings[0])) -}
065b32ad76ea4a8b0402f332e197f31d
  $fNumKings_$c- ::
    BitBoard.Kings -> BitBoard.Kings -> BitBoard.Kings
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$c-
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0])
                 ->_R Sym (BitBoard.NTCo:Kings[0])
                 ->_R Sym (BitBoard.NTCo:Kings[0])) -}
065b32ad76ea4a8b0402f332e197f31d
  $fNumKings_$cabs :: BitBoard.Kings -> BitBoard.Kings
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$cabs
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0]) ->_R Sym (BitBoard.NTCo:Kings[0])) -}
065b32ad76ea4a8b0402f332e197f31d
  $fNumKings_$cfromInteger ::
    GHC.Integer.Type.Integer -> BitBoard.Kings
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$cfromInteger3
                  `cast`
                (<GHC.Integer.Type.Integer>_R ->_R Sym (BitBoard.NTCo:Kings[0])) -}
065b32ad76ea4a8b0402f332e197f31d
  $fNumKings_$cnegate :: BitBoard.Kings -> BitBoard.Kings
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$cnegate
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0]) ->_R Sym (BitBoard.NTCo:Kings[0])) -}
065b32ad76ea4a8b0402f332e197f31d
  $fNumKings_$csignum :: BitBoard.Kings -> BitBoard.Kings
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(1*U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$csignum
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0]) ->_R Sym (BitBoard.NTCo:Kings[0])) -}
103282c86fd0df5e492207716e3fb109
  $fNumKnights :: GHC.Num.Num BitBoard.Knights
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Knights
                  BitBoard.$fNumKnights_$c+
                  BitBoard.$fNumKnights_$c-
                  BitBoard.$fNumKnights_$c*
                  BitBoard.$fNumKnights_$cnegate
                  BitBoard.$fNumKnights_$cabs
                  BitBoard.$fNumKnights_$csignum
                  BitBoard.$fNumKnights_$cfromInteger -}
103282c86fd0df5e492207716e3fb109
  $fNumKnights_$c* ::
    BitBoard.Knights -> BitBoard.Knights -> BitBoard.Knights
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$c*
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0])
                 ->_R Sym (BitBoard.NTCo:Knights[0])
                 ->_R Sym (BitBoard.NTCo:Knights[0])) -}
103282c86fd0df5e492207716e3fb109
  $fNumKnights_$c+ ::
    BitBoard.Knights -> BitBoard.Knights -> BitBoard.Knights
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$c+
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0])
                 ->_R Sym (BitBoard.NTCo:Knights[0])
                 ->_R Sym (BitBoard.NTCo:Knights[0])) -}
103282c86fd0df5e492207716e3fb109
  $fNumKnights_$c- ::
    BitBoard.Knights -> BitBoard.Knights -> BitBoard.Knights
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$c-
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0])
                 ->_R Sym (BitBoard.NTCo:Knights[0])
                 ->_R Sym (BitBoard.NTCo:Knights[0])) -}
103282c86fd0df5e492207716e3fb109
  $fNumKnights_$cabs :: BitBoard.Knights -> BitBoard.Knights
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$cabs
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0])
                 ->_R Sym (BitBoard.NTCo:Knights[0])) -}
103282c86fd0df5e492207716e3fb109
  $fNumKnights_$cfromInteger ::
    GHC.Integer.Type.Integer -> BitBoard.Knights
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$cfromInteger3
                  `cast`
                (<GHC.Integer.Type.Integer>_R
                 ->_R Sym (BitBoard.NTCo:Knights[0])) -}
103282c86fd0df5e492207716e3fb109
  $fNumKnights_$cnegate :: BitBoard.Knights -> BitBoard.Knights
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$cnegate
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0])
                 ->_R Sym (BitBoard.NTCo:Knights[0])) -}
103282c86fd0df5e492207716e3fb109
  $fNumKnights_$csignum :: BitBoard.Knights -> BitBoard.Knights
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(1*U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$csignum
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0])
                 ->_R Sym (BitBoard.NTCo:Knights[0])) -}
d43d5bd6477b515f51d59101d16394b6
  $fNumPawns :: GHC.Num.Num BitBoard.Pawns
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Pawns
                  BitBoard.$fNumPawns_$c+
                  BitBoard.$fNumPawns_$c-
                  BitBoard.$fNumPawns_$c*
                  BitBoard.$fNumPawns_$cnegate
                  BitBoard.$fNumPawns_$cabs
                  BitBoard.$fNumPawns_$csignum
                  BitBoard.$fNumPawns_$cfromInteger -}
d43d5bd6477b515f51d59101d16394b6
  $fNumPawns_$c* ::
    BitBoard.Pawns -> BitBoard.Pawns -> BitBoard.Pawns
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$c*
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0])
                 ->_R Sym (BitBoard.NTCo:Pawns[0])
                 ->_R Sym (BitBoard.NTCo:Pawns[0])) -}
d43d5bd6477b515f51d59101d16394b6
  $fNumPawns_$c+ ::
    BitBoard.Pawns -> BitBoard.Pawns -> BitBoard.Pawns
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$c+
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0])
                 ->_R Sym (BitBoard.NTCo:Pawns[0])
                 ->_R Sym (BitBoard.NTCo:Pawns[0])) -}
d43d5bd6477b515f51d59101d16394b6
  $fNumPawns_$c- ::
    BitBoard.Pawns -> BitBoard.Pawns -> BitBoard.Pawns
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$c-
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0])
                 ->_R Sym (BitBoard.NTCo:Pawns[0])
                 ->_R Sym (BitBoard.NTCo:Pawns[0])) -}
d43d5bd6477b515f51d59101d16394b6
  $fNumPawns_$cabs :: BitBoard.Pawns -> BitBoard.Pawns
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$cabs
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0]) ->_R Sym (BitBoard.NTCo:Pawns[0])) -}
d43d5bd6477b515f51d59101d16394b6
  $fNumPawns_$cfromInteger ::
    GHC.Integer.Type.Integer -> BitBoard.Pawns
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$cfromInteger3
                  `cast`
                (<GHC.Integer.Type.Integer>_R ->_R Sym (BitBoard.NTCo:Pawns[0])) -}
d43d5bd6477b515f51d59101d16394b6
  $fNumPawns_$cnegate :: BitBoard.Pawns -> BitBoard.Pawns
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$cnegate
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0]) ->_R Sym (BitBoard.NTCo:Pawns[0])) -}
d43d5bd6477b515f51d59101d16394b6
  $fNumPawns_$csignum :: BitBoard.Pawns -> BitBoard.Pawns
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(1*U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$csignum
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0]) ->_R Sym (BitBoard.NTCo:Pawns[0])) -}
54dad9256b7d59d866b38b4bb67af31f
  $fNumQueens :: GHC.Num.Num BitBoard.Queens
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Queens
                  BitBoard.$fNumQueens_$c+
                  BitBoard.$fNumQueens_$c-
                  BitBoard.$fNumQueens_$c*
                  BitBoard.$fNumQueens_$cnegate
                  BitBoard.$fNumQueens_$cabs
                  BitBoard.$fNumQueens_$csignum
                  BitBoard.$fNumQueens_$cfromInteger -}
54dad9256b7d59d866b38b4bb67af31f
  $fNumQueens_$c* ::
    BitBoard.Queens -> BitBoard.Queens -> BitBoard.Queens
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$c*
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0])
                 ->_R Sym (BitBoard.NTCo:Queens[0])
                 ->_R Sym (BitBoard.NTCo:Queens[0])) -}
54dad9256b7d59d866b38b4bb67af31f
  $fNumQueens_$c+ ::
    BitBoard.Queens -> BitBoard.Queens -> BitBoard.Queens
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$c+
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0])
                 ->_R Sym (BitBoard.NTCo:Queens[0])
                 ->_R Sym (BitBoard.NTCo:Queens[0])) -}
54dad9256b7d59d866b38b4bb67af31f
  $fNumQueens_$c- ::
    BitBoard.Queens -> BitBoard.Queens -> BitBoard.Queens
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$c-
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0])
                 ->_R Sym (BitBoard.NTCo:Queens[0])
                 ->_R Sym (BitBoard.NTCo:Queens[0])) -}
54dad9256b7d59d866b38b4bb67af31f
  $fNumQueens_$cabs :: BitBoard.Queens -> BitBoard.Queens
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$cabs
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0])
                 ->_R Sym (BitBoard.NTCo:Queens[0])) -}
54dad9256b7d59d866b38b4bb67af31f
  $fNumQueens_$cfromInteger ::
    GHC.Integer.Type.Integer -> BitBoard.Queens
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$cfromInteger3
                  `cast`
                (<GHC.Integer.Type.Integer>_R
                 ->_R Sym (BitBoard.NTCo:Queens[0])) -}
54dad9256b7d59d866b38b4bb67af31f
  $fNumQueens_$cnegate :: BitBoard.Queens -> BitBoard.Queens
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$cnegate
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0])
                 ->_R Sym (BitBoard.NTCo:Queens[0])) -}
54dad9256b7d59d866b38b4bb67af31f
  $fNumQueens_$csignum :: BitBoard.Queens -> BitBoard.Queens
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(1*U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$csignum
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0])
                 ->_R Sym (BitBoard.NTCo:Queens[0])) -}
830f089678e37950d6554715dce54b27
  $fNumRooks :: GHC.Num.Num BitBoard.Rooks
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Rooks
                  BitBoard.$fNumRooks_$c+
                  BitBoard.$fNumRooks_$c-
                  BitBoard.$fNumRooks_$c*
                  BitBoard.$fNumRooks_$cnegate
                  BitBoard.$fNumRooks_$cabs
                  BitBoard.$fNumRooks_$csignum
                  BitBoard.$fNumRooks_$cfromInteger -}
830f089678e37950d6554715dce54b27
  $fNumRooks_$c* ::
    BitBoard.Rooks -> BitBoard.Rooks -> BitBoard.Rooks
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$c*
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0])
                 ->_R Sym (BitBoard.NTCo:Rooks[0])
                 ->_R Sym (BitBoard.NTCo:Rooks[0])) -}
830f089678e37950d6554715dce54b27
  $fNumRooks_$c+ ::
    BitBoard.Rooks -> BitBoard.Rooks -> BitBoard.Rooks
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$c+
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0])
                 ->_R Sym (BitBoard.NTCo:Rooks[0])
                 ->_R Sym (BitBoard.NTCo:Rooks[0])) -}
830f089678e37950d6554715dce54b27
  $fNumRooks_$c- ::
    BitBoard.Rooks -> BitBoard.Rooks -> BitBoard.Rooks
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$c-
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0])
                 ->_R Sym (BitBoard.NTCo:Rooks[0])
                 ->_R Sym (BitBoard.NTCo:Rooks[0])) -}
830f089678e37950d6554715dce54b27
  $fNumRooks_$cabs :: BitBoard.Rooks -> BitBoard.Rooks
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$cabs
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0]) ->_R Sym (BitBoard.NTCo:Rooks[0])) -}
830f089678e37950d6554715dce54b27
  $fNumRooks_$cfromInteger ::
    GHC.Integer.Type.Integer -> BitBoard.Rooks
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$cfromInteger3
                  `cast`
                (<GHC.Integer.Type.Integer>_R ->_R Sym (BitBoard.NTCo:Rooks[0])) -}
830f089678e37950d6554715dce54b27
  $fNumRooks_$cnegate :: BitBoard.Rooks -> BitBoard.Rooks
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$cnegate
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0]) ->_R Sym (BitBoard.NTCo:Rooks[0])) -}
830f089678e37950d6554715dce54b27
  $fNumRooks_$csignum :: BitBoard.Rooks -> BitBoard.Rooks
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(1*U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$csignum
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0]) ->_R Sym (BitBoard.NTCo:Rooks[0])) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fNumWhitePieces :: GHC.Num.Num BitBoard.WhitePieces
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.WhitePieces
                  BitBoard.$fNumWhitePieces_$c+
                  BitBoard.$fNumWhitePieces_$c-
                  BitBoard.$fNumWhitePieces_$c*
                  BitBoard.$fNumWhitePieces_$cnegate
                  BitBoard.$fNumWhitePieces_$cabs
                  BitBoard.$fNumWhitePieces_$csignum
                  BitBoard.$fNumWhitePieces_$cfromInteger -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fNumWhitePieces_$c* ::
    BitBoard.WhitePieces
    -> BitBoard.WhitePieces -> BitBoard.WhitePieces
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$c*
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fNumWhitePieces_$c+ ::
    BitBoard.WhitePieces
    -> BitBoard.WhitePieces -> BitBoard.WhitePieces
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$c+
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fNumWhitePieces_$c- ::
    BitBoard.WhitePieces
    -> BitBoard.WhitePieces -> BitBoard.WhitePieces
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$c-
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fNumWhitePieces_$cabs ::
    BitBoard.WhitePieces -> BitBoard.WhitePieces
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$cabs
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fNumWhitePieces_$cfromInteger ::
    GHC.Integer.Type.Integer -> BitBoard.WhitePieces
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$cfromInteger3
                  `cast`
                (<GHC.Integer.Type.Integer>_R
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fNumWhitePieces_$cnegate ::
    BitBoard.WhitePieces -> BitBoard.WhitePieces
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$cnegate
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fNumWhitePieces_$csignum ::
    BitBoard.WhitePieces -> BitBoard.WhitePieces
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(1*U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fNumWord64_$csignum
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fOrdBishops :: GHC.Classes.Ord BitBoard.Bishops
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Bishops
                  BitBoard.$fEqBishops
                  BitBoard.$fOrdBishops_$ccompare
                  BitBoard.$fOrdBishops_$c<
                  BitBoard.$fOrdBishops_$c<=
                  BitBoard.$fOrdBishops_$c>
                  BitBoard.$fOrdBishops_$c>=
                  BitBoard.$fOrdBishops_$cmax
                  BitBoard.$fOrdBishops_$cmin -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fOrdBishops_$c< ::
    BitBoard.Bishops -> BitBoard.Bishops -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$c<
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0])
                 ->_R Sym (BitBoard.NTCo:Bishops[0])
                 ->_R <GHC.Types.Bool>_R) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fOrdBishops_$c<= ::
    BitBoard.Bishops -> BitBoard.Bishops -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$c<=
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0])
                 ->_R Sym (BitBoard.NTCo:Bishops[0])
                 ->_R <GHC.Types.Bool>_R) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fOrdBishops_$c> ::
    BitBoard.Bishops -> BitBoard.Bishops -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$c>
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0])
                 ->_R Sym (BitBoard.NTCo:Bishops[0])
                 ->_R <GHC.Types.Bool>_R) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fOrdBishops_$c>= ::
    BitBoard.Bishops -> BitBoard.Bishops -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$c>=
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0])
                 ->_R Sym (BitBoard.NTCo:Bishops[0])
                 ->_R <GHC.Types.Bool>_R) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fOrdBishops_$ccompare ::
    BitBoard.Bishops -> BitBoard.Bishops -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$ccompare
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0])
                 ->_R Sym (BitBoard.NTCo:Bishops[0])
                 ->_R <GHC.Types.Ordering>_R) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fOrdBishops_$cmax ::
    BitBoard.Bishops -> BitBoard.Bishops -> BitBoard.Bishops
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$cmax
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0])
                 ->_R Sym (BitBoard.NTCo:Bishops[0])
                 ->_R Sym (BitBoard.NTCo:Bishops[0])) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fOrdBishops_$cmin ::
    BitBoard.Bishops -> BitBoard.Bishops -> BitBoard.Bishops
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$cmin
                  `cast`
                (Sym (BitBoard.NTCo:Bishops[0])
                 ->_R Sym (BitBoard.NTCo:Bishops[0])
                 ->_R Sym (BitBoard.NTCo:Bishops[0])) -}
9ddff55270133108c79e28dd74ad22ce
  $fOrdBlackPieces :: GHC.Classes.Ord BitBoard.BlackPieces
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.BlackPieces
                  BitBoard.$fEqBlackPieces
                  BitBoard.$fOrdBlackPieces_$ccompare
                  BitBoard.$fOrdBlackPieces_$c<
                  BitBoard.$fOrdBlackPieces_$c<=
                  BitBoard.$fOrdBlackPieces_$c>
                  BitBoard.$fOrdBlackPieces_$c>=
                  BitBoard.$fOrdBlackPieces_$cmax
                  BitBoard.$fOrdBlackPieces_$cmin -}
9ddff55270133108c79e28dd74ad22ce
  $fOrdBlackPieces_$c< ::
    BitBoard.BlackPieces -> BitBoard.BlackPieces -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$c<
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R <GHC.Types.Bool>_R) -}
9ddff55270133108c79e28dd74ad22ce
  $fOrdBlackPieces_$c<= ::
    BitBoard.BlackPieces -> BitBoard.BlackPieces -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$c<=
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R <GHC.Types.Bool>_R) -}
9ddff55270133108c79e28dd74ad22ce
  $fOrdBlackPieces_$c> ::
    BitBoard.BlackPieces -> BitBoard.BlackPieces -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$c>
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R <GHC.Types.Bool>_R) -}
9ddff55270133108c79e28dd74ad22ce
  $fOrdBlackPieces_$c>= ::
    BitBoard.BlackPieces -> BitBoard.BlackPieces -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$c>=
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R <GHC.Types.Bool>_R) -}
9ddff55270133108c79e28dd74ad22ce
  $fOrdBlackPieces_$ccompare ::
    BitBoard.BlackPieces -> BitBoard.BlackPieces -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$ccompare
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R <GHC.Types.Ordering>_R) -}
9ddff55270133108c79e28dd74ad22ce
  $fOrdBlackPieces_$cmax ::
    BitBoard.BlackPieces
    -> BitBoard.BlackPieces -> BitBoard.BlackPieces
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$cmax
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])) -}
9ddff55270133108c79e28dd74ad22ce
  $fOrdBlackPieces_$cmin ::
    BitBoard.BlackPieces
    -> BitBoard.BlackPieces -> BitBoard.BlackPieces
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$cmin
                  `cast`
                (Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])
                 ->_R Sym (BitBoard.NTCo:BlackPieces[0])) -}
065b32ad76ea4a8b0402f332e197f31d
  $fOrdKings :: GHC.Classes.Ord BitBoard.Kings
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Kings
                  BitBoard.$fEqKings
                  BitBoard.$fOrdKings_$ccompare
                  BitBoard.$fOrdKings_$c<
                  BitBoard.$fOrdKings_$c<=
                  BitBoard.$fOrdKings_$c>
                  BitBoard.$fOrdKings_$c>=
                  BitBoard.$fOrdKings_$cmax
                  BitBoard.$fOrdKings_$cmin -}
065b32ad76ea4a8b0402f332e197f31d
  $fOrdKings_$c< ::
    BitBoard.Kings -> BitBoard.Kings -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$c<
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0])
                 ->_R Sym (BitBoard.NTCo:Kings[0])
                 ->_R <GHC.Types.Bool>_R) -}
065b32ad76ea4a8b0402f332e197f31d
  $fOrdKings_$c<= ::
    BitBoard.Kings -> BitBoard.Kings -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$c<=
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0])
                 ->_R Sym (BitBoard.NTCo:Kings[0])
                 ->_R <GHC.Types.Bool>_R) -}
065b32ad76ea4a8b0402f332e197f31d
  $fOrdKings_$c> ::
    BitBoard.Kings -> BitBoard.Kings -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$c>
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0])
                 ->_R Sym (BitBoard.NTCo:Kings[0])
                 ->_R <GHC.Types.Bool>_R) -}
065b32ad76ea4a8b0402f332e197f31d
  $fOrdKings_$c>= ::
    BitBoard.Kings -> BitBoard.Kings -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$c>=
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0])
                 ->_R Sym (BitBoard.NTCo:Kings[0])
                 ->_R <GHC.Types.Bool>_R) -}
065b32ad76ea4a8b0402f332e197f31d
  $fOrdKings_$ccompare ::
    BitBoard.Kings -> BitBoard.Kings -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$ccompare
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0])
                 ->_R Sym (BitBoard.NTCo:Kings[0])
                 ->_R <GHC.Types.Ordering>_R) -}
065b32ad76ea4a8b0402f332e197f31d
  $fOrdKings_$cmax ::
    BitBoard.Kings -> BitBoard.Kings -> BitBoard.Kings
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$cmax
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0])
                 ->_R Sym (BitBoard.NTCo:Kings[0])
                 ->_R Sym (BitBoard.NTCo:Kings[0])) -}
065b32ad76ea4a8b0402f332e197f31d
  $fOrdKings_$cmin ::
    BitBoard.Kings -> BitBoard.Kings -> BitBoard.Kings
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$cmin
                  `cast`
                (Sym (BitBoard.NTCo:Kings[0])
                 ->_R Sym (BitBoard.NTCo:Kings[0])
                 ->_R Sym (BitBoard.NTCo:Kings[0])) -}
103282c86fd0df5e492207716e3fb109
  $fOrdKnights :: GHC.Classes.Ord BitBoard.Knights
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Knights
                  BitBoard.$fEqKnights
                  BitBoard.$fOrdKnights_$ccompare
                  BitBoard.$fOrdKnights_$c<
                  BitBoard.$fOrdKnights_$c<=
                  BitBoard.$fOrdKnights_$c>
                  BitBoard.$fOrdKnights_$c>=
                  BitBoard.$fOrdKnights_$cmax
                  BitBoard.$fOrdKnights_$cmin -}
103282c86fd0df5e492207716e3fb109
  $fOrdKnights_$c< ::
    BitBoard.Knights -> BitBoard.Knights -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$c<
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0])
                 ->_R Sym (BitBoard.NTCo:Knights[0])
                 ->_R <GHC.Types.Bool>_R) -}
103282c86fd0df5e492207716e3fb109
  $fOrdKnights_$c<= ::
    BitBoard.Knights -> BitBoard.Knights -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$c<=
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0])
                 ->_R Sym (BitBoard.NTCo:Knights[0])
                 ->_R <GHC.Types.Bool>_R) -}
103282c86fd0df5e492207716e3fb109
  $fOrdKnights_$c> ::
    BitBoard.Knights -> BitBoard.Knights -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$c>
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0])
                 ->_R Sym (BitBoard.NTCo:Knights[0])
                 ->_R <GHC.Types.Bool>_R) -}
103282c86fd0df5e492207716e3fb109
  $fOrdKnights_$c>= ::
    BitBoard.Knights -> BitBoard.Knights -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$c>=
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0])
                 ->_R Sym (BitBoard.NTCo:Knights[0])
                 ->_R <GHC.Types.Bool>_R) -}
103282c86fd0df5e492207716e3fb109
  $fOrdKnights_$ccompare ::
    BitBoard.Knights -> BitBoard.Knights -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$ccompare
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0])
                 ->_R Sym (BitBoard.NTCo:Knights[0])
                 ->_R <GHC.Types.Ordering>_R) -}
103282c86fd0df5e492207716e3fb109
  $fOrdKnights_$cmax ::
    BitBoard.Knights -> BitBoard.Knights -> BitBoard.Knights
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$cmax
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0])
                 ->_R Sym (BitBoard.NTCo:Knights[0])
                 ->_R Sym (BitBoard.NTCo:Knights[0])) -}
103282c86fd0df5e492207716e3fb109
  $fOrdKnights_$cmin ::
    BitBoard.Knights -> BitBoard.Knights -> BitBoard.Knights
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$cmin
                  `cast`
                (Sym (BitBoard.NTCo:Knights[0])
                 ->_R Sym (BitBoard.NTCo:Knights[0])
                 ->_R Sym (BitBoard.NTCo:Knights[0])) -}
d43d5bd6477b515f51d59101d16394b6
  $fOrdPawns :: GHC.Classes.Ord BitBoard.Pawns
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Pawns
                  BitBoard.$fEqPawns
                  BitBoard.$fOrdPawns_$ccompare
                  BitBoard.$fOrdPawns_$c<
                  BitBoard.$fOrdPawns_$c<=
                  BitBoard.$fOrdPawns_$c>
                  BitBoard.$fOrdPawns_$c>=
                  BitBoard.$fOrdPawns_$cmax
                  BitBoard.$fOrdPawns_$cmin -}
d43d5bd6477b515f51d59101d16394b6
  $fOrdPawns_$c< ::
    BitBoard.Pawns -> BitBoard.Pawns -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$c<
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0])
                 ->_R Sym (BitBoard.NTCo:Pawns[0])
                 ->_R <GHC.Types.Bool>_R) -}
d43d5bd6477b515f51d59101d16394b6
  $fOrdPawns_$c<= ::
    BitBoard.Pawns -> BitBoard.Pawns -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$c<=
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0])
                 ->_R Sym (BitBoard.NTCo:Pawns[0])
                 ->_R <GHC.Types.Bool>_R) -}
d43d5bd6477b515f51d59101d16394b6
  $fOrdPawns_$c> ::
    BitBoard.Pawns -> BitBoard.Pawns -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$c>
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0])
                 ->_R Sym (BitBoard.NTCo:Pawns[0])
                 ->_R <GHC.Types.Bool>_R) -}
d43d5bd6477b515f51d59101d16394b6
  $fOrdPawns_$c>= ::
    BitBoard.Pawns -> BitBoard.Pawns -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$c>=
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0])
                 ->_R Sym (BitBoard.NTCo:Pawns[0])
                 ->_R <GHC.Types.Bool>_R) -}
d43d5bd6477b515f51d59101d16394b6
  $fOrdPawns_$ccompare ::
    BitBoard.Pawns -> BitBoard.Pawns -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$ccompare
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0])
                 ->_R Sym (BitBoard.NTCo:Pawns[0])
                 ->_R <GHC.Types.Ordering>_R) -}
d43d5bd6477b515f51d59101d16394b6
  $fOrdPawns_$cmax ::
    BitBoard.Pawns -> BitBoard.Pawns -> BitBoard.Pawns
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$cmax
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0])
                 ->_R Sym (BitBoard.NTCo:Pawns[0])
                 ->_R Sym (BitBoard.NTCo:Pawns[0])) -}
d43d5bd6477b515f51d59101d16394b6
  $fOrdPawns_$cmin ::
    BitBoard.Pawns -> BitBoard.Pawns -> BitBoard.Pawns
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$cmin
                  `cast`
                (Sym (BitBoard.NTCo:Pawns[0])
                 ->_R Sym (BitBoard.NTCo:Pawns[0])
                 ->_R Sym (BitBoard.NTCo:Pawns[0])) -}
54dad9256b7d59d866b38b4bb67af31f
  $fOrdQueens :: GHC.Classes.Ord BitBoard.Queens
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Queens
                  BitBoard.$fEqQueens
                  BitBoard.$fOrdQueens_$ccompare
                  BitBoard.$fOrdQueens_$c<
                  BitBoard.$fOrdQueens_$c<=
                  BitBoard.$fOrdQueens_$c>
                  BitBoard.$fOrdQueens_$c>=
                  BitBoard.$fOrdQueens_$cmax
                  BitBoard.$fOrdQueens_$cmin -}
54dad9256b7d59d866b38b4bb67af31f
  $fOrdQueens_$c< ::
    BitBoard.Queens -> BitBoard.Queens -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$c<
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0])
                 ->_R Sym (BitBoard.NTCo:Queens[0])
                 ->_R <GHC.Types.Bool>_R) -}
54dad9256b7d59d866b38b4bb67af31f
  $fOrdQueens_$c<= ::
    BitBoard.Queens -> BitBoard.Queens -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$c<=
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0])
                 ->_R Sym (BitBoard.NTCo:Queens[0])
                 ->_R <GHC.Types.Bool>_R) -}
54dad9256b7d59d866b38b4bb67af31f
  $fOrdQueens_$c> ::
    BitBoard.Queens -> BitBoard.Queens -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$c>
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0])
                 ->_R Sym (BitBoard.NTCo:Queens[0])
                 ->_R <GHC.Types.Bool>_R) -}
54dad9256b7d59d866b38b4bb67af31f
  $fOrdQueens_$c>= ::
    BitBoard.Queens -> BitBoard.Queens -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$c>=
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0])
                 ->_R Sym (BitBoard.NTCo:Queens[0])
                 ->_R <GHC.Types.Bool>_R) -}
54dad9256b7d59d866b38b4bb67af31f
  $fOrdQueens_$ccompare ::
    BitBoard.Queens -> BitBoard.Queens -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$ccompare
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0])
                 ->_R Sym (BitBoard.NTCo:Queens[0])
                 ->_R <GHC.Types.Ordering>_R) -}
54dad9256b7d59d866b38b4bb67af31f
  $fOrdQueens_$cmax ::
    BitBoard.Queens -> BitBoard.Queens -> BitBoard.Queens
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$cmax
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0])
                 ->_R Sym (BitBoard.NTCo:Queens[0])
                 ->_R Sym (BitBoard.NTCo:Queens[0])) -}
54dad9256b7d59d866b38b4bb67af31f
  $fOrdQueens_$cmin ::
    BitBoard.Queens -> BitBoard.Queens -> BitBoard.Queens
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$cmin
                  `cast`
                (Sym (BitBoard.NTCo:Queens[0])
                 ->_R Sym (BitBoard.NTCo:Queens[0])
                 ->_R Sym (BitBoard.NTCo:Queens[0])) -}
830f089678e37950d6554715dce54b27
  $fOrdRooks :: GHC.Classes.Ord BitBoard.Rooks
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Rooks
                  BitBoard.$fEqRooks
                  BitBoard.$fOrdRooks_$ccompare
                  BitBoard.$fOrdRooks_$c<
                  BitBoard.$fOrdRooks_$c<=
                  BitBoard.$fOrdRooks_$c>
                  BitBoard.$fOrdRooks_$c>=
                  BitBoard.$fOrdRooks_$cmax
                  BitBoard.$fOrdRooks_$cmin -}
830f089678e37950d6554715dce54b27
  $fOrdRooks_$c< ::
    BitBoard.Rooks -> BitBoard.Rooks -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$c<
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0])
                 ->_R Sym (BitBoard.NTCo:Rooks[0])
                 ->_R <GHC.Types.Bool>_R) -}
830f089678e37950d6554715dce54b27
  $fOrdRooks_$c<= ::
    BitBoard.Rooks -> BitBoard.Rooks -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$c<=
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0])
                 ->_R Sym (BitBoard.NTCo:Rooks[0])
                 ->_R <GHC.Types.Bool>_R) -}
830f089678e37950d6554715dce54b27
  $fOrdRooks_$c> ::
    BitBoard.Rooks -> BitBoard.Rooks -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$c>
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0])
                 ->_R Sym (BitBoard.NTCo:Rooks[0])
                 ->_R <GHC.Types.Bool>_R) -}
830f089678e37950d6554715dce54b27
  $fOrdRooks_$c>= ::
    BitBoard.Rooks -> BitBoard.Rooks -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$c>=
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0])
                 ->_R Sym (BitBoard.NTCo:Rooks[0])
                 ->_R <GHC.Types.Bool>_R) -}
830f089678e37950d6554715dce54b27
  $fOrdRooks_$ccompare ::
    BitBoard.Rooks -> BitBoard.Rooks -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$ccompare
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0])
                 ->_R Sym (BitBoard.NTCo:Rooks[0])
                 ->_R <GHC.Types.Ordering>_R) -}
830f089678e37950d6554715dce54b27
  $fOrdRooks_$cmax ::
    BitBoard.Rooks -> BitBoard.Rooks -> BitBoard.Rooks
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$cmax
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0])
                 ->_R Sym (BitBoard.NTCo:Rooks[0])
                 ->_R Sym (BitBoard.NTCo:Rooks[0])) -}
830f089678e37950d6554715dce54b27
  $fOrdRooks_$cmin ::
    BitBoard.Rooks -> BitBoard.Rooks -> BitBoard.Rooks
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$cmin
                  `cast`
                (Sym (BitBoard.NTCo:Rooks[0])
                 ->_R Sym (BitBoard.NTCo:Rooks[0])
                 ->_R Sym (BitBoard.NTCo:Rooks[0])) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fOrdWhitePieces :: GHC.Classes.Ord BitBoard.WhitePieces
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.WhitePieces
                  BitBoard.$fEqWhitePieces
                  BitBoard.$fOrdWhitePieces_$ccompare
                  BitBoard.$fOrdWhitePieces_$c<
                  BitBoard.$fOrdWhitePieces_$c<=
                  BitBoard.$fOrdWhitePieces_$c>
                  BitBoard.$fOrdWhitePieces_$c>=
                  BitBoard.$fOrdWhitePieces_$cmax
                  BitBoard.$fOrdWhitePieces_$cmin -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fOrdWhitePieces_$c< ::
    BitBoard.WhitePieces -> BitBoard.WhitePieces -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$c<
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R <GHC.Types.Bool>_R) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fOrdWhitePieces_$c<= ::
    BitBoard.WhitePieces -> BitBoard.WhitePieces -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$c<=
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R <GHC.Types.Bool>_R) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fOrdWhitePieces_$c> ::
    BitBoard.WhitePieces -> BitBoard.WhitePieces -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$c>
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R <GHC.Types.Bool>_R) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fOrdWhitePieces_$c>= ::
    BitBoard.WhitePieces -> BitBoard.WhitePieces -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$c>=
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R <GHC.Types.Bool>_R) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fOrdWhitePieces_$ccompare ::
    BitBoard.WhitePieces -> BitBoard.WhitePieces -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$ccompare
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R <GHC.Types.Ordering>_R) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fOrdWhitePieces_$cmax ::
    BitBoard.WhitePieces
    -> BitBoard.WhitePieces -> BitBoard.WhitePieces
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$cmax
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fOrdWhitePieces_$cmin ::
    BitBoard.WhitePieces
    -> BitBoard.WhitePieces -> BitBoard.WhitePieces
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                GHC.Word.$fOrdWord64_$cmin
                  `cast`
                (Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])
                 ->_R Sym (BitBoard.NTCo:WhitePieces[0])) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fShowBishops :: GHC.Show.Show BitBoard.Bishops
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Bishops
                  BitBoard.$fShowBishops_$cshowsPrec
                  BitBoard.$fShowBishops_$cshow
                  BitBoard.$fShowBishops_$cshowList -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fShowBishops1 :: BitBoard.Bishops -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ w :: BitBoard.Bishops ->
                 BitBoard.$w$cshowsPrec 0 w) -}
df9125fcb9f1b6520261aaf91be2b972
  $fShowBishops2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "}"#) -}
72a782be43662ea6998bda9b5a39c857
  $fShowBishops3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "unB = "#) -}
da1406541ff71eae2cf7ea76f930b3fb
  $fShowBishops4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "B {"#) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fShowBishops_$cshow :: BitBoard.Bishops -> GHC.Base.String
  {- Arity: 1, Strictness: <L,1*U(U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: BitBoard.Bishops ->
                 BitBoard.$fShowBishops_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fShowBishops_$cshowList :: [BitBoard.Bishops] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ BitBoard.Bishops
                   BitBoard.$fShowBishops1) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $fShowBishops_$cshowsPrec ::
    GHC.Types.Int -> BitBoard.Bishops -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(U)><L,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: BitBoard.Bishops ->
                 case w of ww { GHC.Types.I# ww1 ->
                 BitBoard.$w$cshowsPrec ww1 w1 }) -}
88003702250f810b8816a2e041c0453f
  $fShowBitBoard :: GHC.Show.Show BitBoard.BitBoard
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.BitBoard
                  BitBoard.$fShowBitBoard_$cshowsPrec
                  BitBoard.showBitBoard
                  BitBoard.$fShowBitBoard_$cshowList -}
88003702250f810b8816a2e041c0453f
  $fShowBitBoard_$cshowList :: [BitBoard.BitBoard] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ ls :: [BitBoard.BitBoard] s :: GHC.Base.String ->
                 GHC.Show.showList__
                   @ BitBoard.BitBoard
                   (\ b :: BitBoard.BitBoard ->
                    GHC.Base.++ @ GHC.Types.Char (BitBoard.showBitBoard b))
                   ls
                   s) -}
88003702250f810b8816a2e041c0453f
  $fShowBitBoard_$cshowsPrec ::
    GHC.Types.Int -> BitBoard.BitBoard -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,A><L,1*U(U,U,U,U,U,U,U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: GHC.Types.Int b :: BitBoard.BitBoard ->
                 GHC.Base.++ @ GHC.Types.Char (BitBoard.showBitBoard b)) -}
9ddff55270133108c79e28dd74ad22ce
  $fShowBlackPieces :: GHC.Show.Show BitBoard.BlackPieces
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.BlackPieces
                  BitBoard.$fShowBlackPieces_$cshowsPrec
                  BitBoard.$fShowBlackPieces_$cshow
                  BitBoard.$fShowBlackPieces_$cshowList -}
9ddff55270133108c79e28dd74ad22ce
  $fShowBlackPieces1 :: BitBoard.BlackPieces -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ w :: BitBoard.BlackPieces ->
                 BitBoard.$w$cshowsPrec1 0 w) -}
5b3cbbab0b7eb89136ac34671ec77289
  $fShowBlackPieces2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "unBC = "#) -}
5bd9a3de1bf30273e11517e8ecc2237a
  $fShowBlackPieces3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "BC {"#) -}
9ddff55270133108c79e28dd74ad22ce
  $fShowBlackPieces_$cshow :: BitBoard.BlackPieces -> GHC.Base.String
  {- Arity: 1, Strictness: <L,1*U(U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: BitBoard.BlackPieces ->
                 BitBoard.$fShowBlackPieces_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
9ddff55270133108c79e28dd74ad22ce
  $fShowBlackPieces_$cshowList ::
    [BitBoard.BlackPieces] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ BitBoard.BlackPieces
                   BitBoard.$fShowBlackPieces1) -}
9ddff55270133108c79e28dd74ad22ce
  $fShowBlackPieces_$cshowsPrec ::
    GHC.Types.Int -> BitBoard.BlackPieces -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(U)><L,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: BitBoard.BlackPieces ->
                 case w of ww { GHC.Types.I# ww1 ->
                 BitBoard.$w$cshowsPrec1 ww1 w1 }) -}
065b32ad76ea4a8b0402f332e197f31d
  $fShowKings :: GHC.Show.Show BitBoard.Kings
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Kings
                  BitBoard.$fShowKings_$cshowsPrec
                  BitBoard.$fShowKings_$cshow
                  BitBoard.$fShowKings_$cshowList -}
065b32ad76ea4a8b0402f332e197f31d
  $fShowKings1 :: BitBoard.Kings -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ w :: BitBoard.Kings ->
                 BitBoard.$w$cshowsPrec2 0 w) -}
00fcd99ff807c691fb6785b7e982f75b
  $fShowKings2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "unK = "#) -}
d06dd369c0350890902adb5fb35a2758
  $fShowKings3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "K {"#) -}
065b32ad76ea4a8b0402f332e197f31d
  $fShowKings_$cshow :: BitBoard.Kings -> GHC.Base.String
  {- Arity: 1, Strictness: <L,1*U(U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: BitBoard.Kings ->
                 BitBoard.$fShowKings_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
065b32ad76ea4a8b0402f332e197f31d
  $fShowKings_$cshowList :: [BitBoard.Kings] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ BitBoard.Kings
                   BitBoard.$fShowKings1) -}
065b32ad76ea4a8b0402f332e197f31d
  $fShowKings_$cshowsPrec ::
    GHC.Types.Int -> BitBoard.Kings -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(U)><L,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: BitBoard.Kings ->
                 case w of ww { GHC.Types.I# ww1 ->
                 BitBoard.$w$cshowsPrec2 ww1 w1 }) -}
103282c86fd0df5e492207716e3fb109
  $fShowKnights :: GHC.Show.Show BitBoard.Knights
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Knights
                  BitBoard.$fShowKnights_$cshowsPrec
                  BitBoard.$fShowKnights_$cshow
                  BitBoard.$fShowKnights_$cshowList -}
103282c86fd0df5e492207716e3fb109
  $fShowKnights1 :: BitBoard.Knights -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ w :: BitBoard.Knights ->
                 BitBoard.$w$cshowsPrec3 0 w) -}
5f1fa580bb4cdc4de523840314c8bebc
  $fShowKnights2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "unN = "#) -}
9e2a2012814dd20b4f26f85bc1996bc4
  $fShowKnights3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "N {"#) -}
103282c86fd0df5e492207716e3fb109
  $fShowKnights_$cshow :: BitBoard.Knights -> GHC.Base.String
  {- Arity: 1, Strictness: <L,1*U(U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: BitBoard.Knights ->
                 BitBoard.$fShowKnights_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
103282c86fd0df5e492207716e3fb109
  $fShowKnights_$cshowList :: [BitBoard.Knights] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ BitBoard.Knights
                   BitBoard.$fShowKnights1) -}
103282c86fd0df5e492207716e3fb109
  $fShowKnights_$cshowsPrec ::
    GHC.Types.Int -> BitBoard.Knights -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(U)><L,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: BitBoard.Knights ->
                 case w of ww { GHC.Types.I# ww1 ->
                 BitBoard.$w$cshowsPrec3 ww1 w1 }) -}
d43d5bd6477b515f51d59101d16394b6
  $fShowPawns :: GHC.Show.Show BitBoard.Pawns
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Pawns
                  BitBoard.$fShowPawns_$cshowsPrec
                  BitBoard.$fShowPawns_$cshow
                  BitBoard.$fShowPawns_$cshowList -}
d43d5bd6477b515f51d59101d16394b6
  $fShowPawns1 :: BitBoard.Pawns -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ w :: BitBoard.Pawns ->
                 BitBoard.$w$cshowsPrec4 0 w) -}
da9c805158de1546899acbcc51d7a0dc
  $fShowPawns2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "unP = "#) -}
7af99c615f77b29efef360e698d93362
  $fShowPawns3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "P {"#) -}
d43d5bd6477b515f51d59101d16394b6
  $fShowPawns_$cshow :: BitBoard.Pawns -> GHC.Base.String
  {- Arity: 1, Strictness: <L,1*U(U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: BitBoard.Pawns ->
                 BitBoard.$fShowPawns_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
d43d5bd6477b515f51d59101d16394b6
  $fShowPawns_$cshowList :: [BitBoard.Pawns] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ BitBoard.Pawns
                   BitBoard.$fShowPawns1) -}
d43d5bd6477b515f51d59101d16394b6
  $fShowPawns_$cshowsPrec ::
    GHC.Types.Int -> BitBoard.Pawns -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(U)><L,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: BitBoard.Pawns ->
                 case w of ww { GHC.Types.I# ww1 ->
                 BitBoard.$w$cshowsPrec4 ww1 w1 }) -}
54dad9256b7d59d866b38b4bb67af31f
  $fShowQueens :: GHC.Show.Show BitBoard.Queens
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Queens
                  BitBoard.$fShowQueens_$cshowsPrec
                  BitBoard.$fShowQueens_$cshow
                  BitBoard.$fShowQueens_$cshowList -}
54dad9256b7d59d866b38b4bb67af31f
  $fShowQueens1 :: BitBoard.Queens -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ w :: BitBoard.Queens ->
                 BitBoard.$w$cshowsPrec5 0 w) -}
c0387927c72b41a019a2eb3bc1e6c2f3
  $fShowQueens2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "unQ = "#) -}
7aa488e4c022ac9af9515a41d00eb699
  $fShowQueens3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Q {"#) -}
54dad9256b7d59d866b38b4bb67af31f
  $fShowQueens_$cshow :: BitBoard.Queens -> GHC.Base.String
  {- Arity: 1, Strictness: <L,1*U(U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: BitBoard.Queens ->
                 BitBoard.$fShowQueens_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
54dad9256b7d59d866b38b4bb67af31f
  $fShowQueens_$cshowList :: [BitBoard.Queens] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ BitBoard.Queens
                   BitBoard.$fShowQueens1) -}
54dad9256b7d59d866b38b4bb67af31f
  $fShowQueens_$cshowsPrec ::
    GHC.Types.Int -> BitBoard.Queens -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(U)><L,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: BitBoard.Queens ->
                 case w of ww { GHC.Types.I# ww1 ->
                 BitBoard.$w$cshowsPrec5 ww1 w1 }) -}
830f089678e37950d6554715dce54b27
  $fShowRooks :: GHC.Show.Show BitBoard.Rooks
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.Rooks
                  BitBoard.$fShowRooks_$cshowsPrec
                  BitBoard.$fShowRooks_$cshow
                  BitBoard.$fShowRooks_$cshowList -}
830f089678e37950d6554715dce54b27
  $fShowRooks1 :: BitBoard.Rooks -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ w :: BitBoard.Rooks ->
                 BitBoard.$w$cshowsPrec6 0 w) -}
cc1c3c11b3985c12c7c68951269de0e0
  $fShowRooks2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "unR = "#) -}
a88a7ba3c553262f00696bc7e924d81a
  $fShowRooks3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "R {"#) -}
830f089678e37950d6554715dce54b27
  $fShowRooks_$cshow :: BitBoard.Rooks -> GHC.Base.String
  {- Arity: 1, Strictness: <L,1*U(U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: BitBoard.Rooks ->
                 BitBoard.$fShowRooks_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
830f089678e37950d6554715dce54b27
  $fShowRooks_$cshowList :: [BitBoard.Rooks] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ BitBoard.Rooks
                   BitBoard.$fShowRooks1) -}
830f089678e37950d6554715dce54b27
  $fShowRooks_$cshowsPrec ::
    GHC.Types.Int -> BitBoard.Rooks -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(U)><L,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: BitBoard.Rooks ->
                 case w of ww { GHC.Types.I# ww1 ->
                 BitBoard.$w$cshowsPrec6 ww1 w1 }) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fShowWhitePieces :: GHC.Show.Show BitBoard.WhitePieces
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ BitBoard.WhitePieces
                  BitBoard.$fShowWhitePieces_$cshowsPrec
                  BitBoard.$fShowWhitePieces_$cshow
                  BitBoard.$fShowWhitePieces_$cshowList -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fShowWhitePieces1 :: BitBoard.WhitePieces -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ w :: BitBoard.WhitePieces ->
                 BitBoard.$w$cshowsPrec7 0 w) -}
38eba58c758ca4107b73d7cfcd2d079d
  $fShowWhitePieces2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "unWC = "#) -}
b3e3e9dc5f309d08d986d0902dae11c0
  $fShowWhitePieces3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "WC {"#) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fShowWhitePieces_$cshow :: BitBoard.WhitePieces -> GHC.Base.String
  {- Arity: 1, Strictness: <L,1*U(U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: BitBoard.WhitePieces ->
                 BitBoard.$fShowWhitePieces_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fShowWhitePieces_$cshowList ::
    [BitBoard.WhitePieces] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ BitBoard.WhitePieces
                   BitBoard.$fShowWhitePieces1) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $fShowWhitePieces_$cshowsPrec ::
    GHC.Types.Int -> BitBoard.WhitePieces -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(U)><L,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: BitBoard.WhitePieces ->
                 case w of ww { GHC.Types.I# ww1 ->
                 BitBoard.$w$cshowsPrec7 ww1 w1 }) -}
cb5daa937d00a3cbd4dd0c0f3164ee68
  $s$dmshowList1 :: BitBoard.BitBoard -> GHC.Show.ShowS
  {- Arity: 1, Strictness: <L,1*U(U,U,U,U,U,U,U,U)>,
     Unfolding: InlineRule (1, True, False)
                (\ b :: BitBoard.BitBoard ->
                 GHC.Base.++ @ GHC.Types.Char (BitBoard.showBitBoard b)) -}
2d4ec6b056380f1ff25960b1f4e0a6be
  $w$cshowsPrec ::
    GHC.Prim.Int# -> BitBoard.Bishops -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# w :: BitBoard.Bishops ->
                 let {
                   w1 :: GHC.Integer.Type.Integer
                   = case w `cast`
                          (BitBoard.NTCo:Bishops[0]) of wild { GHC.Word.W64# x# ->
                     let {
                       i# :: GHC.Prim.Int# = GHC.Prim.word2Int# x#
                     } in
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.>=# i# 0) of wild1 {
                       GHC.Types.False -> GHC.Integer.Type.wordToInteger x#
                       GHC.Types.True -> GHC.Integer.Type.smallInteger i# } }
                 } in
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ x :: GHC.Base.String ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       BitBoard.$fShowBishops4
                       (GHC.Base.++
                          @ GHC.Types.Char
                          BitBoard.$fShowBishops3
                          (case GHC.Show.$w$cshowsPrec1
                                  0
                                  w1
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     BitBoard.$fShowBishops2
                                     x) of ww2 { (#,#) ww3 ww4 ->
                           GHC.Types.: @ GHC.Types.Char ww3 ww4 }))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False -> p
                   GHC.Types.True
                   -> \ x :: GHC.Base.String ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x)) }) -}
9ddff55270133108c79e28dd74ad22ce
  $w$cshowsPrec1 ::
    GHC.Prim.Int# -> BitBoard.BlackPieces -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# w :: BitBoard.BlackPieces ->
                 let {
                   w1 :: GHC.Integer.Type.Integer
                   = case w `cast`
                          (BitBoard.NTCo:BlackPieces[0]) of wild { GHC.Word.W64# x# ->
                     let {
                       i# :: GHC.Prim.Int# = GHC.Prim.word2Int# x#
                     } in
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.>=# i# 0) of wild1 {
                       GHC.Types.False -> GHC.Integer.Type.wordToInteger x#
                       GHC.Types.True -> GHC.Integer.Type.smallInteger i# } }
                 } in
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ x :: GHC.Base.String ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       BitBoard.$fShowBlackPieces3
                       (GHC.Base.++
                          @ GHC.Types.Char
                          BitBoard.$fShowBlackPieces2
                          (case GHC.Show.$w$cshowsPrec1
                                  0
                                  w1
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     BitBoard.$fShowBishops2
                                     x) of ww2 { (#,#) ww3 ww4 ->
                           GHC.Types.: @ GHC.Types.Char ww3 ww4 }))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False -> p
                   GHC.Types.True
                   -> \ x :: GHC.Base.String ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x)) }) -}
065b32ad76ea4a8b0402f332e197f31d
  $w$cshowsPrec2 :: GHC.Prim.Int# -> BitBoard.Kings -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# w :: BitBoard.Kings ->
                 let {
                   w1 :: GHC.Integer.Type.Integer
                   = case w `cast`
                          (BitBoard.NTCo:Kings[0]) of wild { GHC.Word.W64# x# ->
                     let {
                       i# :: GHC.Prim.Int# = GHC.Prim.word2Int# x#
                     } in
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.>=# i# 0) of wild1 {
                       GHC.Types.False -> GHC.Integer.Type.wordToInteger x#
                       GHC.Types.True -> GHC.Integer.Type.smallInteger i# } }
                 } in
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ x :: GHC.Base.String ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       BitBoard.$fShowKings3
                       (GHC.Base.++
                          @ GHC.Types.Char
                          BitBoard.$fShowKings2
                          (case GHC.Show.$w$cshowsPrec1
                                  0
                                  w1
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     BitBoard.$fShowBishops2
                                     x) of ww2 { (#,#) ww3 ww4 ->
                           GHC.Types.: @ GHC.Types.Char ww3 ww4 }))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False -> p
                   GHC.Types.True
                   -> \ x :: GHC.Base.String ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x)) }) -}
103282c86fd0df5e492207716e3fb109
  $w$cshowsPrec3 ::
    GHC.Prim.Int# -> BitBoard.Knights -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# w :: BitBoard.Knights ->
                 let {
                   w1 :: GHC.Integer.Type.Integer
                   = case w `cast`
                          (BitBoard.NTCo:Knights[0]) of wild { GHC.Word.W64# x# ->
                     let {
                       i# :: GHC.Prim.Int# = GHC.Prim.word2Int# x#
                     } in
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.>=# i# 0) of wild1 {
                       GHC.Types.False -> GHC.Integer.Type.wordToInteger x#
                       GHC.Types.True -> GHC.Integer.Type.smallInteger i# } }
                 } in
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ x :: GHC.Base.String ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       BitBoard.$fShowKnights3
                       (GHC.Base.++
                          @ GHC.Types.Char
                          BitBoard.$fShowKnights2
                          (case GHC.Show.$w$cshowsPrec1
                                  0
                                  w1
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     BitBoard.$fShowBishops2
                                     x) of ww2 { (#,#) ww3 ww4 ->
                           GHC.Types.: @ GHC.Types.Char ww3 ww4 }))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False -> p
                   GHC.Types.True
                   -> \ x :: GHC.Base.String ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x)) }) -}
d43d5bd6477b515f51d59101d16394b6
  $w$cshowsPrec4 :: GHC.Prim.Int# -> BitBoard.Pawns -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# w :: BitBoard.Pawns ->
                 let {
                   w1 :: GHC.Integer.Type.Integer
                   = case w `cast`
                          (BitBoard.NTCo:Pawns[0]) of wild { GHC.Word.W64# x# ->
                     let {
                       i# :: GHC.Prim.Int# = GHC.Prim.word2Int# x#
                     } in
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.>=# i# 0) of wild1 {
                       GHC.Types.False -> GHC.Integer.Type.wordToInteger x#
                       GHC.Types.True -> GHC.Integer.Type.smallInteger i# } }
                 } in
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ x :: GHC.Base.String ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       BitBoard.$fShowPawns3
                       (GHC.Base.++
                          @ GHC.Types.Char
                          BitBoard.$fShowPawns2
                          (case GHC.Show.$w$cshowsPrec1
                                  0
                                  w1
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     BitBoard.$fShowBishops2
                                     x) of ww2 { (#,#) ww3 ww4 ->
                           GHC.Types.: @ GHC.Types.Char ww3 ww4 }))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False -> p
                   GHC.Types.True
                   -> \ x :: GHC.Base.String ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x)) }) -}
54dad9256b7d59d866b38b4bb67af31f
  $w$cshowsPrec5 ::
    GHC.Prim.Int# -> BitBoard.Queens -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# w :: BitBoard.Queens ->
                 let {
                   w1 :: GHC.Integer.Type.Integer
                   = case w `cast`
                          (BitBoard.NTCo:Queens[0]) of wild { GHC.Word.W64# x# ->
                     let {
                       i# :: GHC.Prim.Int# = GHC.Prim.word2Int# x#
                     } in
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.>=# i# 0) of wild1 {
                       GHC.Types.False -> GHC.Integer.Type.wordToInteger x#
                       GHC.Types.True -> GHC.Integer.Type.smallInteger i# } }
                 } in
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ x :: GHC.Base.String ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       BitBoard.$fShowQueens3
                       (GHC.Base.++
                          @ GHC.Types.Char
                          BitBoard.$fShowQueens2
                          (case GHC.Show.$w$cshowsPrec1
                                  0
                                  w1
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     BitBoard.$fShowBishops2
                                     x) of ww2 { (#,#) ww3 ww4 ->
                           GHC.Types.: @ GHC.Types.Char ww3 ww4 }))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False -> p
                   GHC.Types.True
                   -> \ x :: GHC.Base.String ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x)) }) -}
830f089678e37950d6554715dce54b27
  $w$cshowsPrec6 :: GHC.Prim.Int# -> BitBoard.Rooks -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# w :: BitBoard.Rooks ->
                 let {
                   w1 :: GHC.Integer.Type.Integer
                   = case w `cast`
                          (BitBoard.NTCo:Rooks[0]) of wild { GHC.Word.W64# x# ->
                     let {
                       i# :: GHC.Prim.Int# = GHC.Prim.word2Int# x#
                     } in
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.>=# i# 0) of wild1 {
                       GHC.Types.False -> GHC.Integer.Type.wordToInteger x#
                       GHC.Types.True -> GHC.Integer.Type.smallInteger i# } }
                 } in
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ x :: GHC.Base.String ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       BitBoard.$fShowRooks3
                       (GHC.Base.++
                          @ GHC.Types.Char
                          BitBoard.$fShowRooks2
                          (case GHC.Show.$w$cshowsPrec1
                                  0
                                  w1
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     BitBoard.$fShowBishops2
                                     x) of ww2 { (#,#) ww3 ww4 ->
                           GHC.Types.: @ GHC.Types.Char ww3 ww4 }))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False -> p
                   GHC.Types.True
                   -> \ x :: GHC.Base.String ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x)) }) -}
11ef63eebe8ec7dcdee0d4f1bd76688b
  $w$cshowsPrec7 ::
    GHC.Prim.Int# -> BitBoard.WhitePieces -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# w :: BitBoard.WhitePieces ->
                 let {
                   w1 :: GHC.Integer.Type.Integer
                   = case w `cast`
                          (BitBoard.NTCo:WhitePieces[0]) of wild { GHC.Word.W64# x# ->
                     let {
                       i# :: GHC.Prim.Int# = GHC.Prim.word2Int# x#
                     } in
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.>=# i# 0) of wild1 {
                       GHC.Types.False -> GHC.Integer.Type.wordToInteger x#
                       GHC.Types.True -> GHC.Integer.Type.smallInteger i# } }
                 } in
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ x :: GHC.Base.String ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       BitBoard.$fShowWhitePieces3
                       (GHC.Base.++
                          @ GHC.Types.Char
                          BitBoard.$fShowWhitePieces2
                          (case GHC.Show.$w$cshowsPrec1
                                  0
                                  w1
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     BitBoard.$fShowBishops2
                                     x) of ww2 { (#,#) ww3 ww4 ->
                           GHC.Types.: @ GHC.Types.Char ww3 ww4 }))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False -> p
                   GHC.Types.True
                   -> \ x :: GHC.Base.String ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x)) }) -}
545d367a1bd7b42ed332554e8ce183a3
  $wshowBitBoard ::
    GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Base.String
  {- Arity: 8, Strictness: <L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U>,
     Inline: [0] -}
2d4ec6b056380f1ff25960b1f4e0a6be
  newtype Bishops = B {unB :: GHC.Word.Word64}
88003702250f810b8816a2e041c0453f
  data BitBoard
    = BitBoard ! {-# UNPACK #-}(BitBoard.NTCo:BlackPieces[0])BitBoard.BlackPieces
               ! {-# UNPACK #-}(BitBoard.NTCo:WhitePieces[0])BitBoard.WhitePieces
               ! {-# UNPACK #-}(BitBoard.NTCo:Pawns[0])BitBoard.Pawns
               ! {-# UNPACK #-}(BitBoard.NTCo:Rooks[0])BitBoard.Rooks
               ! {-# UNPACK #-}(BitBoard.NTCo:Knights[0])BitBoard.Knights
               ! {-# UNPACK #-}(BitBoard.NTCo:Bishops[0])BitBoard.Bishops
               ! {-# UNPACK #-}(BitBoard.NTCo:Queens[0])BitBoard.Queens
               ! {-# UNPACK #-}(BitBoard.NTCo:Kings[0])BitBoard.Kings
9ddff55270133108c79e28dd74ad22ce
  newtype BlackPieces = BC {unBC :: GHC.Word.Word64}
065b32ad76ea4a8b0402f332e197f31d
  newtype Kings = K {unK :: GHC.Word.Word64}
103282c86fd0df5e492207716e3fb109
  newtype Knights = N {unN :: GHC.Word.Word64}
d43d5bd6477b515f51d59101d16394b6
  newtype Pawns = P {unP :: GHC.Word.Word64}
54dad9256b7d59d866b38b4bb67af31f
  newtype Queens = Q {unQ :: GHC.Word.Word64}
830f089678e37950d6554715dce54b27
  newtype Rooks = R {unR :: GHC.Word.Word64}
11ef63eebe8ec7dcdee0d4f1bd76688b
  newtype WhitePieces = WC {unWC :: GHC.Word.Word64}
8cbb3767d78e359afbac3cfe2576fe53
  emptyBoard :: BitBoard.BitBoard
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (BitBoard.BitBoard
                   __word 0
                   __word 0
                   __word 0
                   __word 0
                   __word 0
                   __word 0
                   __word 0
                   __word 0) -}
88003702250f810b8816a2e041c0453f
  showBitBoard :: BitBoard.BitBoard -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(U,U,U,U,U,U,U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: BitBoard.BitBoard ->
                 case w of ww { BitBoard.BitBoard ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ->
                 BitBoard.$wshowBitBoard ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 }) -}
3f58324bcf54b25f6073d16fc4dc9670
  unB :: BitBoard.Bishops -> GHC.Word.Word64
  RecSel BitBoard.Bishops
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                BitBoard.unB1
                  `cast`
                (<BitBoard.Bishops>_R ->_R BitBoard.NTCo:Bishops[0]) -}
36bd78ef9286f4ecc6da01b062c60699
  unB1 :: BitBoard.Bishops -> BitBoard.Bishops
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (1, True, True)
                (\ ds :: BitBoard.Bishops -> ds) -}
31707ec4cf871f6fb209fe31abf182d2
  unBC :: BitBoard.BlackPieces -> GHC.Word.Word64
  RecSel BitBoard.BlackPieces
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                BitBoard.unBC1
                  `cast`
                (<BitBoard.BlackPieces>_R ->_R BitBoard.NTCo:BlackPieces[0]) -}
1560e1b9953eabc96acb8d951c055c28
  unBC1 :: BitBoard.BlackPieces -> BitBoard.BlackPieces
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (1, True, True)
                (\ ds :: BitBoard.BlackPieces -> ds) -}
c3f03e3d124ef619da04bc505ded286b
  unK :: BitBoard.Kings -> GHC.Word.Word64
  RecSel BitBoard.Kings
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                BitBoard.unK1
                  `cast`
                (<BitBoard.Kings>_R ->_R BitBoard.NTCo:Kings[0]) -}
6aed54057815ce2cf11a4c22d6e9b544
  unK1 :: BitBoard.Kings -> BitBoard.Kings
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (1, True, True)
                (\ ds :: BitBoard.Kings -> ds) -}
5671e581031d73814b7c5a8e9ed31313
  unN :: BitBoard.Knights -> GHC.Word.Word64
  RecSel BitBoard.Knights
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                BitBoard.unN1
                  `cast`
                (<BitBoard.Knights>_R ->_R BitBoard.NTCo:Knights[0]) -}
6b3439e25d9831b98a9de871b6d62152
  unN1 :: BitBoard.Knights -> BitBoard.Knights
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (1, True, True)
                (\ ds :: BitBoard.Knights -> ds) -}
4f6b6df131899bfb92b74a5d59a8c538
  unP :: BitBoard.Pawns -> GHC.Word.Word64
  RecSel BitBoard.Pawns
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                BitBoard.unP1
                  `cast`
                (<BitBoard.Pawns>_R ->_R BitBoard.NTCo:Pawns[0]) -}
38c3b0847c3bdb811bee88cdf6ac1018
  unP1 :: BitBoard.Pawns -> BitBoard.Pawns
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (1, True, True)
                (\ ds :: BitBoard.Pawns -> ds) -}
ade8c13e63aafe8db88580fff8650290
  unQ :: BitBoard.Queens -> GHC.Word.Word64
  RecSel BitBoard.Queens
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                BitBoard.unQ1
                  `cast`
                (<BitBoard.Queens>_R ->_R BitBoard.NTCo:Queens[0]) -}
702dcc2be1bf7371b2a88cdeec680987
  unQ1 :: BitBoard.Queens -> BitBoard.Queens
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (1, True, True)
                (\ ds :: BitBoard.Queens -> ds) -}
e4880171dd9d4e8c9183dd0c741d8322
  unR :: BitBoard.Rooks -> GHC.Word.Word64
  RecSel BitBoard.Rooks
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                BitBoard.unR1
                  `cast`
                (<BitBoard.Rooks>_R ->_R BitBoard.NTCo:Rooks[0]) -}
b7400c8632fb5a9dea8b2a4fdae10733
  unR1 :: BitBoard.Rooks -> BitBoard.Rooks
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (1, True, True)
                (\ ds :: BitBoard.Rooks -> ds) -}
9039b0c05478c7410b7196fa813df278
  unWC :: BitBoard.WhitePieces -> GHC.Word.Word64
  RecSel BitBoard.WhitePieces
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                BitBoard.unWC1
                  `cast`
                (<BitBoard.WhitePieces>_R ->_R BitBoard.NTCo:WhitePieces[0]) -}
ea3294ad7c2294eb4f67b772f174a8ed
  unWC1 :: BitBoard.WhitePieces -> BitBoard.WhitePieces
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (1, True, True)
                (\ ds :: BitBoard.WhitePieces -> ds) -}
instance Data.Bits.Bits [BitBoard.Bishops] = BitBoard.$fBitsBishops
instance Data.Bits.Bits [BitBoard.BlackPieces]
  = BitBoard.$fBitsBlackPieces
instance Data.Bits.Bits [BitBoard.Kings] = BitBoard.$fBitsKings
instance Data.Bits.Bits [BitBoard.Knights] = BitBoard.$fBitsKnights
instance Data.Bits.Bits [BitBoard.Pawns] = BitBoard.$fBitsPawns
instance Data.Bits.Bits [BitBoard.Queens] = BitBoard.$fBitsQueens
instance Data.Bits.Bits [BitBoard.Rooks] = BitBoard.$fBitsRooks
instance Data.Bits.Bits [BitBoard.WhitePieces]
  = BitBoard.$fBitsWhitePieces
instance GHC.Enum.Enum [BitBoard.Bishops] = BitBoard.$fEnumBishops
instance GHC.Enum.Enum [BitBoard.BlackPieces]
  = BitBoard.$fEnumBlackPieces
instance GHC.Enum.Enum [BitBoard.Kings] = BitBoard.$fEnumKings
instance GHC.Enum.Enum [BitBoard.Knights] = BitBoard.$fEnumKnights
instance GHC.Enum.Enum [BitBoard.Pawns] = BitBoard.$fEnumPawns
instance GHC.Enum.Enum [BitBoard.Queens] = BitBoard.$fEnumQueens
instance GHC.Enum.Enum [BitBoard.Rooks] = BitBoard.$fEnumRooks
instance GHC.Enum.Enum [BitBoard.WhitePieces]
  = BitBoard.$fEnumWhitePieces
instance GHC.Classes.Eq [BitBoard.Bishops] = BitBoard.$fEqBishops
instance GHC.Classes.Eq [BitBoard.BlackPieces]
  = BitBoard.$fEqBlackPieces
instance GHC.Classes.Eq [BitBoard.Kings] = BitBoard.$fEqKings
instance GHC.Classes.Eq [BitBoard.Knights] = BitBoard.$fEqKnights
instance GHC.Classes.Eq [BitBoard.Pawns] = BitBoard.$fEqPawns
instance GHC.Classes.Eq [BitBoard.Queens] = BitBoard.$fEqQueens
instance GHC.Classes.Eq [BitBoard.Rooks] = BitBoard.$fEqRooks
instance GHC.Classes.Eq [BitBoard.WhitePieces]
  = BitBoard.$fEqWhitePieces
instance Data.Bits.FiniteBits [BitBoard.Bishops]
  = BitBoard.$fFiniteBitsBishops
instance Data.Bits.FiniteBits [BitBoard.BlackPieces]
  = BitBoard.$fFiniteBitsBlackPieces
instance Data.Bits.FiniteBits [BitBoard.Kings]
  = BitBoard.$fFiniteBitsKings
instance Data.Bits.FiniteBits [BitBoard.Knights]
  = BitBoard.$fFiniteBitsKnights
instance Data.Bits.FiniteBits [BitBoard.Pawns]
  = BitBoard.$fFiniteBitsPawns
instance Data.Bits.FiniteBits [BitBoard.Queens]
  = BitBoard.$fFiniteBitsQueens
instance Data.Bits.FiniteBits [BitBoard.Rooks]
  = BitBoard.$fFiniteBitsRooks
instance Data.Bits.FiniteBits [BitBoard.WhitePieces]
  = BitBoard.$fFiniteBitsWhitePieces
instance GHC.Num.Num [BitBoard.Bishops] = BitBoard.$fNumBishops
instance GHC.Num.Num [BitBoard.BlackPieces]
  = BitBoard.$fNumBlackPieces
instance GHC.Num.Num [BitBoard.Kings] = BitBoard.$fNumKings
instance GHC.Num.Num [BitBoard.Knights] = BitBoard.$fNumKnights
instance GHC.Num.Num [BitBoard.Pawns] = BitBoard.$fNumPawns
instance GHC.Num.Num [BitBoard.Queens] = BitBoard.$fNumQueens
instance GHC.Num.Num [BitBoard.Rooks] = BitBoard.$fNumRooks
instance GHC.Num.Num [BitBoard.WhitePieces]
  = BitBoard.$fNumWhitePieces
instance GHC.Classes.Ord [BitBoard.Bishops] = BitBoard.$fOrdBishops
instance GHC.Classes.Ord [BitBoard.BlackPieces]
  = BitBoard.$fOrdBlackPieces
instance GHC.Classes.Ord [BitBoard.Kings] = BitBoard.$fOrdKings
instance GHC.Classes.Ord [BitBoard.Knights] = BitBoard.$fOrdKnights
instance GHC.Classes.Ord [BitBoard.Pawns] = BitBoard.$fOrdPawns
instance GHC.Classes.Ord [BitBoard.Queens] = BitBoard.$fOrdQueens
instance GHC.Classes.Ord [BitBoard.Rooks] = BitBoard.$fOrdRooks
instance GHC.Classes.Ord [BitBoard.WhitePieces]
  = BitBoard.$fOrdWhitePieces
instance GHC.Show.Show [BitBoard.Bishops] = BitBoard.$fShowBishops
instance GHC.Show.Show [BitBoard.BitBoard]
  = BitBoard.$fShowBitBoard
instance GHC.Show.Show [BitBoard.BlackPieces]
  = BitBoard.$fShowBlackPieces
instance GHC.Show.Show [BitBoard.Kings] = BitBoard.$fShowKings
instance GHC.Show.Show [BitBoard.Knights] = BitBoard.$fShowKnights
instance GHC.Show.Show [BitBoard.Pawns] = BitBoard.$fShowPawns
instance GHC.Show.Show [BitBoard.Queens] = BitBoard.$fShowQueens
instance GHC.Show.Show [BitBoard.Rooks] = BitBoard.$fShowRooks
instance GHC.Show.Show [BitBoard.WhitePieces]
  = BitBoard.$fShowWhitePieces
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

