
==================== FINAL INTERFACE ====================
2015-12-13 01:39:19.126488 UTC

interface hches_DCOOKx5aUDOAR8ciXX95kw:GameTree 7102
  interface hash: e809331ed139cbb94ce4ade03bf9a084
  ABI hash: 9bfa7917d4f220fef3c53fe757050c2c
  export-list hash: 37c1c1284da5d3b1b6d33b3c0ada9c40
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: fa9503a4b03c265efc8b5152b175dd63
  sig of: Nothing
  used TH splices: False
  where
exports:
  GameTree.applyMove
  GameTree.generateMoves
  GameTree.generateTree
  GameTree.main
  GameTree.moveBishop
  GameTree.moveKing
  GameTree.moveKnight
  GameTree.movePawn
  GameTree.moveQueen
  GameTree.moveRook
  GameTree.moves
  GameTree.singletonDList
  GameTree.test
  GameTree.MakeMoves
  GameTree.Move{GameTree.M}
  GameTree.Moves
module dependencies: Board Tree
package dependencies: StateVar-1.1.0.1@State_6K4a3UqSdqh6lGAm1wlr9s
                      array-0.5.1.0@array_E0sTtauuKsGDLZoT7lTbgZ
                      attoparsec-0.13.0.1@attop_969x13NRo2w1GLFNqu19TU base-4.8.1.0
                      base-orphans-0.4.4@baseo_E55c3OEBLyu45sND7mOuE9
                      bifunctors-5@bifun_GM18iLLOdGHJbSbyyW44ic
                      binary-0.7.5.0@binar_IvYoLp9H6Xy3zEH13MmZwd
                      bytestring-0.10.6.0@bytes_6elQVSg5cWdFrvRnfxTUrH
                      comonad-4.2.7.2@comon_Gau7sL6kCs2Gp1aW6PmLQx
                      containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN
                      contravariant-1.3.3@contr_Etlu4sPcQvWFc7dliDRyeB
                      deepseq-1.4.1.1@deeps_LbCWUlehDDeLxurARKDH5o
                      distributive-0.4.4@distr_DtmCggRmFF9KhnqzzbElBb
                      exceptions-0.8.0.2@excep_8GsEeHgaIks3pVGk6GaELJ
                      free-4.12.1@free_LEq3JjfARCZAm9OpWXvSL2 ghc-prim-0.4.0.0
                      hashable-1.2.3.3@hasha_2GTZqecVp8NJZrNuKzGxfy integer-gmp-1.0.0.0
                      mtl-2.2.1@mtl_KMpng31YRYc5JfMWFZ3FCU
                      prelude-extras-0.4.0.2@prelu_57eavILAbKD5CaKv31zEDY
                      primitive-0.6.1.0@primi_5Jnw7oEuYtM9dmKXelGXVb
                      profunctors-5.1.1@profu_10NTdMLhDJnH9DAPKgg0Ts
                      recursion-schemes-4.1.2@recur_GXdItymymlF6sVuqWgqFa4
                      scientific-0.3.4.2@scien_1UL7hJs0dy8BYuo3rFsz84
                      semigroups-0.16.2.2@semig_HNb9h0T169c7a2Sufm50uz
                      semigroupoids-5.0.0.4@semig_KHHOcgV5JRD8a0BEZjdiJ6
                      stm-2.4.4@stm_C1kFMnPqFjvDhFjgMZGUpr
                      tagged-0.8.2@tagge_4zanMqQLQHpBO0ZYm7KGkc
                      text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh
                      transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X
                      unordered-containers-0.2.5.1@unord_7E41cj9RvqSJeZ4jSnbs1a
                      vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF
orphans: attoparsec-0.13.0.1@attop_969x13NRo2w1GLFNqu19TU:Data.Attoparsec.Text.Internal
         base-4.8.1.0:GHC.Base base-4.8.1.0:GHC.Float
         binary-0.7.5.0@binar_IvYoLp9H6Xy3zEH13MmZwd:Data.Binary.Generic
         bytestring-0.10.6.0@bytes_6elQVSg5cWdFrvRnfxTUrH:Data.ByteString.Builder
         hashable-1.2.3.3@hasha_2GTZqecVp8NJZrNuKzGxfy:Data.Hashable.Generic
         stm-2.4.4@stm_C1kFMnPqFjvDhFjgMZGUpr:Control.Monad.STM
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Lazy
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Show
         transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X:Control.Monad.Trans.Error
         vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector.Fusion.Bundle
family instance modules: attoparsec-0.13.0.1@attop_969x13NRo2w1GLFNqu19TU:Data.Attoparsec.Internal.Types
                         base-4.8.1.0:Control.Applicative base-4.8.1.0:Data.Either
                         base-4.8.1.0:Data.Functor.Identity base-4.8.1.0:Data.Monoid
                         base-4.8.1.0:Data.Type.Equality base-4.8.1.0:Data.Void
                         base-4.8.1.0:GHC.Exts base-4.8.1.0:GHC.Generics
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntMap.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntSet.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Map.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Sequence
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Set.Base
                         hches_DCOOKx5aUDOAR8ciXX95kw:Tree
                         primitive-0.6.1.0@primi_5Jnw7oEuYtM9dmKXelGXVb:Control.Monad.Primitive
                         recursion-schemes-4.1.2@recur_GXdItymymlF6sVuqWgqFa4:Data.Functor.Foldable
                         semigroups-0.16.2.2@semig_HNb9h0T169c7a2Sufm50uz:Data.List.NonEmpty
                         semigroups-0.16.2.2@semig_HNb9h0T169c7a2Sufm50uz:Data.Semigroup
                         tagged-0.8.2@tagge_4zanMqQLQHpBO0ZYm7KGkc:Data.Tagged
                         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text
                         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Lazy
                         unordered-containers-0.2.5.1@unord_7E41cj9RvqSJeZ4jSnbs1a:Data.HashMap.Base
                         unordered-containers-0.2.5.1@unord_7E41cj9RvqSJeZ4jSnbs1a:Data.HashSet
                         vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector
import  -/  base-4.8.1.0:Data.Coerce 115f9a67dc841840e696ba440ba99295
import  -/  base-4.8.1.0:Data.Foldable 2e5acb797cfda6b3b7fabd7052abe290
import  -/  base-4.8.1.0:Data.Functor 5c701b0af1708f0192a25dfe14ce6274
import  -/  base-4.8.1.0:Data.Monoid bd73caba6e77f9944cb89ef5bec300c6
import  -/  base-4.8.1.0:Data.Tuple 012ad951a59a9d85fe1de36a2f012986
import  -/  base-4.8.1.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.1.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.1.0:Prelude 518f762991bc287d78f21a73c974da1f
import  -/  base-4.8.1.0:System.IO d541b8bdf18c04de3ab7ea0277c4eba3
import  -/  containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntMap.Base 41288a612f7bbd399bc0bb07f2f75738
import  -/  containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntMap.Strict 75157829e2fd1bf3aaf8a4fd3bd7d8f4
import  -/  containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Sequence 13f210c7fe95a318f20a78a068ebd17a
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  ghc-prim-0.4.0.0:GHC.Types 6b27fb3fdbd0e3f0925a4496c66513bb
import  -/  Board 97fbdfc85727bac4b1b597f6c6289a32
  exports: 3d7f70012ff23dff8c8c460ebe35f709
  Board 23a5f097f8341f48290bdf0337ecf484
  Color 94465145731abeb83fb90abca9de01d1
  Piece 97d13553bfc5d4b7536e4e493ac808fd
  Piece 9ca02e3625982d2cd041d82cee286e37
  PieceType 4c31c7686e77340a120c300a07c2e4ea
  startingBoard dfd5dad06d5f99aeb342c3f7cbfcb4ea
import  -/  Tree 3b9c0e8ba1b15ec49e4ef0ee69a519e8
  exports: 71f889167e64532cf139c79bd20a06d9
  BTree a49cfbd10675c028824e2701452b10fb
  Forest 663c5f3e3b6de6e90e1b804ad3bb3fa2
  Tree 663c5f3e3b6de6e90e1b804ad3bb3fa2
  take e20c1a50b128d191309427e2ee02d1b5
import  -/  recursion-schemes-4.1.2@recur_GXdItymymlF6sVuqWgqFa4:Data.Functor.Foldable ab79a0f11179235986b467d054856f29
ad4e76169d8622a04682003982ccdd6f
  $w$wa1 ::
    Board.Board
    -> GHC.Prim.Int#
    -> (# GHC.Types.Int,
          Data.IntMap.Base.IntMap
            (Data.Sequence.Seq (Tree.Tree GHC.Types.Int)) #)
  {- Arity: 2, Strictness: <S,U><L,U>, Inline: [0] -}
55962aa75285498af0ef36dda1f98839
  $wcoalg ::
    Board.Board
    -> GHC.Prim.Int#
    -> (# GHC.Types.Int,
          Data.IntMap.Base.IntMap (Data.Sequence.Seq GameTree.Move) #)
  {- Arity: 2, Strictness: <S,U><L,U>, Inline: INLINABLE[0],
     Unfolding: <stable> (\ ww :: Board.Board ww1 :: GHC.Prim.Int# ->
                          (# GHC.Types.I# ww1,
                             Data.IntMap.Strict.mapWithKey
                               @ (Data.Sequence.Seq GHC.Types.Int)
                               @ (Data.Sequence.Seq GameTree.Move)
                               (\ x :: Data.IntSet.Base.Key
                                  eta :: Data.Sequence.Seq GHC.Types.Int[OneShot] ->
                                Data.Sequence.$fApplicativeSeq_$cfmap
                                  @ (Data.Sequence.Elem GHC.Types.Int)
                                  @ (Data.Sequence.Elem GameTree.Move)
                                  (GameTree.generateTree_buildMove ww x)
                                    `cast`
                                  (Sym (Data.Sequence.NTCo:Elem[0] <GHC.Types.Int>_R)
                                   ->_R Sym (Data.Sequence.NTCo:Elem[0] <GameTree.Move>_R))
                                  eta `cast` (Data.Sequence.NTCo:Seq[0] <GHC.Types.Int>_R))
                                 `cast`
                               (<Data.IntSet.Base.Key>_R
                                ->_R <Data.Sequence.Seq GHC.Types.Int>_R
                                ->_R Sym (Data.Sequence.NTCo:Seq[0] <GameTree.Move>_R))
                               (GameTree.generateMoves ww) #)) -}
b52208046f906d9639e080fdec343cab
  $wmovePawn :: GHC.Types.Int -> Board.Color -> GameTree.Moves
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><S,1*U>,
     Inline: [0],
     Unfolding: (\ w :: GHC.Types.Int w1 :: Board.Color ->
                 case w1 of wild {
                   GHC.Types.False
                   -> Data.IntMap.Base.Nil
                        @ (Data.Monoid.Endo (Data.Sequence.Seq GHC.Types.Int))
                   GHC.Types.True
                   -> case w of wild1 { GHC.Types.I# x ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# x 56) of wild2 {
                        GHC.Types.False
                        -> Data.IntMap.Base.Nil
                             @ (Data.Monoid.Endo (Data.Sequence.Seq GHC.Types.Int))
                        GHC.Types.True
                        -> let {
                             a :: GHC.Prim.Int# = GHC.Prim.+# x 8
                           } in
                           let {
                             a1 :: GHC.Types.Int {- Strictness: m -} = GHC.Types.I# a
                           } in
                           let {
                             lvl1 :: Data.Sequence.Digit (Data.Sequence.Elem GHC.Types.Int)
                             = Data.Sequence.One
                                 @ (Data.Sequence.Elem GHC.Types.Int)
                                 a1 `cast` (Sym (Data.Sequence.NTCo:Elem[0] <GHC.Types.Int>_R))
                           } in
                           let {
                             lvl2 :: Data.Sequence.FingerTree (Data.Sequence.Elem GHC.Types.Int)
                             = Data.Sequence.Single
                                 @ (Data.Sequence.Elem GHC.Types.Int)
                                 a1 `cast` (Sym (Data.Sequence.NTCo:Elem[0] <GHC.Types.Int>_R))
                           } in
                           Data.IntMap.Base.Tip
                             @ (Data.Monoid.Endo (Data.Sequence.Seq GHC.Types.Int))
                             x
                             (\ ds :: Data.Sequence.FingerTree
                                        (Data.Sequence.Elem GHC.Types.Int) ->
                              case ds of wild3 {
                                Data.Sequence.Empty -> lvl2
                                Data.Sequence.Single b
                                -> Data.Sequence.Deep
                                     @ (Data.Sequence.Elem GHC.Types.Int)
                                     2
                                     lvl1
                                     (Data.Sequence.Empty
                                        @ (Data.Sequence.Node (Data.Sequence.Elem GHC.Types.Int)))
                                     (Data.Sequence.One @ (Data.Sequence.Elem GHC.Types.Int) b)
                                Data.Sequence.Deep dt ds1 m sf
                                -> case ds1 of wild4 {
                                     Data.Sequence.One b
                                     -> Data.Sequence.Deep
                                          @ (Data.Sequence.Elem GHC.Types.Int)
                                          (GHC.Prim.+# 1 dt)
                                          (Data.Sequence.Two
                                             @ (Data.Sequence.Elem GHC.Types.Int)
                                             a1
                                               `cast`
                                             (Sym (Data.Sequence.NTCo:Elem[0] <GHC.Types.Int>_R))
                                             b)
                                          m
                                          sf
                                     Data.Sequence.Two b c
                                     -> Data.Sequence.Deep
                                          @ (Data.Sequence.Elem GHC.Types.Int)
                                          (GHC.Prim.+# 1 dt)
                                          (Data.Sequence.Three
                                             @ (Data.Sequence.Elem GHC.Types.Int)
                                             a1
                                               `cast`
                                             (Sym (Data.Sequence.NTCo:Elem[0] <GHC.Types.Int>_R))
                                             b
                                             c)
                                          m
                                          sf
                                     Data.Sequence.Three b c d
                                     -> Data.Sequence.Deep
                                          @ (Data.Sequence.Elem GHC.Types.Int)
                                          (GHC.Prim.+# 1 dt)
                                          (Data.Sequence.Four
                                             @ (Data.Sequence.Elem GHC.Types.Int)
                                             a1
                                               `cast`
                                             (Sym (Data.Sequence.NTCo:Elem[0] <GHC.Types.Int>_R))
                                             b
                                             c
                                             d)
                                          m
                                          sf
                                     Data.Sequence.Four b c d e
                                     -> case m of m1 { DEFAULT ->
                                        Data.Sequence.Deep
                                          @ (Data.Sequence.Elem GHC.Types.Int)
                                          (GHC.Prim.+# 1 dt)
                                          (Data.Sequence.Two
                                             @ (Data.Sequence.Elem GHC.Types.Int)
                                             a1
                                               `cast`
                                             (Sym (Data.Sequence.NTCo:Elem[0] <GHC.Types.Int>_R))
                                             b)
                                          (Data.Sequence.<|_$s$sconsTree @ GHC.Types.Int 3 c d e m1)
                                          sf } } })
                               `cast`
                             (Sym (Data.Monoid.NTCo:Endo[0]
                                       (Data.Sequence.NTCo:Seq[0] <GHC.Types.Int>_R))) } } }) -}
9ebe3f47a74d5c619a6767051e7a9114
  $wmoves ::
    Board.Board
    -> GHC.Prim.Int# -> Board.Color -> GHC.Prim.Int# -> GameTree.Moves
  {- Arity: 4, Strictness: <S,1*U><L,U><S,U><S,1*U>, Inline: [0],
     Unfolding: (\ w :: Board.Board
                   ww :: GHC.Prim.Int#
                   ww1 :: Board.Color
                   ww2 :: GHC.Prim.Int# ->
                 case w of board { DEFAULT ->
                 case ww2 of wild {
                   DEFAULT -> GameTree.generateMoves2
                   1 -> GameTree.$wmovePawn (GHC.Types.I# ww) ww1
                   2
                   -> Data.IntMap.Base.Nil
                        @ (Data.Monoid.Endo (Data.Sequence.Seq GHC.Types.Int))
                   3
                   -> Data.IntMap.Base.Nil
                        @ (Data.Monoid.Endo (Data.Sequence.Seq GHC.Types.Int))
                   4
                   -> Data.IntMap.Base.Nil
                        @ (Data.Monoid.Endo (Data.Sequence.Seq GHC.Types.Int))
                   5
                   -> Data.IntMap.Base.Nil
                        @ (Data.Monoid.Endo (Data.Sequence.Seq GHC.Types.Int))
                   6
                   -> Data.IntMap.Base.Nil
                        @ (Data.Monoid.Endo (Data.Sequence.Seq GHC.Types.Int)) } }) -}
95e71e3ce2c785bdc38b226bc3a083ce
  type MakeMoves =
    Board.Board -> GHC.Types.Int -> Board.Color -> GameTree.Moves
d82116e5eb8283335c021c9be079cb34
  data Move = M !Board.Board {-# UNPACK #-}GHC.Types.Int
d57756fcd7a7f80f4bba7d8a9f1fdca1
  type Moves =
    Data.IntMap.Base.IntMap
      (Data.Monoid.Endo (Data.Sequence.Seq GHC.Types.Int))
2e3d9437be9b6f40623ebf686f98656b
  applyMove ::
    GHC.Types.Int -> GHC.Types.Int -> Board.Board -> Board.Board
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(U)><S,1*U>,
     Inline: INLINE (sat-args=3),
     Unfolding: InlineRule (3, False, False)
                (\ start :: GHC.Types.Int
                   end :: GHC.Types.Int
                   board :: Board.Board ->
                 case start of start1 { GHC.Types.I# ipv ->
                 case end of end1 { GHC.Types.I# ipv1 ->
                 case board of board1 { DEFAULT ->
                 Data.IntMap.Strict.insert
                   @ Board.Piece
                   end1
                   (Data.IntMap.Base.! @ Board.Piece board1 start1)
                   (Data.IntMap.Base.delete @ Board.Piece start1 board1) } } }) -}
e6845d4142ea3a006009c3adafcce783
  generateMoves ::
    Board.Board
    -> Data.IntMap.Base.IntMap (Data.Sequence.Seq GHC.Types.Int)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ b :: Board.Board ->
                 letrec {
                   go2 :: Data.IntMap.Base.IntMap
                            (Data.Monoid.Endo (Data.Sequence.Seq GHC.Types.Int))
                          -> Data.IntMap.Base.IntMap Board.Piece
                          -> Data.IntMap.Base.IntMap
                               (Data.Monoid.Endo (Data.Sequence.Seq GHC.Types.Int))
                     {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                   = \ z' :: Data.IntMap.Base.IntMap
                               (Data.Monoid.Endo (Data.Sequence.Seq GHC.Types.Int))
                       ds :: Data.IntMap.Base.IntMap Board.Piece ->
                     case ds of wild {
                       Data.IntMap.Base.Bin dt dt1 l r -> go2 (go2 z' r) l
                       Data.IntMap.Base.Tip dt x
                       -> case x of ww { Board.Piece ww1 ww2 ->
                          Data.IntMap.Strict.unionWithKey
                            @ (Data.Monoid.Endo (Data.Sequence.Seq GHC.Types.Int))
                            GameTree.generateMoves3
                              `cast`
                            (<Data.IntSet.Base.Key>_R
                             ->_R <Data.Monoid.Endo (Data.Sequence.Seq GHC.Types.Int)>_R
                             ->_R <Data.Monoid.Endo (Data.Sequence.Seq GHC.Types.Int)>_R
                             ->_R Sym (Data.Monoid.NTCo:Endo[0]
                                           <Data.Sequence.Seq GHC.Types.Int>_R))
                            (GameTree.$wmoves b dt ww1 ww2)
                            z' }
                       Data.IntMap.Base.Nil -> z' }
                 } in
                 case b of wild {
                   DEFAULT
                   -> Data.IntMap.Base.map
                        @ (Data.Monoid.Endo (Data.Sequence.Seq GHC.Types.Int))
                        @ (Data.Sequence.Seq GHC.Types.Int)
                        GameTree.generateMoves1
                        (go2
                           (Data.IntMap.Base.Nil
                              @ (Data.Monoid.Endo (Data.Sequence.Seq GHC.Types.Int)))
                           wild)
                   Data.IntMap.Base.Bin dt dt1 l r
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<# dt1 0) of wild1 {
                        GHC.Types.False
                        -> Data.IntMap.Base.map
                             @ (Data.Monoid.Endo (Data.Sequence.Seq GHC.Types.Int))
                             @ (Data.Sequence.Seq GHC.Types.Int)
                             GameTree.generateMoves1
                             (go2
                                (go2
                                   (Data.IntMap.Base.Nil
                                      @ (Data.Monoid.Endo (Data.Sequence.Seq GHC.Types.Int)))
                                   r)
                                l)
                        GHC.Types.True
                        -> Data.IntMap.Base.map
                             @ (Data.Monoid.Endo (Data.Sequence.Seq GHC.Types.Int))
                             @ (Data.Sequence.Seq GHC.Types.Int)
                             GameTree.generateMoves1
                             (go2
                                (go2
                                   (Data.IntMap.Base.Nil
                                      @ (Data.Monoid.Endo (Data.Sequence.Seq GHC.Types.Int)))
                                   l)
                                r) } }) -}
20fb28d4a1d2408b91e97acc58597e90
  generateMoves1 ::
    Data.Monoid.Endo (Data.Sequence.Seq GHC.Types.Int)
    -> Data.Sequence.Seq GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <C(S),1*C1(U)>,
     Unfolding: InlineRule (1, True, True)
                (\ y :: Data.Monoid.Endo (Data.Sequence.Seq GHC.Types.Int) ->
                 y `cast`
                 (Data.Monoid.NTCo:Endo[0] <Data.Sequence.Seq GHC.Types.Int>_R)
                   (Data.Sequence.Empty @ (Data.Sequence.Elem GHC.Types.Int))
                     `cast`
                   (Sym (Data.Sequence.NTCo:Seq[0] <GHC.Types.Int>_R))) -}
4d8bf9fd896d19af8f573962695bc5c8
  generateMoves2 :: GameTree.Moves
  {- Strictness: b -}
70d0023a7a4f9365e0da310f07519684
  generateMoves3 ::
    Data.IntSet.Base.Key
    -> Data.Monoid.Endo (Data.Sequence.Seq GHC.Types.Int)
    -> Data.Monoid.Endo (Data.Sequence.Seq GHC.Types.Int)
    -> Data.Sequence.Seq GHC.Types.Int
    -> Data.Sequence.Seq GHC.Types.Int
  {- Arity: 4, HasNoCafRefs,
     Unfolding: (\ ds :: Data.IntSet.Base.Key
                   x :: Data.Monoid.Endo (Data.Sequence.Seq GHC.Types.Int)[OneShot]
                   y :: Data.Monoid.Endo (Data.Sequence.Seq GHC.Types.Int)[OneShot] ->
                 Data.Monoid.$fMonoidEndo3
                   @ (Data.Sequence.Seq GHC.Types.Int)
                   x
                   y) -}
a579e36ec78f8c1dceb6ff5a9e8ab26a
  generateTree :: Board.Board -> Tree.Forest GHC.Types.Int
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ board :: Board.Board ->
                 let {
                   unfoldMoves :: GHC.Types.Int
                                  -> GHC.Types.Int -> Tree.Tree GHC.Types.Int
                     {- Arity: 2, Strictness: <S,1*U(U)><S,1*U(U)>m,
                        Inline: INLINE (sat-args=2),
                        Unfolding: InlineRule (2, False, False)
                                   (\ start :: GHC.Types.Int end :: GHC.Types.Int ->
                                    Tree.$fUnfoldableTree_$cana
                                      @ GHC.Types.Int
                                      (Tree.$fFunctorBTree @ GHC.Types.Int)
                                        `cast`
                                      (GHC.Base.Functor
                                         (Sym (Tree.TFCo:R:BaseTree[0] <GHC.Types.Int>_N)))_R
                                      @ GameTree.Move
                                      GameTree.generateTree_coalg
                                      (case start of start1 { GHC.Types.I# ipv ->
                                       case end of end1 { GHC.Types.I# ipv1 ->
                                       case board of board1 { DEFAULT ->
                                       case Data.IntMap.Strict.insert
                                              @ Board.Piece
                                              end1
                                              (Data.IntMap.Base.! @ Board.Piece board1 start1)
                                              (Data.IntMap.Base.delete
                                                 @ Board.Piece
                                                 start1
                                                 board1) of dt { DEFAULT ->
                                       GameTree.M dt ipv1 } } } })) -}
                   = \ eta :: GHC.Types.Int eta1 :: GHC.Types.Int ->
                     case eta of start { GHC.Types.I# ipv ->
                     case eta1 of end { GHC.Types.I# ipv1 ->
                     case Data.IntMap.Strict.$winsert
                            @ Board.Piece
                            ipv1
                            (Data.IntMap.Base.$w! @ Board.Piece board ipv)
                            (Data.IntMap.Base.$wdelete
                               @ Board.Piece
                               ipv
                               board) of dt { DEFAULT ->
                     case GameTree.$w$wa1 dt ipv1 of ww { (#,#) ww1 ww2 ->
                     Tree.Tree @ GHC.Types.Int ww1 ww2 } } } }
                 } in
                 Data.IntMap.Strict.mapWithKey
                   @ (Data.Sequence.Seq GHC.Types.Int)
                   @ (Data.Sequence.Seq (Tree.Tree GHC.Types.Int))
                   (\ x :: Data.IntSet.Base.Key
                      eta :: Data.Sequence.Seq GHC.Types.Int[OneShot] ->
                    Data.Sequence.$fApplicativeSeq_$cfmap
                      @ (Data.Sequence.Elem GHC.Types.Int)
                      @ (Data.Sequence.Elem (Tree.Tree GHC.Types.Int))
                      (unfoldMoves x)
                        `cast`
                      (Sym (Data.Sequence.NTCo:Elem[0] <GHC.Types.Int>_R)
                       ->_R Sym (Data.Sequence.NTCo:Elem[0] <Tree.Tree GHC.Types.Int>_R))
                      eta `cast` (Data.Sequence.NTCo:Seq[0] <GHC.Types.Int>_R))
                     `cast`
                   (<Data.IntSet.Base.Key>_R
                    ->_R <Data.Sequence.Seq GHC.Types.Int>_R
                    ->_R Sym (Data.Sequence.NTCo:Seq[0] <Tree.Tree GHC.Types.Int>_R))
                   (GameTree.generateMoves board)) -}
40cff319cc5844fa1d8b3c06b809a9f7
  generateTree_buildMove ::
    Board.Board -> GHC.Types.Int -> GHC.Types.Int -> GameTree.Move
  {- Arity: 3, Strictness: <S,1*U><S,1*U(U)><S,1*U(U)>m,
     Inline: INLINE (sat-args=3),
     Unfolding: InlineRule (3, False, False)
                (\ board :: Board.Board
                   start :: GHC.Types.Int
                   end :: GHC.Types.Int ->
                 case board of board1 { DEFAULT ->
                 case start of start1 { GHC.Types.I# ipv ->
                 case end of end1 { GHC.Types.I# ipv1 ->
                 case Data.IntMap.Strict.insert
                        @ Board.Piece
                        end1
                        (Data.IntMap.Base.! @ Board.Piece board1 start1)
                        (Data.IntMap.Base.delete
                           @ Board.Piece
                           start1
                           board1) of dt { DEFAULT ->
                 GameTree.M dt ipv1 } } } }) -}
b27d6a3a7e68029850c696d2827db0e3
  generateTree_coalg ::
    GameTree.Move
    -> Data.Functor.Foldable.Base
         (Tree.Tree GHC.Types.Int) GameTree.Move
  {- Arity: 1, Strictness: <S(SL),1*U(U,U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GameTree.Move ->
                 case w of ww { GameTree.M ww1 ww2 ->
                 case GameTree.$wcoalg ww1 ww2 of ww3 { (#,#) ww4 ww5 ->
                 (Tree.BTree @ GHC.Types.Int @ GameTree.Move ww4 ww5)
                   `cast`
                 (Sub (Sym (Tree.TFCo:R:BaseTree[0]
                                <GHC.Types.Int>_N)) <GameTree.Move>_N) } }) -}
2359fad431d585258256fbc824254d92
  main :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True)
                GameTree.main1 `cast` (Sym (GHC.Types.NTCo:IO[0] <()>_R)) -}
e34b275f88e53f10414b3c06fc6b418b
  main1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ eta :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 GHC.IO.Handle.Text.hPutStr2
                   GHC.IO.Handle.FD.stdout
                   GameTree.main2
                   GHC.Types.True
                   eta) -}
9c5b171790e4ada11cdbeb72beee4276
  main2 :: GHC.Base.String
  {- Unfolding: (case GameTree.main3 of ww5 { Tree.Tree ww6 ww7 ->
                 case Tree.$wa2 @ GHC.Types.Int 7 ww6 ww7 of ww8 { (#,#) ww9 ww10 ->
                 case (Tree.$w$cfoldMap
                         @ GHC.Types.Int
                         @ (Data.Monoid.Endo (GHC.Types.Int -> GHC.Types.Int))
                         (Data.Monoid.$fMonoidEndo @ (GHC.Types.Int -> GHC.Types.Int))
                         (Tree.$fFoldableTree6 @ GHC.Types.Int)
                           `cast`
                         (<GHC.Types.Int>_R
                          ->_R Sym (Data.Monoid.NTCo:Endo[0]
                                        <GHC.Types.Int -> GHC.Types.Int>_R))
                         ww9
                         ww10)
                        `cast`
                      (Data.Monoid.NTCo:Endo[0] <GHC.Types.Int -> GHC.Types.Int>_R)
                        (GHC.Base.id @ GHC.Types.Int)
                        Tree.$fFoldableTree0_z0 of ww2 { GHC.Types.I# ww3 ->
                 case GHC.Show.$wshowSignedInt
                        0
                        ww3
                        (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww1 ww12 ->
                 GHC.Types.: @ GHC.Types.Char ww1 ww12 } } } }) -}
b1038f93db845c4006f9342b1064ba07
  main3 :: Tree.Tree GHC.Types.Int
  {- Unfolding: (case GameTree.generateTree
                        Board.startingBoard of wild {
                   Data.IntMap.Base.Bin dt dt1 l r
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<# dt1 0) of wild1 {
                        GHC.Types.False
                        -> case Data.IntMap.Base.$wgo3
                                  @ (Data.Sequence.Seq (Tree.Tree GHC.Types.Int))
                                  l of ww { (#,#) ww1 ww2 ->
                           Data.Sequence.$windex @ (Tree.Tree GHC.Types.Int) ww2 0 }
                        GHC.Types.True
                        -> case Data.IntMap.Base.$wgo3
                                  @ (Data.Sequence.Seq (Tree.Tree GHC.Types.Int))
                                  r of ww { (#,#) ww1 ww2 ->
                           Data.Sequence.$windex @ (Tree.Tree GHC.Types.Int) ww2 0 } }
                   Data.IntMap.Base.Tip dt v
                   -> Data.Sequence.$windex @ (Tree.Tree GHC.Types.Int) v 0
                   Data.IntMap.Base.Nil
                   -> case Data.IntMap.Base.findMin1
                      ret_ty (Tree.Tree GHC.Types.Int)
                      of {} }) -}
15874c8fd3cd88de236038706453122b
  moveBishop :: GameTree.MakeMoves
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ board :: Board.Board index :: GHC.Types.Int c :: Board.Color ->
                 Data.IntMap.Base.Nil
                   @ (Data.Monoid.Endo (Data.Sequence.Seq GHC.Types.Int))) -}
2dffc682986757cc652fd1abce0e8d3f
  moveKing :: GameTree.MakeMoves
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ board :: Board.Board index :: GHC.Types.Int c :: Board.Color ->
                 Data.IntMap.Base.Nil
                   @ (Data.Monoid.Endo (Data.Sequence.Seq GHC.Types.Int))) -}
d11ad50ac6e3558feb9b6ad2e30624c7
  moveKnight :: GameTree.MakeMoves
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ board :: Board.Board index :: GHC.Types.Int c :: Board.Color ->
                 Data.IntMap.Base.Nil
                   @ (Data.Monoid.Endo (Data.Sequence.Seq GHC.Types.Int))) -}
1cb299d6de86fce11f50c644e4578337
  movePawn :: GameTree.MakeMoves
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,1*U(U)><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: Board.Board w1 :: GHC.Types.Int w2 :: Board.Color ->
                 GameTree.$wmovePawn w1 w2) -}
3b8aa93d76b564651aef3c56ee651b49
  moveQueen :: GameTree.MakeMoves
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ board :: Board.Board index :: GHC.Types.Int c :: Board.Color ->
                 Data.IntMap.Base.Nil
                   @ (Data.Monoid.Endo (Data.Sequence.Seq GHC.Types.Int))) -}
aee752ab9dbd4f34b8bf25bec341ad76
  moveRook :: GameTree.MakeMoves
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ board :: Board.Board index :: GHC.Types.Int c :: Board.Color ->
                 Data.IntMap.Base.Nil
                   @ (Data.Monoid.Endo (Data.Sequence.Seq GHC.Types.Int))) -}
3afd3c3f71d0087903de6b6b28fe2271
  moves ::
    Board.Board -> GHC.Types.Int -> Board.Piece -> GameTree.Moves
  {- Arity: 3, Strictness: <S,1*U><S,1*U(U)><S(SS),1*U(U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: Board.Board w1 :: GHC.Types.Int w2 :: Board.Piece ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 case w2 of ww2 { Board.Piece ww3 ww4 ->
                 GameTree.$wmoves w ww1 ww3 ww4 } }) -}
1fa9e11a11775a2aa5c264bd93be5037
  singletonDList :: a -> Data.Monoid.Endo (Data.Sequence.Seq a)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Data.Sequence.<|_$sconsTree
                  `cast`
                (forall a.
                 Data.Sequence.NTCo:Elem[0] <a>_R
                 ->_R Sym (Data.Monoid.NTCo:Endo[0]
                               (Data.Sequence.NTCo:Seq[0] <a>_R))) -}
681622f6bf1d100f3239d3772f565a99
  test :: GHC.Types.Int -> Tree.Tree GHC.Types.Int
  {- Arity: 1, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ n :: GHC.Types.Int ->
                 Tree.take @ GHC.Types.Int n GameTree.main3) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

