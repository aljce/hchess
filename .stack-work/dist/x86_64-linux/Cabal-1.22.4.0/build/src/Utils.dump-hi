
==================== FINAL INTERFACE ====================
2016-01-02 04:04:55.148258 UTC

interface hches_KF6MDI5eODG4Q8cKhuw0mn:Utils 7102
  interface hash: bfcd69f09b111bb1e6ccecdc61179131
  ABI hash: c1fcca74c7807322d8b03839708375a1
  export-list hash: 36d236ad7b4c1b7db186f8e2df774189
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 2bfdd69c509df0f94c327e5faec9ae27
  sig of: Nothing
  used TH splices: False
  where
exports:
  Utils.bool
  Utils.ps
  Utils.put8
  Utils.showWord64
module dependencies:
package dependencies: base-4.8.1.0 ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
orphans: base-4.8.1.0:GHC.Base base-4.8.1.0:GHC.Float
family instance modules: base-4.8.1.0:Control.Applicative
                         base-4.8.1.0:Data.Either base-4.8.1.0:Data.Monoid
                         base-4.8.1.0:Data.Type.Equality base-4.8.1.0:GHC.Generics
import  -/  base-4.8.1.0:Data.Bits 5341167fdd5958c2b3f0dac8924f1efd
import  -/  base-4.8.1.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.1.0:GHC.List f31ed8784b3e05f1397195751f7d74ea
import  -/  base-4.8.1.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.1.0:Prelude 518f762991bc287d78f21a73c974da1f
import  -/  base-4.8.1.0:System.IO d541b8bdf18c04de3ab7ea0277c4eba3
import  -/  ghc-prim-0.4.0.0:GHC.Types 6b27fb3fdbd0e3f0925a4496c66513bb
be303d76d08aee566bc6a591179693c3
  bool :: a -> a -> GHC.Types.Bool -> a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,1*U><L,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a x :: a ds :: a ds1 :: GHC.Types.Bool ->
                 case ds1 of wild { GHC.Types.False -> ds GHC.Types.True -> x }) -}
ea783c546bebc2e41f7509d153a5ca7f
  ps :: Data.Bits.FiniteBits a => a -> GHC.Types.IO ()
  {- Arity: 3, Strictness: <S(LC(S)LL),U(U,C(U(U)),A,A)><L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Utils.ps1
                  `cast`
                (forall a.
                 <Data.Bits.FiniteBits a>_R
                 ->_R <a>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0] <()>_R)) -}
f3a17cd41ffc871e3da9af0c8cd1a12e
  ps1 ::
    Data.Bits.FiniteBits a =>
    a
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3, Strictness: <S(LC(S)LL),U(U,C(U(U)),A,A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   $dFiniteBits :: Data.Bits.FiniteBits a
                   eta :: a
                   eta1 :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 Utils.ps2 (Utils.showWord64 @ a $dFiniteBits eta) eta1) -}
72ca950c4a036e728c452cb0e12b5fdf
  ps2 ::
    [GHC.Types.Char]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <S,1*U><L,U> -}
582e26294751770905d4431b99677f5c
  put8 :: GHC.Base.String -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Utils.ps2
                  `cast`
                (<[GHC.Types.Char]>_R ->_R Sym (GHC.Types.NTCo:IO[0] <()>_R)) -}
e06ec8be13afa1dda0aca3ab93c9fd8a
  showWord1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.List.reverse1
                   @ GHC.Types.Char
                   (GHC.Types.[] @ GHC.Types.Char)
                   (GHC.Types.[] @ GHC.Types.Char)) -}
e42204498ae82affd202ae94ce151b75
  showWord2 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# '1') -}
b109e48f8ca6d3e49e2f1d56958737f1
  showWord3 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# '0') -}
07d01ce258e0d575e1925a3fc4c4de17
  showWord64 :: Data.Bits.FiniteBits a => a -> GHC.Base.String
  {- Arity: 2, Strictness: <S(LC(S)LL),U(1*U,1*C1(U(U)),A,A)><L,U>,
     Unfolding: (\ @ a
                   $dFiniteBits :: Data.Bits.FiniteBits a
                   eta :: a ->
                 case Data.Bits.finiteBitSize
                        @ a
                        $dFiniteBits
                        eta of wild { GHC.Types.I# x ->
                 let {
                   y :: GHC.Prim.Int# = GHC.Prim.-# x 1
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># 0 y) of wild1 {
                   GHC.Types.False
                   -> let {
                        $dBits :: Data.Bits.Bits a
                        = Data.Bits.$p1FiniteBits @ a $dFiniteBits
                      } in
                      letrec {
                        go :: GHC.Prim.Int# -> [GHC.Types.Char]
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ x1 :: GHC.Prim.Int# ->
                          GHC.Types.:
                            @ GHC.Types.Char
                            (case Data.Bits.testBit @ a $dBits eta (GHC.Types.I# x1) of wild2 {
                               GHC.Types.False -> Utils.showWord3
                               GHC.Types.True -> Utils.showWord2 })
                            (case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.==# x1 y) of wild2 {
                               GHC.Types.False -> go (GHC.Prim.+# x1 1)
                               GHC.Types.True -> GHC.Types.[] @ GHC.Types.Char })
                      } in
                      GHC.List.reverse1
                        @ GHC.Types.Char
                        (go 0)
                        (GHC.Types.[] @ GHC.Types.Char)
                   GHC.Types.True -> Utils.showWord1 } }) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

