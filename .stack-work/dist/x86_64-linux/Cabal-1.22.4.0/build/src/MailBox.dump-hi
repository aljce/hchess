
==================== FINAL INTERFACE ====================
2015-12-22 19:40:22.384276 UTC

interface hches_KF6MDI5eODG4Q8cKhuw0mn:MailBox [family instance module] 7102
  interface hash: 9466e028d8b5597a8751750d9149e3a4
  ABI hash: 24d63f472109eda6b7ba89a63060cf8a
  export-list hash: ee118c8e7eddc4f779ee085c52fa58ec
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 60b0c5c5667f32509f7228bb0f134659
  sig of: Nothing
  used TH splices: True
  where
exports:
  MailBox.allSquareTypes
  MailBox.showMailBox
  MailBox.MailBox
  MailBox.Square{MailBox.S MailBox.unS}
  Data.Vector.Unboxed.Base.MVector|{MailBox.MV_Square}
  Data.Vector.Unboxed.Base.Vector|{MailBox.V_Square}
module dependencies: BitBoard
package dependencies: array-0.5.1.0@array_E0sTtauuKsGDLZoT7lTbgZ
                      base-4.8.1.0 containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN
                      deepseq-1.4.1.1@deeps_LbCWUlehDDeLxurARKDH5o ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0 pretty-1.1.2.0@prett_7UQTOB05U7lIYPkFOVraeR
                      primitive-0.6.1.0@primi_5Jnw7oEuYtM9dmKXelGXVb
                      template-haskell-2.10.0.0
                      transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X
                      vector-th-unbox-0.2.1.3@vecto_7UKBkJbwJOEKV3lSwERBE0
                      vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF
orphans: base-4.8.1.0:GHC.Base base-4.8.1.0:GHC.Float
         transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X:Control.Monad.Trans.Error
         vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector.Fusion.Bundle
         vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector.Unboxed
family instance modules: base-4.8.1.0:Control.Applicative
                         base-4.8.1.0:Data.Either base-4.8.1.0:Data.Functor.Identity
                         base-4.8.1.0:Data.Monoid base-4.8.1.0:Data.Type.Equality
                         base-4.8.1.0:Data.Void base-4.8.1.0:GHC.Exts
                         base-4.8.1.0:GHC.Generics
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntMap.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntSet.Base
                         pretty-1.1.2.0@prett_7UQTOB05U7lIYPkFOVraeR:Text.PrettyPrint.HughesPJ
                         primitive-0.6.1.0@primi_5Jnw7oEuYtM9dmKXelGXVb:Control.Monad.Primitive
                         template-haskell-2.10.0.0:Language.Haskell.TH.Syntax
                         vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector.Primitive
                         vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector.Unboxed
                         vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector.Unboxed.Base
import  -/  base-4.8.1.0:Data.Word 448c480b98a0c18988a37db5ab829b22
import  -/  base-4.8.1.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.1.0:GHC.Word ef6286c279d61931eb675109b4b93579
import  -/  base-4.8.1.0:Prelude 518f762991bc287d78f21a73c974da1f
import  -/  BitBoard 7e4576e6f7d0be2ca1ef0ad8232e27f7
  exports: bdccb0548ea28b40cb7b32788872b4c3
import  -/  vector-th-unbox-0.2.1.3@vecto_7UKBkJbwJOEKV3lSwERBE0:Data.Vector.Unboxed.Deriving ca39b75552a17b45193a0bf900b2bb7a
import  -/  vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector.Generic.Base f9e814d2cdc449478d6b1a8e12059519
import  -/  vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector.Generic.Mutable.Base 74328ab2ccb574f6522896e090906e9d
import  -/  vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector.Unboxed 8bd91cd1a3cd2cbd12faec978422ccd8
import  -/  vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector.Unboxed.Base 0761e27d6792efb778c5ac79292248a5
import  -/  vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector.Unboxed.Mutable d0342434d0f49e690fa796e53c38e521
95999ae030c6e75e85d223fd90df7ec1
  $fMVectorMVectorSquare ::
    Data.Vector.Generic.Mutable.Base.MVector
      Data.Vector.Unboxed.Base.MVector MailBox.Square
  DFunId[0]
  {- Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Vector.Unboxed.Base.MVector
                  @ MailBox.Square
                  MailBox.$fMVectorMVectorSquare_$cbasicLength
                  MailBox.$fMVectorMVectorSquare_$cbasicUnsafeSlice
                  MailBox.$fMVectorMVectorSquare_$cbasicOverlaps
                  MailBox.$fMVectorMVectorSquare_$cbasicUnsafeNew
                  MailBox.$fMVectorMVectorSquare_$cbasicInitialize
                  MailBox.$fMVectorMVectorSquare_$cbasicUnsafeReplicate
                  MailBox.$fMVectorMVectorSquare_$cbasicUnsafeRead
                  MailBox.$fMVectorMVectorSquare_$cbasicUnsafeWrite
                  MailBox.$fMVectorMVectorSquare_$cbasicClear
                  MailBox.$fMVectorMVectorSquare_$cbasicSet
                  MailBox.$fMVectorMVectorSquare_$cbasicUnsafeCopy
                  MailBox.$fMVectorMVectorSquare_$cbasicUnsafeMove
                  MailBox.$fMVectorMVectorSquare_$cbasicUnsafeGrow -}
95999ae030c6e75e85d223fd90df7ec1
  $fMVectorMVectorSquare_$cbasicClear ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Unboxed.Base.MVector
      (Control.Monad.Primitive.PrimState m) MailBox.Square
    -> m ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(LLLC(S)L)L),1*U(1*U(A,A,A,1*C1(U),A),A)><L,A>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   ds :: Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m) MailBox.Square ->
                 GHC.Base.return
                   @ m
                   (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                   @ ()
                   GHC.Tuple.()) -}
95999ae030c6e75e85d223fd90df7ec1
  $fMVectorMVectorSquare_$cbasicInitialize ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Unboxed.Base.MVector
      (Control.Monad.Primitive.PrimState m) MailBox.Square
    -> m ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LC(S)),1*U(A,1*C1(U))><S,1*U(U,U,U)>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   ds :: Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m) MailBox.Square ->
                 case ds
                        `cast`
                      (Trans
                           (Sub (MailBox.TFCo:R:MVectorsSquare[0]
                                     <Control.Monad.Primitive.PrimState m>_N))
                           (Trans
                                (MailBox.NTCo:R:MVectorsSquare[0]
                                     <Control.Monad.Primitive.PrimState m>_N)
                                (Trans
                                     (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                               <Control.Monad.Primitive.PrimState m>_N))
                                     (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                          <Control.Monad.Primitive.PrimState
                                             m>_N)))) of wild { Data.Vector.Primitive.Mutable.MVector dt dt1 dt2 ->
                 let {
                   size :: GHC.Types.Int
                   = Data.Vector.Unboxed.Base.$fMVectorMVectorBool_$ssizeOf
                       (GHC.Err.undefined @ GHC.Word.Word8)
                 } in
                 case GHC.Num.$fNumInt_$c*
                        (GHC.Types.I# dt)
                        size of wild1 { GHC.Types.I# doff# ->
                 case GHC.Num.$fNumInt_$c*
                        (GHC.Types.I# dt1)
                        size of wild2 { GHC.Types.I# sz# ->
                 Control.Monad.Primitive.primitive
                   @ m
                   $dPrimMonad
                   @ ()
                   (\ s# :: GHC.Prim.State#
                              (Control.Monad.Primitive.PrimState m)[OneShot] ->
                    case GHC.Word.$cfromInteger
                           __integer 0 of wild4 { GHC.Word.W8# x# ->
                    case GHC.Base.id
                           @ GHC.Types.Int
                           (GHC.Types.I# doff#) of wild5 { GHC.Types.I# x#1 ->
                    case ((Data.Primitive.Internal.Operations.setWord8Array#
                             @ (Control.Monad.Primitive.PrimState m)
                             dt2
                             (GHC.Int.I64# x#1) `cast` (Sym (Foreign.C.Types.NTCo:CPtrdiff[0]))
                             (GHC.Word.W64# (GHC.Prim.int2Word# sz#))
                               `cast`
                             (Sym (Foreign.C.Types.NTCo:CSize[0]))
                             x#)
                            `cast`
                          (Trans
                               (GHC.Types.NTCo:IO[0] <()>_R)
                               ((GHC.Prim.State#
                                   (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R
                                ->_R ((# (GHC.Prim.State#
                                            (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R,
                                         <()>_R #))_R))
                            s#
                              `cast`
                            (GHC.Prim.State#
                               (Trans
                                    (UnivCo mkUnsafeCo nominal (Control.Monad.Primitive.PrimState
                                                                  m) GHC.Prim.RealWorld)
                                    (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0]))))_R)
                           `cast`
                         ((# (GHC.Prim.State#
                                (Trans
                                     (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])
                                     (UnivCo mkUnsafeCo nominal GHC.Prim.RealWorld (Control.Monad.Primitive.PrimState
                                                                                      m))))_R,
                             UnivCo mkUnsafeCo representational () GHC.Prim.Any #))_R of ds1 { (#,#) ipv ipv1 ->
                    (# ipv, GHC.Tuple.() #) } } }) } } }) -}
95999ae030c6e75e85d223fd90df7ec1
  $fMVectorMVectorSquare_$cbasicLength ::
    Data.Vector.Unboxed.Base.MVector s MailBox.Square -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(A,U,A)>m,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                Data.Vector.Unboxed.Base.$fMVectorMVectorBool2
                  `cast`
                (forall s.
                 Trans
                     (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0] <s>_N))
                     (Trans
                          (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                         <s>_N)))
                          (Trans
                               (Sym (MailBox.NTCo:R:MVectorsSquare[0] <s>_N))
                               (Sub (Sym (MailBox.TFCo:R:MVectorsSquare[0] <s>_N)))))
                 ->_R <GHC.Types.Int>_R) -}
95999ae030c6e75e85d223fd90df7ec1
  $fMVectorMVectorSquare_$cbasicOverlaps ::
    Data.Vector.Unboxed.Base.MVector s MailBox.Square
    -> Data.Vector.Unboxed.Base.MVector s MailBox.Square
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(U,U,U)><S,1*U(U,U,U)>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, True)
                Data.Vector.Unboxed.Base.$fMVectorMVectorWord8_$cbasicOverlaps
                  `cast`
                (forall s.
                 Trans
                     (Sym (MailBox.NTCo:R:MVectorsSquare[0] <s>_N))
                     (Sub (Sym (MailBox.TFCo:R:MVectorsSquare[0] <s>_N)))
                 ->_R Trans
                          (Sym (MailBox.NTCo:R:MVectorsSquare[0] <s>_N))
                          (Sub (Sym (MailBox.TFCo:R:MVectorsSquare[0] <s>_N)))
                 ->_R <GHC.Types.Bool>_R) -}
95999ae030c6e75e85d223fd90df7ec1
  $fMVectorMVectorSquare_$cbasicSet ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Unboxed.Base.MVector
      (Control.Monad.Primitive.PrimState m) MailBox.Square
    -> MailBox.Square -> m ()
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(S)),1*U(A,1*C1(U))><S,1*U(U,U,U)><L,U(U)>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   ds :: Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m) MailBox.Square
                   val :: MailBox.Square ->
                 case ds
                        `cast`
                      (Trans
                           (Sub (MailBox.TFCo:R:MVectorsSquare[0]
                                     <Control.Monad.Primitive.PrimState m>_N))
                           (Trans
                                (MailBox.NTCo:R:MVectorsSquare[0]
                                     <Control.Monad.Primitive.PrimState m>_N)
                                (Trans
                                     (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                               <Control.Monad.Primitive.PrimState m>_N))
                                     (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                          <Control.Monad.Primitive.PrimState
                                             m>_N)))) of wild { Data.Vector.Primitive.Mutable.MVector dt dt1 dt2 ->
                 Control.Monad.Primitive.primitive
                   @ m
                   $dPrimMonad
                   @ ()
                   (\ s# :: GHC.Prim.State#
                              (Control.Monad.Primitive.PrimState m)[OneShot] ->
                    case MailBox.unS val of wild1 { GHC.Word.W8# x# ->
                    case GHC.Base.id
                           @ GHC.Types.Int
                           (GHC.Types.I# dt) of wild2 { GHC.Types.I# x#1 ->
                    case ((Data.Primitive.Internal.Operations.setWord8Array#
                             @ (Control.Monad.Primitive.PrimState m)
                             dt2
                             (GHC.Int.I64# x#1) `cast` (Sym (Foreign.C.Types.NTCo:CPtrdiff[0]))
                             (GHC.Word.W64# (GHC.Prim.int2Word# dt1))
                               `cast`
                             (Sym (Foreign.C.Types.NTCo:CSize[0]))
                             x#)
                            `cast`
                          (Trans
                               (GHC.Types.NTCo:IO[0] <()>_R)
                               ((GHC.Prim.State#
                                   (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R
                                ->_R ((# (GHC.Prim.State#
                                            (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R,
                                         <()>_R #))_R))
                            s#
                              `cast`
                            (GHC.Prim.State#
                               (Trans
                                    (UnivCo mkUnsafeCo nominal (Control.Monad.Primitive.PrimState
                                                                  m) GHC.Prim.RealWorld)
                                    (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0]))))_R)
                           `cast`
                         ((# (GHC.Prim.State#
                                (Trans
                                     (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])
                                     (UnivCo mkUnsafeCo nominal GHC.Prim.RealWorld (Control.Monad.Primitive.PrimState
                                                                                      m))))_R,
                             UnivCo mkUnsafeCo representational () GHC.Prim.Any #))_R of ds1 { (#,#) ipv ipv1 ->
                    (# ipv, GHC.Tuple.() #) } } }) }) -}
95999ae030c6e75e85d223fd90df7ec1
  $fMVectorMVectorSquare_$cbasicUnsafeCopy ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Unboxed.Base.MVector
      (Control.Monad.Primitive.PrimState m) MailBox.Square
    -> Data.Vector.Unboxed.Base.MVector
         (Control.Monad.Primitive.PrimState m) MailBox.Square
    -> m ()
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(S)),1*U(A,1*C1(U))><S,1*U(U,U,U)><S,1*U(U,A,U)>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   ds :: Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m) MailBox.Square
                   ds1 :: Data.Vector.Unboxed.Base.MVector
                            (Control.Monad.Primitive.PrimState m) MailBox.Square ->
                 case ds
                        `cast`
                      (Trans
                           (Sub (MailBox.TFCo:R:MVectorsSquare[0]
                                     <Control.Monad.Primitive.PrimState m>_N))
                           (Trans
                                (MailBox.NTCo:R:MVectorsSquare[0]
                                     <Control.Monad.Primitive.PrimState m>_N)
                                (Trans
                                     (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                               <Control.Monad.Primitive.PrimState m>_N))
                                     (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                          <Control.Monad.Primitive.PrimState
                                             m>_N)))) of wild { Data.Vector.Primitive.Mutable.MVector dt dt1 dt2 ->
                 case ds1
                        `cast`
                      (Trans
                           (Sub (MailBox.TFCo:R:MVectorsSquare[0]
                                     <Control.Monad.Primitive.PrimState m>_N))
                           (Trans
                                (MailBox.NTCo:R:MVectorsSquare[0]
                                     <Control.Monad.Primitive.PrimState m>_N)
                                (Trans
                                     (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                               <Control.Monad.Primitive.PrimState m>_N))
                                     (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                          <Control.Monad.Primitive.PrimState
                                             m>_N)))) of wild1 { Data.Vector.Primitive.Mutable.MVector dt3 dt4 dt5 ->
                 let {
                   sz :: GHC.Types.Int
                   = Data.Vector.Unboxed.Base.$fMVectorMVectorBool_$ssizeOf
                       (GHC.Err.undefined @ GHC.Word.Word8)
                 } in
                 Control.Monad.Primitive.primitive
                   @ m
                   $dPrimMonad
                   @ ()
                   (\ s# :: GHC.Prim.State#
                              (Control.Monad.Primitive.PrimState m)[OneShot] ->
                    case Data.Primitive.ByteArray.unI#
                           (GHC.Num.$fNumInt_$c* (GHC.Types.I# dt1) sz) of wild2 { DEFAULT ->
                    case Data.Primitive.ByteArray.unI#
                           (GHC.Num.$fNumInt_$c* (GHC.Types.I# dt) sz) of wild3 { DEFAULT ->
                    case Data.Primitive.ByteArray.unI#
                           (GHC.Num.$fNumInt_$c* (GHC.Types.I# dt3) sz) of wild4 { DEFAULT ->
                    case GHC.Prim.copyMutableByteArray#
                           @ (Control.Monad.Primitive.PrimState m)
                           dt5
                           wild4
                           dt2
                           wild3
                           wild2
                           s# of s'# { DEFAULT ->
                    (# s'#, GHC.Tuple.() #) } } } }) } }) -}
95999ae030c6e75e85d223fd90df7ec1
  $fMVectorMVectorSquare_$cbasicUnsafeGrow ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Unboxed.Base.MVector
      (Control.Monad.Primitive.PrimState m) MailBox.Square
    -> GHC.Types.Int
    -> m (Data.Vector.Unboxed.Base.MVector
            (Control.Monad.Primitive.PrimState m) MailBox.Square)
  {- Arity: 3, Strictness: <S(SL),U(U,C(U))><L,U(U,U,U)><L,1*U(U)>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   eta :: Data.Vector.Unboxed.Base.MVector
                            (Control.Monad.Primitive.PrimState m) MailBox.Square
                   eta1 :: GHC.Types.Int ->
                 GHC.Base.liftM
                   @ (Data.Vector.Unboxed.Base.MVector
                        (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                   @ (Data.Vector.Unboxed.Base.MVector
                        (Control.Monad.Primitive.PrimState m) MailBox.Square)
                   @ m
                   (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                   (\ tpl :: Data.Vector.Unboxed.Base.MVector
                               (Control.Monad.Primitive.PrimState m) GHC.Word.Word8 ->
                    tpl)
                     `cast`
                   (<Data.Vector.Unboxed.Base.MVector
                       (Control.Monad.Primitive.PrimState m) GHC.Word.Word8>_R
                    ->_R Trans
                             (Sym (MailBox.NTCo:R:MVectorsSquare[0]
                                       <Control.Monad.Primitive.PrimState m>_N))
                             (Sub (Sym (MailBox.TFCo:R:MVectorsSquare[0]
                                            <Control.Monad.Primitive.PrimState m>_N))))
                   (GHC.Base.liftM
                      @ (Data.Vector.Primitive.Mutable.MVector
                           (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                      @ (Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                      @ m
                      (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                      (\ tpl :: Data.Vector.Primitive.Mutable.MVector
                                  (Control.Monad.Primitive.PrimState m) GHC.Word.Word8 ->
                       tpl)
                        `cast`
                      (<Data.Vector.Primitive.Mutable.MVector
                          (Control.Monad.Primitive.PrimState m) GHC.Word.Word8>_R
                       ->_R Trans
                                (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                          <Control.Monad.Primitive.PrimState m>_N))
                                (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                               <Control.Monad.Primitive.PrimState m>_N))))
                      (let {
                         $dMonad :: GHC.Base.Monad m
                         = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                       } in
                       let {
                         n :: GHC.Types.Int
                         = Data.Vector.Unboxed.Base.$fMVectorMVectorBool2
                             @ (Control.Monad.Primitive.PrimState m)
                             eta
                               `cast`
                             (Trans
                                  (Sub (MailBox.TFCo:R:MVectorsSquare[0]
                                            <Control.Monad.Primitive.PrimState m>_N))
                                  (Trans
                                       (MailBox.NTCo:R:MVectorsSquare[0]
                                            <Control.Monad.Primitive.PrimState m>_N)
                                       (Trans
                                            (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                                      <Control.Monad.Primitive.PrimState m>_N))
                                            (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                                 <Control.Monad.Primitive.PrimState m>_N))))
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (Data.Vector.Primitive.Mutable.MVector
                              (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                         @ (Data.Vector.Primitive.Mutable.MVector
                              (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                         (let {
                            size :: GHC.Types.Int
                            = Data.Vector.Unboxed.Base.$fMVectorMVectorBool_$ssizeOf
                                (GHC.Err.undefined @ GHC.Word.Word8)
                          } in
                          case GHC.Num.$fNumInt_$c+ n eta1 of wild { GHC.Types.I# x ->
                          case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.<# x 0) of wild1 {
                            GHC.Types.False
                            -> case GHC.Real.$fIntegralInt_$cdiv
                                      GHC.Base.maxInt
                                      size of wild2 { GHC.Types.I# y ->
                               case GHC.Prim.tagToEnum#
                                      @ GHC.Types.Bool
                                      (GHC.Prim.># x y) of wild3 {
                                 GHC.Types.False
                                 -> GHC.Base.liftM
                                      @ (Data.Primitive.ByteArray.MutableByteArray
                                           (Control.Monad.Primitive.PrimState m))
                                      @ (Data.Vector.Primitive.Mutable.MVector
                                           (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                                      @ m
                                      (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                                      (Data.Vector.Primitive.Mutable.$WMVector
                                         @ (Control.Monad.Primitive.PrimState m)
                                         @ GHC.Word.Word8
                                         (GHC.Types.I# 0)
                                         wild)
                                      (case GHC.Num.$fNumInt_$c*
                                              wild
                                              size of wild4 { GHC.Types.I# n# ->
                                       Control.Monad.Primitive.primitive
                                         @ m
                                         $dPrimMonad
                                         @ (Data.Primitive.ByteArray.MutableByteArray
                                              (Control.Monad.Primitive.PrimState m))
                                         (\ s# :: GHC.Prim.State#
                                                    (Control.Monad.Primitive.PrimState
                                                       m)[OneShot] ->
                                          case GHC.Prim.newByteArray#
                                                 @ (Control.Monad.Primitive.PrimState m)
                                                 n#
                                                 s# of ds1 { (#,#) ipv ipv1 ->
                                          (# ipv,
                                             Data.Primitive.ByteArray.MutableByteArray
                                               @ (Control.Monad.Primitive.PrimState m)
                                               ipv1 #) }) })
                                 GHC.Types.True
                                 -> GHC.Base.$
                                      @ [GHC.Types.Char]
                                      @ (m (Data.Vector.Primitive.Mutable.MVector
                                              (Control.Monad.Primitive.PrimState m) GHC.Word.Word8))
                                      (GHC.Err.error
                                         @ (m (Data.Vector.Primitive.Mutable.MVector
                                                 (Control.Monad.Primitive.PrimState m)
                                                 GHC.Word.Word8)))
                                      (GHC.Base.augment
                                         @ GHC.Types.Char
                                         (\ @ b
                                            c :: GHC.Types.Char -> b -> b[OneShot]
                                            n1 :: b[OneShot] ->
                                          GHC.CString.unpackFoldrCString#
                                            @ b
                                            "Primitive.basicUnsafeNew: length to large: "#
                                            c
                                            n1)
                                         (GHC.Show.$fShowInt_$cshow wild)) } }
                            GHC.Types.True
                            -> GHC.Base.$
                                 @ [GHC.Types.Char]
                                 @ (m (Data.Vector.Primitive.Mutable.MVector
                                         (Control.Monad.Primitive.PrimState m) GHC.Word.Word8))
                                 (GHC.Err.error
                                    @ (m (Data.Vector.Primitive.Mutable.MVector
                                            (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)))
                                 (GHC.Base.augment
                                    @ GHC.Types.Char
                                    (\ @ b
                                       c :: GHC.Types.Char -> b -> b[OneShot]
                                       n1 :: b[OneShot] ->
                                     GHC.CString.unpackFoldrCString#
                                       @ b
                                       "Primitive.basicUnsafeNew: negative length: "#
                                       c
                                       n1)
                                    (GHC.Show.$fShowInt_$cshow wild)) } })
                         (\ v' :: Data.Vector.Primitive.Mutable.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Word.Word8 ->
                          GHC.Base.>>
                            @ m
                            $dMonad
                            @ ()
                            @ (Data.Vector.Primitive.Mutable.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                            (case Data.Vector.Unboxed.Base.$fMVectorMVectorBool1
                                    @ (Control.Monad.Primitive.PrimState m)
                                    (GHC.Types.I# 0)
                                    n
                                    v' of wild { Data.Vector.Primitive.Mutable.MVector dt dt1 dt2 ->
                             case eta
                                    `cast`
                                  (Trans
                                       (Sub (MailBox.TFCo:R:MVectorsSquare[0]
                                                 <Control.Monad.Primitive.PrimState m>_N))
                                       (Trans
                                            (MailBox.NTCo:R:MVectorsSquare[0]
                                                 <Control.Monad.Primitive.PrimState m>_N)
                                            (Trans
                                                 (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                                           <Control.Monad.Primitive.PrimState m>_N))
                                                 (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                                      <Control.Monad.Primitive.PrimState
                                                         m>_N)))) of wild1 { Data.Vector.Primitive.Mutable.MVector dt3 dt4 dt5 ->
                             let {
                               sz :: GHC.Types.Int
                               = Data.Vector.Unboxed.Base.$fMVectorMVectorBool_$ssizeOf
                                   (GHC.Err.undefined @ GHC.Word.Word8)
                             } in
                             Control.Monad.Primitive.primitive
                               @ m
                               $dPrimMonad
                               @ ()
                               (\ s# :: GHC.Prim.State#
                                          (Control.Monad.Primitive.PrimState m)[OneShot] ->
                                case Data.Primitive.ByteArray.unI#
                                       (GHC.Num.$fNumInt_$c*
                                          (GHC.Types.I# dt1)
                                          sz) of wild2 { DEFAULT ->
                                case Data.Primitive.ByteArray.unI#
                                       (GHC.Num.$fNumInt_$c*
                                          (GHC.Types.I# dt)
                                          sz) of wild3 { DEFAULT ->
                                case Data.Primitive.ByteArray.unI#
                                       (GHC.Num.$fNumInt_$c*
                                          (GHC.Types.I# dt3)
                                          sz) of wild4 { DEFAULT ->
                                case GHC.Prim.copyMutableByteArray#
                                       @ (Control.Monad.Primitive.PrimState m)
                                       dt5
                                       wild4
                                       dt2
                                       wild3
                                       wild2
                                       s# of s'# { DEFAULT ->
                                (# s'#, GHC.Tuple.() #) } } } }) } })
                            (GHC.Base.return
                               @ m
                               $dMonad
                               @ (Data.Vector.Primitive.Mutable.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                               v'))))) -}
95999ae030c6e75e85d223fd90df7ec1
  $fMVectorMVectorSquare_$cbasicUnsafeMove ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Unboxed.Base.MVector
      (Control.Monad.Primitive.PrimState m) MailBox.Square
    -> Data.Vector.Unboxed.Base.MVector
         (Control.Monad.Primitive.PrimState m) MailBox.Square
    -> m ()
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(S)),1*U(A,1*C1(U))><S,1*U(U,U,U)><S,1*U(U,A,U)>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, True)
                Data.Vector.Unboxed.Base.$fMVectorMVectorWord8_$cbasicUnsafeMove
                  `cast`
                (forall (m :: * -> *).
                 <Control.Monad.Primitive.PrimMonad m>_R
                 ->_R Trans
                          (Sym (MailBox.NTCo:R:MVectorsSquare[0]
                                    <Control.Monad.Primitive.PrimState m>_N))
                          (Sub (Sym (MailBox.TFCo:R:MVectorsSquare[0]
                                         <Control.Monad.Primitive.PrimState m>_N)))
                 ->_R Trans
                          (Sym (MailBox.NTCo:R:MVectorsSquare[0]
                                    <Control.Monad.Primitive.PrimState m>_N))
                          (Sub (Sym (MailBox.TFCo:R:MVectorsSquare[0]
                                         <Control.Monad.Primitive.PrimState m>_N)))
                 ->_R <m ()>_R) -}
95999ae030c6e75e85d223fd90df7ec1
  $fMVectorMVectorSquare_$cbasicUnsafeNew ::
    Control.Monad.Primitive.PrimMonad m =>
    GHC.Types.Int
    -> m (Data.Vector.Unboxed.Base.MVector
            (Control.Monad.Primitive.PrimState m) MailBox.Square)
  {- Arity: 2, Strictness: <S(SL),U(U,1*C1(U))><L,1*U(U)>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   eta :: GHC.Types.Int ->
                 GHC.Base.liftM
                   @ (Data.Vector.Unboxed.Base.MVector
                        (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                   @ (Data.Vector.Unboxed.Base.MVector
                        (Control.Monad.Primitive.PrimState m) MailBox.Square)
                   @ m
                   (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                   (\ tpl :: Data.Vector.Unboxed.Base.MVector
                               (Control.Monad.Primitive.PrimState m) GHC.Word.Word8 ->
                    tpl)
                     `cast`
                   (<Data.Vector.Unboxed.Base.MVector
                       (Control.Monad.Primitive.PrimState m) GHC.Word.Word8>_R
                    ->_R Trans
                             (Sym (MailBox.NTCo:R:MVectorsSquare[0]
                                       <Control.Monad.Primitive.PrimState m>_N))
                             (Sub (Sym (MailBox.TFCo:R:MVectorsSquare[0]
                                            <Control.Monad.Primitive.PrimState m>_N))))
                   (GHC.Base.liftM
                      @ (Data.Vector.Primitive.Mutable.MVector
                           (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                      @ (Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                      @ m
                      (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                      (\ tpl :: Data.Vector.Primitive.Mutable.MVector
                                  (Control.Monad.Primitive.PrimState m) GHC.Word.Word8 ->
                       tpl)
                        `cast`
                      (<Data.Vector.Primitive.Mutable.MVector
                          (Control.Monad.Primitive.PrimState m) GHC.Word.Word8>_R
                       ->_R Trans
                                (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                          <Control.Monad.Primitive.PrimState m>_N))
                                (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                               <Control.Monad.Primitive.PrimState m>_N))))
                      (let {
                         size :: GHC.Types.Int
                         = Data.Vector.Unboxed.Base.$fMVectorMVectorBool_$ssizeOf
                             (GHC.Err.undefined @ GHC.Word.Word8)
                       } in
                       case eta of wild { GHC.Types.I# x ->
                       case GHC.Prim.tagToEnum#
                              @ GHC.Types.Bool
                              (GHC.Prim.<# x 0) of wild1 {
                         GHC.Types.False
                         -> case GHC.Real.$fIntegralInt_$cdiv
                                   GHC.Base.maxInt
                                   size of wild2 { GHC.Types.I# y ->
                            case GHC.Prim.tagToEnum#
                                   @ GHC.Types.Bool
                                   (GHC.Prim.># x y) of wild3 {
                              GHC.Types.False
                              -> GHC.Base.liftM
                                   @ (Data.Primitive.ByteArray.MutableByteArray
                                        (Control.Monad.Primitive.PrimState m))
                                   @ (Data.Vector.Primitive.Mutable.MVector
                                        (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                                   @ m
                                   (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                                   (Data.Vector.Primitive.Mutable.$WMVector
                                      @ (Control.Monad.Primitive.PrimState m)
                                      @ GHC.Word.Word8
                                      (GHC.Types.I# 0)
                                      wild)
                                   (case GHC.Num.$fNumInt_$c*
                                           wild
                                           size of wild4 { GHC.Types.I# n# ->
                                    Control.Monad.Primitive.primitive
                                      @ m
                                      $dPrimMonad
                                      @ (Data.Primitive.ByteArray.MutableByteArray
                                           (Control.Monad.Primitive.PrimState m))
                                      (\ s# :: GHC.Prim.State#
                                                 (Control.Monad.Primitive.PrimState m)[OneShot] ->
                                       case GHC.Prim.newByteArray#
                                              @ (Control.Monad.Primitive.PrimState m)
                                              n#
                                              s# of ds1 { (#,#) ipv ipv1 ->
                                       (# ipv,
                                          Data.Primitive.ByteArray.MutableByteArray
                                            @ (Control.Monad.Primitive.PrimState m)
                                            ipv1 #) }) })
                              GHC.Types.True
                              -> GHC.Base.$
                                   @ [GHC.Types.Char]
                                   @ (m (Data.Vector.Primitive.Mutable.MVector
                                           (Control.Monad.Primitive.PrimState m) GHC.Word.Word8))
                                   (GHC.Err.error
                                      @ (m (Data.Vector.Primitive.Mutable.MVector
                                              (Control.Monad.Primitive.PrimState m)
                                              GHC.Word.Word8)))
                                   (GHC.Base.augment
                                      @ GHC.Types.Char
                                      (\ @ b
                                         c :: GHC.Types.Char -> b -> b[OneShot]
                                         n :: b[OneShot] ->
                                       GHC.CString.unpackFoldrCString#
                                         @ b
                                         "Primitive.basicUnsafeNew: length to large: "#
                                         c
                                         n)
                                      (GHC.Show.$fShowInt_$cshow wild)) } }
                         GHC.Types.True
                         -> GHC.Base.$
                              @ [GHC.Types.Char]
                              @ (m (Data.Vector.Primitive.Mutable.MVector
                                      (Control.Monad.Primitive.PrimState m) GHC.Word.Word8))
                              (GHC.Err.error
                                 @ (m (Data.Vector.Primitive.Mutable.MVector
                                         (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)))
                              (GHC.Base.augment
                                 @ GHC.Types.Char
                                 (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                                  GHC.CString.unpackFoldrCString#
                                    @ b
                                    "Primitive.basicUnsafeNew: negative length: "#
                                    c
                                    n)
                                 (GHC.Show.$fShowInt_$cshow wild)) } }))) -}
95999ae030c6e75e85d223fd90df7ec1
  $fMVectorMVectorSquare_$cbasicUnsafeRead ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Unboxed.Base.MVector
      (Control.Monad.Primitive.PrimState m) MailBox.Square
    -> GHC.Types.Int -> m MailBox.Square
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(SL),U(1*U,1*C1(U))><L,1*U(U,A,U)><L,1*U(U)>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   eta :: Data.Vector.Unboxed.Base.MVector
                            (Control.Monad.Primitive.PrimState m) MailBox.Square
                   eta1 :: GHC.Types.Int ->
                 GHC.Base.liftM
                   @ GHC.Word.Word8
                   @ MailBox.Square
                   @ m
                   (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                   (\ tpl :: GHC.Word.Word8 -> tpl)
                     `cast`
                   (<GHC.Word.Word8>_R ->_R Sym (MailBox.NTCo:Square[0]))
                   (case eta
                           `cast`
                         (Trans
                              (Sub (MailBox.TFCo:R:MVectorsSquare[0]
                                        <Control.Monad.Primitive.PrimState m>_N))
                              (Trans
                                   (MailBox.NTCo:R:MVectorsSquare[0]
                                        <Control.Monad.Primitive.PrimState m>_N)
                                   (Trans
                                        (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                                  <Control.Monad.Primitive.PrimState m>_N))
                                        (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                             <Control.Monad.Primitive.PrimState
                                                m>_N)))) of wild { Data.Vector.Primitive.Mutable.MVector dt dt1 dt2 ->
                    case GHC.Num.$fNumInt_$c+
                           (GHC.Types.I# dt)
                           eta1 of wild1 { GHC.Types.I# i# ->
                    Control.Monad.Primitive.primitive
                      @ m
                      $dPrimMonad
                      @ GHC.Word.Word8
                      (Data.Primitive.Types.$fPrimWord8_$creadByteArray#
                         @ (Control.Monad.Primitive.PrimState m)
                         dt2
                         i#) } })) -}
95999ae030c6e75e85d223fd90df7ec1
  $fMVectorMVectorSquare_$cbasicUnsafeReplicate ::
    Control.Monad.Primitive.PrimMonad m =>
    GHC.Types.Int
    -> MailBox.Square
    -> m (Data.Vector.Unboxed.Base.MVector
            (Control.Monad.Primitive.PrimState m) MailBox.Square)
  {- Arity: 3, Strictness: <S(SL),U(U,C(U))><L,1*U(U)><L,U(U)>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   eta :: GHC.Types.Int
                   eta1 :: MailBox.Square ->
                 GHC.Base.liftM
                   @ (Data.Vector.Unboxed.Base.MVector
                        (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                   @ (Data.Vector.Unboxed.Base.MVector
                        (Control.Monad.Primitive.PrimState m) MailBox.Square)
                   @ m
                   (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                   (\ tpl :: Data.Vector.Unboxed.Base.MVector
                               (Control.Monad.Primitive.PrimState m) GHC.Word.Word8 ->
                    tpl)
                     `cast`
                   (<Data.Vector.Unboxed.Base.MVector
                       (Control.Monad.Primitive.PrimState m) GHC.Word.Word8>_R
                    ->_R Trans
                             (Sym (MailBox.NTCo:R:MVectorsSquare[0]
                                       <Control.Monad.Primitive.PrimState m>_N))
                             (Sub (Sym (MailBox.TFCo:R:MVectorsSquare[0]
                                            <Control.Monad.Primitive.PrimState m>_N))))
                   (let {
                      eta2 :: GHC.Word.Word8 = MailBox.unS eta1
                    } in
                    GHC.Base.liftM
                      @ (Data.Vector.Primitive.Mutable.MVector
                           (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                      @ (Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                      @ m
                      (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                      (\ tpl :: Data.Vector.Primitive.Mutable.MVector
                                  (Control.Monad.Primitive.PrimState m) GHC.Word.Word8 ->
                       tpl)
                        `cast`
                      (<Data.Vector.Primitive.Mutable.MVector
                          (Control.Monad.Primitive.PrimState m) GHC.Word.Word8>_R
                       ->_R Trans
                                (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                          <Control.Monad.Primitive.PrimState m>_N))
                                (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                               <Control.Monad.Primitive.PrimState m>_N))))
                      (let {
                         $dMonad :: GHC.Base.Monad m
                         = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                       } in
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (Data.Vector.Primitive.Mutable.MVector
                              (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                         @ (Data.Vector.Primitive.Mutable.MVector
                              (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                         (let {
                            size :: GHC.Types.Int
                            = Data.Vector.Unboxed.Base.$fMVectorMVectorBool_$ssizeOf
                                (GHC.Err.undefined @ GHC.Word.Word8)
                          } in
                          case eta of wild { GHC.Types.I# x ->
                          case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.<# x 0) of wild1 {
                            GHC.Types.False
                            -> case GHC.Real.$fIntegralInt_$cdiv
                                      GHC.Base.maxInt
                                      size of wild2 { GHC.Types.I# y ->
                               case GHC.Prim.tagToEnum#
                                      @ GHC.Types.Bool
                                      (GHC.Prim.># x y) of wild3 {
                                 GHC.Types.False
                                 -> GHC.Base.liftM
                                      @ (Data.Primitive.ByteArray.MutableByteArray
                                           (Control.Monad.Primitive.PrimState m))
                                      @ (Data.Vector.Primitive.Mutable.MVector
                                           (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                                      @ m
                                      (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                                      (Data.Vector.Primitive.Mutable.$WMVector
                                         @ (Control.Monad.Primitive.PrimState m)
                                         @ GHC.Word.Word8
                                         (GHC.Types.I# 0)
                                         wild)
                                      (case GHC.Num.$fNumInt_$c*
                                              wild
                                              size of wild4 { GHC.Types.I# n# ->
                                       Control.Monad.Primitive.primitive
                                         @ m
                                         $dPrimMonad
                                         @ (Data.Primitive.ByteArray.MutableByteArray
                                              (Control.Monad.Primitive.PrimState m))
                                         (\ s# :: GHC.Prim.State#
                                                    (Control.Monad.Primitive.PrimState
                                                       m)[OneShot] ->
                                          case GHC.Prim.newByteArray#
                                                 @ (Control.Monad.Primitive.PrimState m)
                                                 n#
                                                 s# of ds1 { (#,#) ipv ipv1 ->
                                          (# ipv,
                                             Data.Primitive.ByteArray.MutableByteArray
                                               @ (Control.Monad.Primitive.PrimState m)
                                               ipv1 #) }) })
                                 GHC.Types.True
                                 -> GHC.Base.$
                                      @ [GHC.Types.Char]
                                      @ (m (Data.Vector.Primitive.Mutable.MVector
                                              (Control.Monad.Primitive.PrimState m) GHC.Word.Word8))
                                      (GHC.Err.error
                                         @ (m (Data.Vector.Primitive.Mutable.MVector
                                                 (Control.Monad.Primitive.PrimState m)
                                                 GHC.Word.Word8)))
                                      (GHC.Base.augment
                                         @ GHC.Types.Char
                                         (\ @ b
                                            c :: GHC.Types.Char -> b -> b[OneShot]
                                            n :: b[OneShot] ->
                                          GHC.CString.unpackFoldrCString#
                                            @ b
                                            "Primitive.basicUnsafeNew: length to large: "#
                                            c
                                            n)
                                         (GHC.Show.$fShowInt_$cshow wild)) } }
                            GHC.Types.True
                            -> GHC.Base.$
                                 @ [GHC.Types.Char]
                                 @ (m (Data.Vector.Primitive.Mutable.MVector
                                         (Control.Monad.Primitive.PrimState m) GHC.Word.Word8))
                                 (GHC.Err.error
                                    @ (m (Data.Vector.Primitive.Mutable.MVector
                                            (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)))
                                 (GHC.Base.augment
                                    @ GHC.Types.Char
                                    (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                                     GHC.CString.unpackFoldrCString#
                                       @ b
                                       "Primitive.basicUnsafeNew: negative length: "#
                                       c
                                       n)
                                    (GHC.Show.$fShowInt_$cshow wild)) } })
                         (\ v1 :: Data.Vector.Primitive.Mutable.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Word.Word8 ->
                          GHC.Base.>>
                            @ m
                            $dMonad
                            @ ()
                            @ (Data.Vector.Primitive.Mutable.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                            (case v1 of wild { Data.Vector.Primitive.Mutable.MVector dt dt1 dt2 ->
                             Control.Monad.Primitive.primitive
                               @ m
                               $dPrimMonad
                               @ ()
                               (\ s# :: GHC.Prim.State#
                                          (Control.Monad.Primitive.PrimState m)[OneShot] ->
                                case eta2 of wild1 { GHC.Word.W8# x# ->
                                case GHC.Base.id
                                       @ GHC.Types.Int
                                       (GHC.Types.I# dt) of wild2 { GHC.Types.I# x#1 ->
                                case ((Data.Primitive.Internal.Operations.setWord8Array#
                                         @ (Control.Monad.Primitive.PrimState m)
                                         dt2
                                         (GHC.Int.I64# x#1)
                                           `cast`
                                         (Sym (Foreign.C.Types.NTCo:CPtrdiff[0]))
                                         (GHC.Word.W64# (GHC.Prim.int2Word# dt1))
                                           `cast`
                                         (Sym (Foreign.C.Types.NTCo:CSize[0]))
                                         x#)
                                        `cast`
                                      (Trans
                                           (GHC.Types.NTCo:IO[0] <()>_R)
                                           ((GHC.Prim.State#
                                               (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R
                                            ->_R ((# (GHC.Prim.State#
                                                        (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R,
                                                     <()>_R #))_R))
                                        s#
                                          `cast`
                                        (GHC.Prim.State#
                                           (Trans
                                                (UnivCo mkUnsafeCo nominal (Control.Monad.Primitive.PrimState
                                                                              m) GHC.Prim.RealWorld)
                                                (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0]))))_R)
                                       `cast`
                                     ((# (GHC.Prim.State#
                                            (Trans
                                                 (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])
                                                 (UnivCo mkUnsafeCo nominal GHC.Prim.RealWorld (Control.Monad.Primitive.PrimState
                                                                                                  m))))_R,
                                         UnivCo mkUnsafeCo representational () GHC.Prim.Any #))_R of ds1 { (#,#) ipv ipv1 ->
                                (# ipv, GHC.Tuple.() #) } } }) })
                            (GHC.Base.return
                               @ m
                               $dMonad
                               @ (Data.Vector.Primitive.Mutable.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                               v1))))) -}
95999ae030c6e75e85d223fd90df7ec1
  $fMVectorMVectorSquare_$cbasicUnsafeSlice ::
    GHC.Types.Int
    -> GHC.Types.Int
    -> Data.Vector.Unboxed.Base.MVector s MailBox.Square
    -> Data.Vector.Unboxed.Base.MVector s MailBox.Square
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,1*U(U)><S,1*U(U)><S,1*U(U,A,U)>m,
     Inline: INLINE (sat-args=3),
     Unfolding: InlineRule (3, False, True)
                Data.Vector.Unboxed.Base.$fMVectorMVectorWord8_$cbasicUnsafeSlice
                  `cast`
                (forall s.
                 <GHC.Types.Int>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R Trans
                          (Sym (MailBox.NTCo:R:MVectorsSquare[0] <s>_N))
                          (Sub (Sym (MailBox.TFCo:R:MVectorsSquare[0] <s>_N)))
                 ->_R Trans
                          (Sym (MailBox.NTCo:R:MVectorsSquare[0] <s>_N))
                          (Sub (Sym (MailBox.TFCo:R:MVectorsSquare[0] <s>_N)))) -}
95999ae030c6e75e85d223fd90df7ec1
  $fMVectorMVectorSquare_$cbasicUnsafeWrite ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Unboxed.Base.MVector
      (Control.Monad.Primitive.PrimState m) MailBox.Square
    -> GHC.Types.Int -> MailBox.Square -> m ()
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(LC(S)),1*U(A,1*C1(U))><S,1*U(U,A,U)><S,1*U(U)><L,U(U)>,
     Inline: INLINE (sat-args=3),
     Unfolding: InlineRule (3, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   ds :: Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m) MailBox.Square
                   idx :: GHC.Types.Int
                   val :: MailBox.Square ->
                 case ds
                        `cast`
                      (Trans
                           (Sub (MailBox.TFCo:R:MVectorsSquare[0]
                                     <Control.Monad.Primitive.PrimState m>_N))
                           (Trans
                                (MailBox.NTCo:R:MVectorsSquare[0]
                                     <Control.Monad.Primitive.PrimState m>_N)
                                (Trans
                                     (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                               <Control.Monad.Primitive.PrimState m>_N))
                                     (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                          <Control.Monad.Primitive.PrimState
                                             m>_N)))) of wild { Data.Vector.Primitive.Mutable.MVector dt dt1 dt2 ->
                 case GHC.Num.$fNumInt_$c+
                        (GHC.Types.I# dt)
                        idx of wild1 { GHC.Types.I# i# ->
                 Control.Monad.Primitive.primitive
                   @ m
                   $dPrimMonad
                   @ ()
                   (\ s# :: GHC.Prim.State#
                              (Control.Monad.Primitive.PrimState m)[OneShot] ->
                    case MailBox.unS val of wild2 { GHC.Word.W8# x# ->
                    case GHC.Prim.writeWord8Array#
                           @ (Control.Monad.Primitive.PrimState m)
                           dt2
                           i#
                           x#
                           s# of s'# { DEFAULT ->
                    (# s'#, GHC.Tuple.() #) } }) } }) -}
95999ae030c6e75e85d223fd90df7ec1
  $fUnboxSquare :: Data.Vector.Unboxed.Base.Unbox MailBox.Square
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ MailBox.Square
                  MailBox.$fVectorVectorSquare
                  MailBox.$fMVectorMVectorSquare -}
95999ae030c6e75e85d223fd90df7ec1
  $fVectorVectorSquare ::
    Data.Vector.Generic.Base.Vector
      Data.Vector.Unboxed.Base.Vector MailBox.Square
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Vector.Unboxed.Base.Vector
                  @ MailBox.Square
                  MailBox.$fMVectorMVectorSquare
                    `cast`
                  (Data.Vector.Generic.Mutable.Base.MVector
                     (Sym (Data.Vector.Unboxed.Base.TFCo:R:MutableVector[0]))
                     <MailBox.Square>_N)_R
                  MailBox.$fVectorVectorSquare_$cbasicUnsafeFreeze
                  MailBox.$fVectorVectorSquare_$cbasicUnsafeThaw
                  MailBox.$fVectorVectorSquare_$cbasicLength
                  MailBox.$fVectorVectorSquare_$cbasicUnsafeSlice
                  MailBox.$fVectorVectorSquare_$cbasicUnsafeIndexM
                  MailBox.$fVectorVectorSquare_$cbasicUnsafeCopy
                  MailBox.$fVectorVectorSquare_$celemseq -}
95999ae030c6e75e85d223fd90df7ec1
  $fVectorVectorSquare_$cbasicLength ::
    Data.Vector.Unboxed.Base.Vector MailBox.Square -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(A,U,A)>m,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                Data.Vector.Unboxed.Base.$fVectorVectorWord8_$cbasicLength
                  `cast`
                (Trans
                     (Sym (MailBox.NTCo:R:VectorSquare[0]))
                     (Sub (Sym (MailBox.TFCo:R:VectorSquare[0])))
                 ->_R <GHC.Types.Int>_R) -}
95999ae030c6e75e85d223fd90df7ec1
  $fVectorVectorSquare_$cbasicUnsafeCopy ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Generic.Base.Mutable
      Data.Vector.Unboxed.Base.Vector
      (Control.Monad.Primitive.PrimState m)
      MailBox.Square
    -> Data.Vector.Unboxed.Base.Vector MailBox.Square -> m ()
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(S)),1*U(A,1*C1(U))><S,1*U(U,U,U)><S,1*U(U,A,U)>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, True)
                Data.Vector.Unboxed.Base.$fVectorVectorWord8_$cbasicUnsafeCopy
                  `cast`
                (forall (m :: * -> *).
                 <Control.Monad.Primitive.PrimMonad m>_R
                 ->_R Trans
                          (Sub (Data.Vector.Unboxed.Base.TFCo:R:MutableVector[0]) <Control.Monad.Primitive.PrimState
                                                                                     m>_N <GHC.Word.Word8>_N)
                          (Trans
                               (Sym (MailBox.NTCo:R:MVectorsSquare[0]
                                         <Control.Monad.Primitive.PrimState m>_N))
                               (Trans
                                    (Sub (Sym (MailBox.TFCo:R:MVectorsSquare[0]
                                                   <Control.Monad.Primitive.PrimState m>_N)))
                                    (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MutableVector[0])) <Control.Monad.Primitive.PrimState
                                                                                                     m>_N <MailBox.Square>_N)))
                 ->_R Trans
                          (Sym (MailBox.NTCo:R:VectorSquare[0]))
                          (Sub (Sym (MailBox.TFCo:R:VectorSquare[0])))
                 ->_R <m ()>_R) -}
95999ae030c6e75e85d223fd90df7ec1
  $fVectorVectorSquare_$cbasicUnsafeFreeze ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Generic.Base.Mutable
      Data.Vector.Unboxed.Base.Vector
      (Control.Monad.Primitive.PrimState m)
      MailBox.Square
    -> m (Data.Vector.Unboxed.Base.Vector MailBox.Square)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),U(U,1*C1(U))><L,1*U(U,U,U)>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   eta :: Data.Vector.Generic.Base.Mutable
                            Data.Vector.Unboxed.Base.Vector
                            (Control.Monad.Primitive.PrimState m)
                            MailBox.Square ->
                 GHC.Base.liftM
                   @ (Data.Vector.Unboxed.Base.Vector GHC.Word.Word8)
                   @ (Data.Vector.Unboxed.Base.Vector MailBox.Square)
                   @ m
                   (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                   (\ tpl :: Data.Vector.Unboxed.Base.Vector GHC.Word.Word8 -> tpl)
                     `cast`
                   (<Data.Vector.Unboxed.Base.Vector GHC.Word.Word8>_R
                    ->_R Trans
                             (Sym (MailBox.NTCo:R:VectorSquare[0]))
                             (Sub (Sym (MailBox.TFCo:R:VectorSquare[0]))))
                   (GHC.Base.liftM
                      @ (Data.Vector.Primitive.Vector GHC.Word.Word8)
                      @ (Data.Vector.Unboxed.Base.Vector GHC.Word.Word8)
                      @ m
                      (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                      (\ tpl :: Data.Vector.Primitive.Vector GHC.Word.Word8 -> tpl)
                        `cast`
                      (<Data.Vector.Primitive.Vector GHC.Word.Word8>_R
                       ->_R Trans
                                (Sym (Data.Vector.Unboxed.Base.NTCo:R:VectorWord8[0]))
                                (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:VectorWord8[0]))))
                      (case eta
                              `cast`
                            (Trans
                                 (Sub (Data.Vector.Unboxed.Base.TFCo:R:MutableVector[0]) <Control.Monad.Primitive.PrimState
                                                                                            m>_N <MailBox.Square>_N)
                                 (Trans
                                      (Sub (MailBox.TFCo:R:MVectorsSquare[0]
                                                <Control.Monad.Primitive.PrimState m>_N))
                                      (Trans
                                           (MailBox.NTCo:R:MVectorsSquare[0]
                                                <Control.Monad.Primitive.PrimState m>_N)
                                           (Trans
                                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                                          <Control.Monad.Primitive.PrimState m>_N))
                                                (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                                     <Control.Monad.Primitive.PrimState
                                                        m>_N))))) of wild { Data.Vector.Primitive.Mutable.MVector dt dt1 dt2 ->
                       GHC.Base.liftM
                         @ Data.Primitive.ByteArray.ByteArray
                         @ (Data.Vector.Primitive.Vector GHC.Word.Word8)
                         @ m
                         (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                         (Data.Vector.Primitive.$WVector
                            @ GHC.Word.Word8
                            (GHC.Types.I# dt)
                            (GHC.Types.I# dt1))
                         (Control.Monad.Primitive.primitive
                            @ m
                            $dPrimMonad
                            @ Data.Primitive.ByteArray.ByteArray
                            (\ s# :: GHC.Prim.State#
                                       (Control.Monad.Primitive.PrimState m)[OneShot] ->
                             case GHC.Prim.unsafeFreezeByteArray#
                                    @ (Control.Monad.Primitive.PrimState m)
                                    dt2
                                    s# of ds1 { (#,#) ipv ipv1 ->
                             (# ipv, Data.Primitive.ByteArray.ByteArray ipv1 #) })) }))) -}
95999ae030c6e75e85d223fd90df7ec1
  $fVectorVectorSquare_$cbasicUnsafeIndexM ::
    GHC.Base.Monad m =>
    Data.Vector.Unboxed.Base.Vector MailBox.Square
    -> GHC.Types.Int -> m MailBox.Square
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLL),U(A,1*C1(C1(U)),A,C(U),A)><L,1*U(U,A,U)><L,1*U(U)>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ (m :: * -> *)
                   $dMonad :: GHC.Base.Monad m
                   ds :: Data.Vector.Unboxed.Base.Vector MailBox.Square
                   idx :: GHC.Types.Int ->
                 GHC.Base.liftM
                   @ GHC.Word.Word8
                   @ MailBox.Square
                   @ m
                   $dMonad
                   (\ tpl :: GHC.Word.Word8 -> tpl)
                     `cast`
                   (<GHC.Word.Word8>_R ->_R Sym (MailBox.NTCo:Square[0]))
                   (case ds
                           `cast`
                         (Trans
                              (Sub (MailBox.TFCo:R:VectorSquare[0]))
                              (Trans
                                   (MailBox.NTCo:R:VectorSquare[0])
                                   (Trans
                                        (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorWord8[0]))
                                        (Data.Vector.Unboxed.Base.NTCo:R:VectorWord8[0])))) of wild { Data.Vector.Primitive.Vector dt dt1 dt2 ->
                    case GHC.Num.$fNumInt_$c+
                           (GHC.Types.I# dt)
                           idx of wild1 { GHC.Types.I# i# ->
                    case GHC.Prim.indexWord8Array# dt2 i# of wild2 { DEFAULT ->
                    GHC.Base.$!
                      @ GHC.Word.Word8
                      @ (m GHC.Word.Word8)
                      (GHC.Base.return @ m $dMonad @ GHC.Word.Word8)
                      (GHC.Word.W8# wild2) } } })) -}
95999ae030c6e75e85d223fd90df7ec1
  $fVectorVectorSquare_$cbasicUnsafeSlice ::
    GHC.Types.Int
    -> GHC.Types.Int
    -> Data.Vector.Unboxed.Base.Vector MailBox.Square
    -> Data.Vector.Unboxed.Base.Vector MailBox.Square
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,1*U(U)><S,1*U(U)><S,1*U(U,A,U)>m,
     Inline: INLINE (sat-args=3),
     Unfolding: InlineRule (3, False, True)
                Data.Vector.Unboxed.Base.$fVectorVectorWord8_$cbasicUnsafeSlice
                  `cast`
                (<GHC.Types.Int>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R Trans
                          (Sym (MailBox.NTCo:R:VectorSquare[0]))
                          (Sub (Sym (MailBox.TFCo:R:VectorSquare[0])))
                 ->_R Trans
                          (Sym (MailBox.NTCo:R:VectorSquare[0]))
                          (Sub (Sym (MailBox.TFCo:R:VectorSquare[0])))) -}
95999ae030c6e75e85d223fd90df7ec1
  $fVectorVectorSquare_$cbasicUnsafeThaw ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Unboxed.Base.Vector MailBox.Square
    -> m (Data.Vector.Generic.Base.Mutable
            Data.Vector.Unboxed.Base.Vector
            (Control.Monad.Primitive.PrimState m)
            MailBox.Square)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),U(U,1*C1(U))><L,1*U(U,U,U)>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   eta :: Data.Vector.Unboxed.Base.Vector MailBox.Square ->
                 GHC.Base.liftM
                   @ (Data.Vector.Unboxed.Base.MVector
                        (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                   @ (Data.Vector.Unboxed.Base.MVector
                        (Control.Monad.Primitive.PrimState m) MailBox.Square)
                   @ m
                   (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                   (\ tpl :: Data.Vector.Unboxed.Base.MVector
                               (Control.Monad.Primitive.PrimState m) GHC.Word.Word8 ->
                    tpl)
                     `cast`
                   (<Data.Vector.Unboxed.Base.MVector
                       (Control.Monad.Primitive.PrimState m) GHC.Word.Word8>_R
                    ->_R Trans
                             (Sym (MailBox.NTCo:R:MVectorsSquare[0]
                                       <Control.Monad.Primitive.PrimState m>_N))
                             (Sub (Sym (MailBox.TFCo:R:MVectorsSquare[0]
                                            <Control.Monad.Primitive.PrimState m>_N))))
                   (GHC.Base.liftM
                      @ (Data.Vector.Primitive.Mutable.MVector
                           (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                      @ (Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                      @ m
                      (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                      (\ tpl :: Data.Vector.Primitive.Mutable.MVector
                                  (Control.Monad.Primitive.PrimState m) GHC.Word.Word8 ->
                       tpl)
                        `cast`
                      (<Data.Vector.Primitive.Mutable.MVector
                          (Control.Monad.Primitive.PrimState m) GHC.Word.Word8>_R
                       ->_R Trans
                                (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                          <Control.Monad.Primitive.PrimState m>_N))
                                (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                               <Control.Monad.Primitive.PrimState m>_N))))
                      (case eta
                              `cast`
                            (Trans
                                 (Sub (MailBox.TFCo:R:VectorSquare[0]))
                                 (Trans
                                      (MailBox.NTCo:R:VectorSquare[0])
                                      (Trans
                                           (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorWord8[0]))
                                           (Data.Vector.Unboxed.Base.NTCo:R:VectorWord8[0])))) of wild { Data.Vector.Primitive.Vector dt dt1 dt2 ->
                       GHC.Base.liftM
                         @ (Data.Primitive.ByteArray.MutableByteArray
                              (Control.Monad.Primitive.PrimState m))
                         @ (Data.Vector.Primitive.Mutable.MVector
                              (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                         @ m
                         (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                         (Data.Vector.Primitive.Mutable.$WMVector
                            @ (Control.Monad.Primitive.PrimState m)
                            @ GHC.Word.Word8
                            (GHC.Types.I# dt)
                            (GHC.Types.I# dt1))
                         (Control.Monad.Primitive.primitive
                            @ m
                            $dPrimMonad
                            @ (Data.Primitive.ByteArray.MutableByteArray
                                 (Control.Monad.Primitive.PrimState m))
                            (\ s# :: GHC.Prim.State#
                                       (Control.Monad.Primitive.PrimState m)[OneShot] ->
                             (# s#,
                                Data.Primitive.ByteArray.MutableByteArray
                                  @ (Control.Monad.Primitive.PrimState m)
                                  dt2
                                    `cast`
                                  (UnivCo mkUnsafeCo representational GHC.Prim.ByteArray# (GHC.Prim.MutableByteArray#
                                                                                             (Control.Monad.Primitive.PrimState
                                                                                                m))) #))) })))
                  `cast`
                (forall (m :: * -> *).
                 <Control.Monad.Primitive.PrimMonad m>_R
                 ->_R <Data.Vector.Unboxed.Base.Vector MailBox.Square>_R
                 ->_R <m>_R (Sym (Data.Vector.Unboxed.Base.TFCo:R:MutableVector[0]) <Control.Monad.Primitive.PrimState
                                                                                       m>_N <MailBox.Square>_N)) -}
95999ae030c6e75e85d223fd90df7ec1
  $fVectorVectorSquare_$celemseq ::
    Data.Vector.Unboxed.Base.Vector MailBox.Square
    -> MailBox.Square -> b -> b
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><S,1*U><S,1*U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ b
                   ds :: Data.Vector.Unboxed.Base.Vector MailBox.Square
                   val :: MailBox.Square ->
                 GHC.Prim.seq @ GHC.Word.Word8 @ b (MailBox.unS val)) -}
e8570aae7bcfd635c2a573fdc068c0a7
  type MailBox = Data.Vector.Unboxed.Base.Vector MailBox.Square
95999ae030c6e75e85d223fd90df7ec1
  newtype instance Data.Vector.Unboxed.Base.MVector s0 MailBox.Square
    = MV_Square (Data.Vector.Unboxed.Base.MVector s0 GHC.Word.Word8)
    RecFlag: Recursive
95999ae030c6e75e85d223fd90df7ec1
  newtype instance Data.Vector.Unboxed.Base.Vector MailBox.Square
    = V_Square (Data.Vector.Unboxed.Base.Vector GHC.Word.Word8)
    RecFlag: Recursive
95999ae030c6e75e85d223fd90df7ec1
  newtype Square = S {unS :: GHC.Word.Word8}
95999ae030c6e75e85d223fd90df7ec1
  axiom TFCo:R:MVectorsSquare::
      Data.Vector.Unboxed.Base.MVector s0 MailBox.Square
        = MailBox.R:MVectorsSquare s0
95999ae030c6e75e85d223fd90df7ec1
  axiom TFCo:R:VectorSquare::
      Data.Vector.Unboxed.Base.Vector MailBox.Square
        = MailBox.R:VectorSquare
dba9b76d67008eef952c2076f95172b2
  allSquareTypes :: (GHC.Enum.Enum t1, GHC.Num.Num t1) => [t] -> [t1]
  {- Arity: 3,
     Strictness: <S(LLLLLLC(C(S))L),1*U(A,A,A,A,A,A,1*C1(C1(U)),A)><L,U(A,A,A,A,A,A,C(U))><S,1*U>,
     Unfolding: (\ @ t
                   @ t1
                   $dEnum :: GHC.Enum.Enum t1
                   $dNum :: GHC.Num.Num t1
                   ds :: [t] ->
                 case ds of wild {
                   [] -> MailBox.allSquareTypes3 @ t1
                   : noPiece ds1
                   -> case ds1 of wild1 {
                        [] -> MailBox.allSquareTypes3 @ t1
                        : bPawn ds2
                        -> case ds2 of wild2 {
                             [] -> MailBox.allSquareTypes3 @ t1
                             : bRook ds3
                             -> case ds3 of wild3 {
                                  [] -> MailBox.allSquareTypes3 @ t1
                                  : bKnight ds4
                                  -> case ds4 of wild4 {
                                       [] -> MailBox.allSquareTypes3 @ t1
                                       : bBishop ds5
                                       -> case ds5 of wild5 {
                                            [] -> MailBox.allSquareTypes3 @ t1
                                            : bQueen ds6
                                            -> case ds6 of wild6 {
                                                 [] -> MailBox.allSquareTypes3 @ t1
                                                 : bKing ds7
                                                 -> case ds7 of wild7 {
                                                      [] -> MailBox.allSquareTypes3 @ t1
                                                      : wPawn ds8
                                                      -> case ds8 of wild8 {
                                                           [] -> MailBox.allSquareTypes3 @ t1
                                                           : wRook ds9
                                                           -> case ds9 of wild9 {
                                                                [] -> MailBox.allSquareTypes3 @ t1
                                                                : wKnight ds10
                                                                -> case ds10 of wild10 {
                                                                     []
                                                                     -> MailBox.allSquareTypes3 @ t1
                                                                     : wBishop ds11
                                                                     -> case ds11 of wild11 {
                                                                          []
                                                                          -> MailBox.allSquareTypes3
                                                                               @ t1
                                                                          : wQueen ds12
                                                                          -> case ds12 of wild12 {
                                                                               []
                                                                               -> MailBox.allSquareTypes3
                                                                                    @ t1
                                                                               : wKing ds13
                                                                               -> case ds13 of wild13 {
                                                                                    []
                                                                                    -> GHC.Enum.enumFromTo
                                                                                         @ t1
                                                                                         $dEnum
                                                                                         (GHC.Num.fromInteger
                                                                                            @ t1
                                                                                            $dNum
                                                                                            MailBox.allSquareTypes2)
                                                                                         (GHC.Num.fromInteger
                                                                                            @ t1
                                                                                            $dNum
                                                                                            MailBox.allSquareTypes1)
                                                                                    : ipv ipv1
                                                                                    -> MailBox.allSquareTypes3
                                                                                         @ t1 } } } } } } } } } } } } } }) -}
6dff646c08243e97d9d30848054927f7
  allSquareTypes1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (__integer 13) -}
8e62eb8afc12bb9a269bb85fa66557f8
  allSquareTypes2 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (__integer 0) -}
eafb85df208ee04c3f4e2ec8a2a3a4cb
  allSquareTypes3 :: [t]
  {- Strictness: b -}
414b08f1443b069248546639d913dab5
  showMailBox :: MailBox.MailBox -> GHC.Base.String
  {- Strictness: b,
     Unfolding: InlineRule (0, True, True)
                (GHC.Err.undefined @ (MailBox.MailBox -> GHC.Base.String)) -}
95999ae030c6e75e85d223fd90df7ec1
  unS :: MailBox.Square -> GHC.Word.Word8
  RecSel MailBox.Square
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                MailBox.unS1
                  `cast`
                (<MailBox.Square>_R ->_R MailBox.NTCo:Square[0]) -}
95999ae030c6e75e85d223fd90df7ec1
  unS1 :: MailBox.Square -> MailBox.Square
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (1, True, True)
                (\ ds :: MailBox.Square -> ds) -}
instance Data.Vector.Generic.Mutable.Base.MVector [Data.Vector.Unboxed.Base.MVector,
                                                   MailBox.Square]
  = MailBox.$fMVectorMVectorSquare
instance Data.Vector.Unboxed.Base.Unbox [MailBox.Square]
  = MailBox.$fUnboxSquare
instance Data.Vector.Generic.Base.Vector [Data.Vector.Unboxed.Base.Vector,
                                          MailBox.Square]
  = MailBox.$fVectorVectorSquare
family instance Data.Vector.Unboxed.Base.MVector [.],
                                                 [MailBox.Square]
  = MailBox.TFCo:R:MVectorsSquare
family instance Data.Vector.Unboxed.Base.Vector [MailBox.Square]
  = MailBox.TFCo:R:VectorSquare
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

