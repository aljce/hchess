
==================== FINAL INTERFACE ====================
2015-12-07 17:24:11.180347 UTC

interface hches_DCOOKx5aUDOAR8ciXX95kw:Test [family instance module] 7102
  interface hash: dd8ac36a38b2b72e841bc0aa912d8765
  ABI hash: fd1eda9ce25946f0d15c88c8c3536117
  export-list hash: 121b0ca3f1774b9ca3b4307a2d9f3b47
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 541d2ae739ad8cde81f8c21554eda2f6
  sig of: Nothing
  used TH splices: False
  where
exports:
  Test.generateTree
  Test.takeTree
  Test.BTree{Test.BTree}
  Test.Tree{Test.Tree}
module dependencies:
package dependencies: StateVar-1.1.0.1@State_6K4a3UqSdqh6lGAm1wlr9s
                      array-0.5.1.0@array_E0sTtauuKsGDLZoT7lTbgZ base-4.8.1.0
                      base-orphans-0.4.4@baseo_E55c3OEBLyu45sND7mOuE9
                      bifunctors-5@bifun_GM18iLLOdGHJbSbyyW44ic
                      binary-0.7.5.0@binar_IvYoLp9H6Xy3zEH13MmZwd
                      bytestring-0.10.6.0@bytes_6elQVSg5cWdFrvRnfxTUrH
                      comonad-4.2.7.2@comon_Gau7sL6kCs2Gp1aW6PmLQx
                      containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN
                      contravariant-1.3.3@contr_Etlu4sPcQvWFc7dliDRyeB
                      deepseq-1.4.1.1@deeps_LbCWUlehDDeLxurARKDH5o
                      distributive-0.4.4@distr_DtmCggRmFF9KhnqzzbElBb
                      exceptions-0.8.0.2@excep_8GsEeHgaIks3pVGk6GaELJ
                      free-4.12.1@free_LEq3JjfARCZAm9OpWXvSL2 ghc-prim-0.4.0.0
                      hashable-1.2.3.3@hasha_2GTZqecVp8NJZrNuKzGxfy integer-gmp-1.0.0.0
                      mtl-2.2.1@mtl_KMpng31YRYc5JfMWFZ3FCU
                      prelude-extras-0.4.0.2@prelu_57eavILAbKD5CaKv31zEDY
                      primitive-0.6.1.0@primi_5Jnw7oEuYtM9dmKXelGXVb
                      profunctors-5.1.1@profu_10NTdMLhDJnH9DAPKgg0Ts
                      recursion-schemes-4.1.2@recur_GXdItymymlF6sVuqWgqFa4
                      semigroups-0.16.2.2@semig_HNb9h0T169c7a2Sufm50uz
                      semigroupoids-5.0.0.4@semig_KHHOcgV5JRD8a0BEZjdiJ6
                      stm-2.4.4@stm_C1kFMnPqFjvDhFjgMZGUpr
                      tagged-0.8.2@tagge_4zanMqQLQHpBO0ZYm7KGkc
                      text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh
                      transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X
                      unordered-containers-0.2.5.1@unord_7E41cj9RvqSJeZ4jSnbs1a
                      vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF
orphans: base-4.8.1.0:GHC.Base base-4.8.1.0:GHC.Float
         binary-0.7.5.0@binar_IvYoLp9H6Xy3zEH13MmZwd:Data.Binary.Generic
         bytestring-0.10.6.0@bytes_6elQVSg5cWdFrvRnfxTUrH:Data.ByteString.Builder
         hashable-1.2.3.3@hasha_2GTZqecVp8NJZrNuKzGxfy:Data.Hashable.Generic
         stm-2.4.4@stm_C1kFMnPqFjvDhFjgMZGUpr:Control.Monad.STM
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Lazy
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Show
         transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X:Control.Monad.Trans.Error
         vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector.Fusion.Bundle
family instance modules: base-4.8.1.0:Control.Applicative
                         base-4.8.1.0:Data.Either base-4.8.1.0:Data.Functor.Identity
                         base-4.8.1.0:Data.Monoid base-4.8.1.0:Data.Type.Equality
                         base-4.8.1.0:Data.Void base-4.8.1.0:GHC.Exts
                         base-4.8.1.0:GHC.Generics
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntMap.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntSet.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Map.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Sequence
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Set.Base
                         primitive-0.6.1.0@primi_5Jnw7oEuYtM9dmKXelGXVb:Control.Monad.Primitive
                         recursion-schemes-4.1.2@recur_GXdItymymlF6sVuqWgqFa4:Data.Functor.Foldable
                         semigroups-0.16.2.2@semig_HNb9h0T169c7a2Sufm50uz:Data.List.NonEmpty
                         semigroups-0.16.2.2@semig_HNb9h0T169c7a2Sufm50uz:Data.Semigroup
                         tagged-0.8.2@tagge_4zanMqQLQHpBO0ZYm7KGkc:Data.Tagged
                         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text
                         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Lazy
                         unordered-containers-0.2.5.1@unord_7E41cj9RvqSJeZ4jSnbs1a:Data.HashMap.Base
                         unordered-containers-0.2.5.1@unord_7E41cj9RvqSJeZ4jSnbs1a:Data.HashSet
                         vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector
import  -/  base-4.8.1.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.1.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.1.0:GHC.Show b8c65ca3124f92a166c9f05120382442
import  -/  base-4.8.1.0:Prelude 518f762991bc287d78f21a73c974da1f
import  -/  containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntMap.Base 41288a612f7bbd399bc0bb07f2f75738
import  -/  containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntMap.Strict 75157829e2fd1bf3aaf8a4fd3bd7d8f4
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  recursion-schemes-4.1.2@recur_GXdItymymlF6sVuqWgqFa4:Data.Functor.Foldable ab79a0f11179235986b467d054856f29
import  -/  vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector 4610cc52ce9b78f79b9be7be941ffbe2
2b8039d4a97b7ffc3fe307ae41a5ec0f
  $fFoldableTree ::
    GHC.Base.Functor (Data.Functor.Foldable.Base (Test.Tree a)) =>
    Data.Functor.Foldable.Foldable (Test.Tree a)
  DFunId[1]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(U,U)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a
                      $dFunctor :: GHC.Base.Functor
                                     (Data.Functor.Foldable.Base (Test.Tree a)).
                  @ (Test.Tree a)
                  $dFunctor
                  (Test.$fFoldableTree_$cproject @ a $dFunctor)
                  (Test.$fFoldableTree_$ccata @ a $dFunctor)
                  (Test.$fFoldableTree_$cpara @ a $dFunctor)
                  (Test.$fFoldableTree_$cgpara @ a $dFunctor)
                  (Test.$fFoldableTree_$cprepro @ a $dFunctor)
                  (Test.$fFoldableTree_$cgprepro @ a $dFunctor) -}
2b8039d4a97b7ffc3fe307ae41a5ec0f
  $fFoldableTree_$ccata ::
    GHC.Base.Functor (Data.Functor.Foldable.Base (Test.Tree a)) =>
    forall a1.
    (Data.Functor.Foldable.Base (Test.Tree a) a1 -> a1)
    -> Test.Tree a -> a1
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(C(U),A)><L,C(U)>,
     Unfolding: (\ @ a
                   $dFunctor :: GHC.Base.Functor
                                  (Data.Functor.Foldable.Base (Test.Tree a))
                   @ a1
                   eta :: Data.Functor.Foldable.Base (Test.Tree a) a1 -> a1 ->
                 letrec {
                   f :: Data.Functor.Foldable.Base (Test.Tree a) (Test.Tree a)
                        -> Data.Functor.Foldable.Base (Test.Tree a) a1
                   = GHC.Base.fmap
                       @ (Data.Functor.Foldable.Base (Test.Tree a))
                       $dFunctor
                       @ (Test.Tree a)
                       @ a1
                       c
                   c :: Test.Tree a -> a1 {- Arity: 1, Strictness: <L,1*U(U,U)> -}
                   = \ x :: Test.Tree a ->
                     eta
                       (f (case x of wild { Test.Tree leaf branches ->
                           (Test.BTree @ a @ (Test.Tree a) leaf branches)
                             `cast`
                           (Sub (Sym (Test.TFCo:R:BaseTree[0] <a>_N)) <Test.Tree a>_N) }))
                 } in
                 c) -}
2b8039d4a97b7ffc3fe307ae41a5ec0f
  $fFoldableTree_$cgpara ::
    GHC.Base.Functor (Data.Functor.Foldable.Base (Test.Tree a)) =>
    forall (w :: * -> *) a1.
    (Data.Functor.Foldable.Unfoldable (Test.Tree a),
     Control.Comonad.Comonad w) =>
    (forall b.
     Data.Functor.Foldable.Base (Test.Tree a) (w b)
     -> w (Data.Functor.Foldable.Base (Test.Tree a) b))
    -> (Data.Functor.Foldable.Base
          (Test.Tree a) (Control.Comonad.Trans.Env.EnvT (Test.Tree a) w a1)
        -> a1)
    -> Test.Tree a
    -> a1
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(U,U)> -}
2b8039d4a97b7ffc3fe307ae41a5ec0f
  $fFoldableTree_$cgprepro ::
    GHC.Base.Functor (Data.Functor.Foldable.Base (Test.Tree a)) =>
    forall (w :: * -> *) a1.
    (Data.Functor.Foldable.Unfoldable (Test.Tree a),
     Control.Comonad.Comonad w) =>
    (forall b.
     Data.Functor.Foldable.Base (Test.Tree a) (w b)
     -> w (Data.Functor.Foldable.Base (Test.Tree a) b))
    -> (forall c.
        Data.Functor.Foldable.Base (Test.Tree a) c
        -> Data.Functor.Foldable.Base (Test.Tree a) c)
    -> (Data.Functor.Foldable.Base (Test.Tree a) (w a1) -> a1)
    -> Test.Tree a
    -> a1
  {- Arity: 6, HasNoCafRefs,
     Strictness: <L,U(C(U),A)><L,U(U(C(U),A),U,A,A,A,A)><L,U(1*U(1*C1(U),A),1*U,U,A)><L,C(U)><L,C(U)><L,U>,
     Unfolding: (\ @ a
                   $dFunctor :: GHC.Base.Functor
                                  (Data.Functor.Foldable.Base (Test.Tree a))
                   @ (w :: * -> *)
                   @ a1
                   $dUnfoldable :: Data.Functor.Foldable.Unfoldable (Test.Tree a)
                   $dComonad :: Control.Comonad.Comonad w
                   eta :: forall b.
                          Data.Functor.Foldable.Base (Test.Tree a) (w b)
                          -> w (Data.Functor.Foldable.Base (Test.Tree a) b)
                   eta1 :: forall c.
                           Data.Functor.Foldable.Base (Test.Tree a) c
                           -> Data.Functor.Foldable.Base (Test.Tree a) c
                   eta2 :: Data.Functor.Foldable.Base (Test.Tree a) (w a1) -> a1 ->
                 let {
                   f :: w (Data.Functor.Foldable.Base (Test.Tree a) (w a1)) -> w a1
                   = GHC.Base.fmap
                       @ w
                       (Control.Comonad.$p1Comonad @ w $dComonad)
                       @ (Data.Functor.Foldable.Base (Test.Tree a) (w a1))
                       @ a1
                       eta2
                 } in
                 letrec {
                   f1 :: Data.Functor.Foldable.Base (Test.Tree a) (Test.Tree a)
                         -> Data.Functor.Foldable.Base (Test.Tree a) (w (w a1))
                   = GHC.Base.fmap
                       @ (Data.Functor.Foldable.Base (Test.Tree a))
                       (Data.Functor.Foldable.$p1Unfoldable @ (Test.Tree a) $dUnfoldable)
                       @ (Test.Tree a)
                       @ (w (w a1))
                       (let {
                          f2 :: w a1 -> w (w a1)
                          = Control.Comonad.duplicate @ w $dComonad @ a1
                        } in
                        let {
                          f3 :: Data.Functor.Foldable.Base (Test.Tree a) (Test.Tree a)
                                -> Test.Tree a
                          = Data.Functor.Foldable.embed @ (Test.Tree a) $dUnfoldable
                        } in
                        letrec {
                          f4 :: Data.Functor.Foldable.Base (Test.Tree a) (Test.Tree a)
                                -> Data.Functor.Foldable.Base (Test.Tree a) (Test.Tree a)
                          = GHC.Base.fmap
                              @ (Data.Functor.Foldable.Base (Test.Tree a))
                              $dFunctor
                              @ (Test.Tree a)
                              @ (Test.Tree a)
                              c1
                          c1 :: Test.Tree a -> Test.Tree a
                            {- Arity: 1, Strictness: <L,1*U(U,U)> -}
                          = \ x :: Test.Tree a ->
                            f3
                              (eta1
                                 @ (Test.Tree a)
                                 (f4
                                    (case x of wild { Test.Tree leaf branches ->
                                     (Test.BTree @ a @ (Test.Tree a) leaf branches)
                                       `cast`
                                     (Sub (Sym (Test.TFCo:R:BaseTree[0] <a>_N)) <Test.Tree
                                                                                   a>_N) })))
                        } in
                        \ x :: Test.Tree a -> f2 (c (c1 x)))
                   c :: Test.Tree a -> w a1 {- Arity: 1, Strictness: <L,1*U(U,U)> -}
                   = \ x :: Test.Tree a ->
                     f (eta
                          @ (w a1)
                          (f1
                             (case x of wild { Test.Tree leaf branches ->
                              (Test.BTree @ a @ (Test.Tree a) leaf branches)
                                `cast`
                              (Sub (Sym (Test.TFCo:R:BaseTree[0] <a>_N)) <Test.Tree a>_N) })))
                 } in
                 let {
                   f2 :: w a1 -> a1 = Control.Comonad.extract @ w $dComonad @ a1
                 } in
                 \ x :: Test.Tree a -> f2 (c x)) -}
2b8039d4a97b7ffc3fe307ae41a5ec0f
  $fFoldableTree_$cpara ::
    GHC.Base.Functor (Data.Functor.Foldable.Base (Test.Tree a)) =>
    forall a1.
    (Data.Functor.Foldable.Base (Test.Tree a) (Test.Tree a, a1) -> a1)
    -> Test.Tree a -> a1
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><C(S),C(U)><L,1*U(U,U)>,
     Unfolding: (\ @ a
                   $dFunctor :: GHC.Base.Functor
                                  (Data.Functor.Foldable.Base (Test.Tree a))
                   @ a1
                   eta :: Data.Functor.Foldable.Base (Test.Tree a) (Test.Tree a, a1)
                          -> a1
                   eta1 :: Test.Tree a ->
                 letrec {
                   lvl4 :: Test.Tree a -> (Test.Tree a, a1) {- Arity: 1 -}
                   = \ x :: Test.Tree a -> (x, p x)
                   p :: Test.Tree a -> a1 {- Arity: 1, Strictness: <L,1*U(U,U)> -}
                   = \ x :: Test.Tree a ->
                     eta
                       (GHC.Base.fmap
                          @ (Data.Functor.Foldable.Base (Test.Tree a))
                          $dFunctor
                          @ (Test.Tree a)
                          @ (Test.Tree a, a1)
                          lvl4
                          (case x of wild { Test.Tree leaf branches ->
                           (Test.BTree @ a @ (Test.Tree a) leaf branches)
                             `cast`
                           (Sub (Sym (Test.TFCo:R:BaseTree[0] <a>_N)) <Test.Tree a>_N) }))
                 } in
                 p eta1) -}
2b8039d4a97b7ffc3fe307ae41a5ec0f
  $fFoldableTree_$cprepro ::
    GHC.Base.Functor (Data.Functor.Foldable.Base (Test.Tree a)) =>
    forall a1.
    Data.Functor.Foldable.Unfoldable (Test.Tree a) =>
    (forall b.
     Data.Functor.Foldable.Base (Test.Tree a) b
     -> Data.Functor.Foldable.Base (Test.Tree a) b)
    -> (Data.Functor.Foldable.Base (Test.Tree a) a1 -> a1)
    -> Test.Tree a
    -> a1
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(C(U),A)><L,U(U(C(U),A),U,A,A,A,A)><L,C(U)><L,C(U)>,
     Unfolding: (\ @ a
                   $dFunctor :: GHC.Base.Functor
                                  (Data.Functor.Foldable.Base (Test.Tree a))
                   @ a1
                   $dUnfoldable :: Data.Functor.Foldable.Unfoldable (Test.Tree a)
                   eta :: forall b.
                          Data.Functor.Foldable.Base (Test.Tree a) b
                          -> Data.Functor.Foldable.Base (Test.Tree a) b
                   eta1 :: Data.Functor.Foldable.Base (Test.Tree a) a1 -> a1 ->
                 letrec {
                   f :: Data.Functor.Foldable.Base (Test.Tree a) (Test.Tree a)
                        -> Data.Functor.Foldable.Base (Test.Tree a) a1
                   = GHC.Base.fmap
                       @ (Data.Functor.Foldable.Base (Test.Tree a))
                       (Data.Functor.Foldable.$p1Unfoldable @ (Test.Tree a) $dUnfoldable)
                       @ (Test.Tree a)
                       @ a1
                       (let {
                          f1 :: Data.Functor.Foldable.Base (Test.Tree a) (Test.Tree a)
                                -> Test.Tree a
                          = Data.Functor.Foldable.embed @ (Test.Tree a) $dUnfoldable
                        } in
                        letrec {
                          f2 :: Data.Functor.Foldable.Base (Test.Tree a) (Test.Tree a)
                                -> Data.Functor.Foldable.Base (Test.Tree a) (Test.Tree a)
                          = GHC.Base.fmap
                              @ (Data.Functor.Foldable.Base (Test.Tree a))
                              $dFunctor
                              @ (Test.Tree a)
                              @ (Test.Tree a)
                              c1
                          c1 :: Test.Tree a -> Test.Tree a
                            {- Arity: 1, Strictness: <L,1*U(U,U)> -}
                          = \ x :: Test.Tree a ->
                            f1
                              (eta
                                 @ (Test.Tree a)
                                 (f2
                                    (case x of wild { Test.Tree leaf branches ->
                                     (Test.BTree @ a @ (Test.Tree a) leaf branches)
                                       `cast`
                                     (Sub (Sym (Test.TFCo:R:BaseTree[0] <a>_N)) <Test.Tree
                                                                                   a>_N) })))
                        } in
                        \ x :: Test.Tree a -> c (c1 x))
                   c :: Test.Tree a -> a1 {- Arity: 1, Strictness: <L,1*U(U,U)> -}
                   = \ x :: Test.Tree a ->
                     eta1
                       (f (case x of wild { Test.Tree leaf branches ->
                           (Test.BTree @ a @ (Test.Tree a) leaf branches)
                             `cast`
                           (Sub (Sym (Test.TFCo:R:BaseTree[0] <a>_N)) <Test.Tree a>_N) }))
                 } in
                 c) -}
2b8039d4a97b7ffc3fe307ae41a5ec0f
  $fFoldableTree_$cproject ::
    GHC.Base.Functor (Data.Functor.Foldable.Base (Test.Tree a)) =>
    Test.Tree a
    -> Data.Functor.Foldable.Base (Test.Tree a) (Test.Tree a)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U(U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   $dFunctor :: GHC.Base.Functor
                                  (Data.Functor.Foldable.Base (Test.Tree a))
                   ds :: Test.Tree a ->
                 case ds of wild { Test.Tree leaf branches ->
                 (Test.BTree @ a @ (Test.Tree a) leaf branches)
                   `cast`
                 (Sub (Sym (Test.TFCo:R:BaseTree[0] <a>_N)) <Test.Tree a>_N) }) -}
2b8039d4a97b7ffc3fe307ae41a5ec0f
  $fFunctorBTree :: GHC.Base.Functor (Test.BTree a)
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a.
                  @ (Test.BTree a)
                  (Test.$fFunctorBTree_$cfmap @ a)
                  (Test.$fFunctorBTree_$c<$ @ a) -}
2b8039d4a97b7ffc3fe307ae41a5ec0f
  $fFunctorBTree_$c<$ :: a1 -> Test.BTree a b -> Test.BTree a a1
  {- Arity: 2, Strictness: <L,U><S,1*U(U,1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ a1 @ b eta :: a1 eta1 :: Test.BTree a b ->
                 Test.$fFunctorBTree_$cfmap @ a @ b @ a1 (\ ds :: b -> eta) eta1) -}
2b8039d4a97b7ffc3fe307ae41a5ec0f
  $fFunctorBTree_$cfmap ::
    (a1 -> b) -> Test.BTree a a1 -> Test.BTree a b
  {- Arity: 2, Strictness: <L,C(U)><S,1*U(U,1*U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ a1 @ b w :: a1 -> b w1 :: Test.BTree a a1 ->
                 case w1 of ww { Test.BTree ww1 ww2 ->
                 case Test.$w$cfmap @ a @ a1 @ b w ww1 ww2 of ww3 { (#,#) ww4 ww5 ->
                 Test.BTree @ a @ b ww4 ww5 } }) -}
2b8039d4a97b7ffc3fe307ae41a5ec0f
  $fShowTree :: GHC.Show.Show a => GHC.Show.Show (Test.Tree a)
  DFunId[0]
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a $dShow :: GHC.Show.Show a.
                  @ (Test.Tree a)
                  (Test.$fShowTree_$cshowsPrec @ a $dShow)
                  (Test.$fShowTree_$cshow @ a $dShow)
                  (Test.$fShowTree_$cshowList @ a $dShow) -}
f748aa5e8b90cbb76023c79df7f0dcbd
  $fShowTree1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
2b8039d4a97b7ffc3fe307ae41a5ec0f
  $fShowTree_$cshow ::
    GHC.Show.Show a => Test.Tree a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a $dShow :: GHC.Show.Show a x :: Test.Tree a ->
                 Test.$fShowTree_$cshowsPrec
                   @ a
                   $dShow
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
2b8039d4a97b7ffc3fe307ae41a5ec0f
  $fShowTree_$cshowList ::
    GHC.Show.Show a => [Test.Tree a] -> GHC.Show.ShowS
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a $dShow :: GHC.Show.Show a ->
                 GHC.Show.showList__
                   @ (Test.Tree a)
                   (Test.$fShowTree_$cshowsPrec @ a $dShow Test.$fShowTree1)) -}
2b8039d4a97b7ffc3fe307ae41a5ec0f
  $fShowTree_$cshowsPrec ::
    GHC.Show.Show a => GHC.Types.Int -> Test.Tree a -> GHC.Show.ShowS
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)> -}
2b8039d4a97b7ffc3fe307ae41a5ec0f
  $fUnfoldableTree ::
    GHC.Base.Functor (Data.Functor.Foldable.Base (Test.Tree a)) =>
    Data.Functor.Foldable.Unfoldable (Test.Tree a)
  DFunId[1]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(U,U)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a
                      $dFunctor :: GHC.Base.Functor
                                     (Data.Functor.Foldable.Base (Test.Tree a)).
                  @ (Test.Tree a)
                  $dFunctor
                  (Test.$fUnfoldableTree_$cembed @ a $dFunctor)
                  (Test.$fUnfoldableTree_$cana @ a $dFunctor)
                  (Test.$fUnfoldableTree_$capo @ a $dFunctor)
                  (Test.$fUnfoldableTree_$cpostpro @ a $dFunctor)
                  (Test.$fUnfoldableTree_$cgpostpro @ a $dFunctor) -}
2b8039d4a97b7ffc3fe307ae41a5ec0f
  $fUnfoldableTree_$cana ::
    GHC.Base.Functor (Data.Functor.Foldable.Base (Test.Tree a)) =>
    forall a1.
    (a1 -> Data.Functor.Foldable.Base (Test.Tree a) a1)
    -> a1 -> Test.Tree a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(C(U),A)><L,C(U)>,
     Unfolding: (\ @ a
                   $dFunctor :: GHC.Base.Functor
                                  (Data.Functor.Foldable.Base (Test.Tree a))
                   @ a1
                   eta :: a1 -> Data.Functor.Foldable.Base (Test.Tree a) a1 ->
                 letrec {
                   a4 :: a1 -> Test.Tree a
                     {- Arity: 1, Strictness: <L,U>m, Inline: INLINE[0],
                        Unfolding: InlineRule (1, True, False)
                                   (\ w :: a1 ->
                                    case $wa1 w of ww { (#,#) ww1 ww2 -> Test.Tree @ a ww1 ww2 }) -}
                   = \ w :: a1 ->
                     case $wa1 w of ww { (#,#) ww1 ww2 -> Test.Tree @ a ww1 ww2 }
                   f1 :: Data.Functor.Foldable.Base (Test.Tree a) a1
                         -> Data.Functor.Foldable.Base (Test.Tree a) (Test.Tree a)
                   = GHC.Base.fmap
                       @ (Data.Functor.Foldable.Base (Test.Tree a))
                       $dFunctor
                       @ a1
                       @ (Test.Tree a)
                       a4
                   $wa1 :: a1
                           -> (# a,
                                 Data.IntMap.Base.IntMap (Data.Vector.Vector (Test.Tree a)) #)
                     {- Arity: 1, Strictness: <L,U>, Inline: [0] -}
                   = \ w :: a1 ->
                     case (f1 (eta w))
                            `cast`
                          (Sub (Test.TFCo:R:BaseTree[0] <a>_N) <Test.Tree
                                                                  a>_N) of wild { Test.BTree leaf branches ->
                     (# leaf, branches #) }
                 } in
                 a4) -}
2b8039d4a97b7ffc3fe307ae41a5ec0f
  $fUnfoldableTree_$capo ::
    GHC.Base.Functor (Data.Functor.Foldable.Base (Test.Tree a)) =>
    forall a1.
    Data.Functor.Foldable.Foldable (Test.Tree a) =>
    (a1
     -> Data.Functor.Foldable.Base
          (Test.Tree a) (Data.Either.Either (Test.Tree a) a1))
    -> a1 -> Test.Tree a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,A><L,U(U(C(U),A),A,A,A,A,A,A)><L,C(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ @ a
                   w :: GHC.Base.Functor (Data.Functor.Foldable.Base (Test.Tree a))
                   @ a1
                   w1 :: Data.Functor.Foldable.Foldable (Test.Tree a)
                   w2 :: a1
                         -> Data.Functor.Foldable.Base
                              (Test.Tree a) (Data.Either.Either (Test.Tree a) a1) ->
                 Test.$w$capo @ a @ a1 w1 w2) -}
2b8039d4a97b7ffc3fe307ae41a5ec0f
  $fUnfoldableTree_$cembed ::
    GHC.Base.Functor (Data.Functor.Foldable.Base (Test.Tree a)) =>
    Data.Functor.Foldable.Base (Test.Tree a) (Test.Tree a)
    -> Test.Tree a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U(U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   $dFunctor :: GHC.Base.Functor
                                  (Data.Functor.Foldable.Base (Test.Tree a))
                   ds :: Data.Functor.Foldable.Base (Test.Tree a) (Test.Tree a) ->
                 case ds
                        `cast`
                      (Sub (Test.TFCo:R:BaseTree[0] <a>_N) <Test.Tree
                                                              a>_N) of wild { Test.BTree leaf branches ->
                 Test.Tree @ a leaf branches }) -}
2b8039d4a97b7ffc3fe307ae41a5ec0f
  $fUnfoldableTree_$cgpostpro ::
    GHC.Base.Functor (Data.Functor.Foldable.Base (Test.Tree a)) =>
    forall a1 (m :: * -> *).
    (Data.Functor.Foldable.Foldable (Test.Tree a), GHC.Base.Monad m) =>
    (forall b.
     m (Data.Functor.Foldable.Base (Test.Tree a) b)
     -> Data.Functor.Foldable.Base (Test.Tree a) (m b))
    -> (forall c.
        Data.Functor.Foldable.Base (Test.Tree a) c
        -> Data.Functor.Foldable.Base (Test.Tree a) c)
    -> (a1 -> Data.Functor.Foldable.Base (Test.Tree a) (m a1))
    -> a1
    -> Test.Tree a
  {- Arity: 6, HasNoCafRefs,
     Strictness: <L,U(C(U),A)><L,U(U(C(U),A),U,A,A,A,A,A)><L,U(A,C(C1(U)),A,U,A)><L,C(U)><L,C(U)><L,C(U)>,
     Unfolding: (\ @ a
                   $dFunctor :: GHC.Base.Functor
                                  (Data.Functor.Foldable.Base (Test.Tree a))
                   @ a1
                   @ (m :: * -> *)
                   $dFoldable :: Data.Functor.Foldable.Foldable (Test.Tree a)
                   $dMonad :: GHC.Base.Monad m
                   eta :: forall b.
                          m (Data.Functor.Foldable.Base (Test.Tree a) b)
                          -> Data.Functor.Foldable.Base (Test.Tree a) (m b)
                   eta1 :: forall c.
                           Data.Functor.Foldable.Base (Test.Tree a) c
                           -> Data.Functor.Foldable.Base (Test.Tree a) c
                   eta2 :: a1 -> Data.Functor.Foldable.Base (Test.Tree a) (m a1) ->
                 letrec {
                   f1 :: Data.Functor.Foldable.Base (Test.Tree a) (m (m a1))
                         -> Data.Functor.Foldable.Base (Test.Tree a) (Test.Tree a)
                   = GHC.Base.fmap
                       @ (Data.Functor.Foldable.Base (Test.Tree a))
                       (Data.Functor.Foldable.$p1Foldable @ (Test.Tree a) $dFoldable)
                       @ (m (m a1))
                       @ (Test.Tree a)
                       (let {
                          g :: Test.Tree a
                               -> Data.Functor.Foldable.Base (Test.Tree a) (Test.Tree a)
                          = Data.Functor.Foldable.project @ (Test.Tree a) $dFoldable
                        } in
                        letrec {
                          a4 :: Test.Tree a -> Test.Tree a
                            {- Arity: 1, Strictness: <L,U>m, Inline: INLINE[0],
                               Unfolding: InlineRule (1, True, False)
                                          (\ w :: Test.Tree a ->
                                           case $wa3 w of ww { (#,#) ww1 ww2 ->
                                           Test.Tree @ a ww1 ww2 }) -}
                          = \ w :: Test.Tree a ->
                            case $wa3 w of ww { (#,#) ww1 ww2 -> Test.Tree @ a ww1 ww2 }
                          f2 :: Data.Functor.Foldable.Base (Test.Tree a) (Test.Tree a)
                                -> Data.Functor.Foldable.Base (Test.Tree a) (Test.Tree a)
                          = GHC.Base.fmap
                              @ (Data.Functor.Foldable.Base (Test.Tree a))
                              $dFunctor
                              @ (Test.Tree a)
                              @ (Test.Tree a)
                              a4
                          $wa3 :: Test.Tree a
                                  -> (# a,
                                        Data.IntMap.Base.IntMap
                                          (Data.Vector.Vector (Test.Tree a)) #)
                            {- Arity: 1, Strictness: <L,U>, Inline: [0] -}
                          = \ w :: Test.Tree a ->
                            case (f2 (eta1 @ (Test.Tree a) (g w)))
                                   `cast`
                                 (Sub (Test.TFCo:R:BaseTree[0] <a>_N) <Test.Tree
                                                                         a>_N) of wild { Test.BTree leaf branches ->
                            (# leaf, branches #) }
                        } in
                        \ x :: m (m a1) ->
                        case $wa3
                               (case $wa1
                                       (GHC.Base.join @ m @ a1 $dMonad x) of ww { (#,#) ww1 ww2 ->
                                Test.Tree @ a ww1 ww2 }) of ww { (#,#) ww1 ww2 ->
                        Test.Tree @ a ww1 ww2 })
                   $wa1 :: m a1
                           -> (# a,
                                 Data.IntMap.Base.IntMap (Data.Vector.Vector (Test.Tree a)) #)
                     {- Arity: 1, Strictness: <L,U>, Inline: [0] -}
                   = \ w :: m a1 ->
                     case (f1
                             (eta
                                @ (m a1)
                                (GHC.Base.liftM
                                   @ a1
                                   @ (Data.Functor.Foldable.Base (Test.Tree a) (m a1))
                                   @ m
                                   $dMonad
                                   eta2
                                   w)))
                            `cast`
                          (Sub (Test.TFCo:R:BaseTree[0] <a>_N) <Test.Tree
                                                                  a>_N) of wild { Test.BTree leaf branches ->
                     (# leaf, branches #) }
                 } in
                 let {
                   g :: a1 -> m a1 = GHC.Base.return @ m $dMonad @ a1
                 } in
                 \ x :: a1 ->
                 case $wa1 (g x) of ww { (#,#) ww1 ww2 ->
                 Test.Tree @ a ww1 ww2 }) -}
2b8039d4a97b7ffc3fe307ae41a5ec0f
  $fUnfoldableTree_$cpostpro ::
    GHC.Base.Functor (Data.Functor.Foldable.Base (Test.Tree a)) =>
    forall a1.
    Data.Functor.Foldable.Foldable (Test.Tree a) =>
    (forall b.
     Data.Functor.Foldable.Base (Test.Tree a) b
     -> Data.Functor.Foldable.Base (Test.Tree a) b)
    -> (a1 -> Data.Functor.Foldable.Base (Test.Tree a) a1)
    -> a1
    -> Test.Tree a
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(C(U),A)><L,U(U(C(U),A),U,A,A,A,A,A)><L,C(U)><L,C(U)>,
     Unfolding: (\ @ a
                   $dFunctor :: GHC.Base.Functor
                                  (Data.Functor.Foldable.Base (Test.Tree a))
                   @ a1
                   $dFoldable :: Data.Functor.Foldable.Foldable (Test.Tree a)
                   eta :: forall b.
                          Data.Functor.Foldable.Base (Test.Tree a) b
                          -> Data.Functor.Foldable.Base (Test.Tree a) b
                   eta1 :: a1 -> Data.Functor.Foldable.Base (Test.Tree a) a1 ->
                 letrec {
                   f1 :: Data.Functor.Foldable.Base (Test.Tree a) a1
                         -> Data.Functor.Foldable.Base (Test.Tree a) (Test.Tree a)
                   = GHC.Base.fmap
                       @ (Data.Functor.Foldable.Base (Test.Tree a))
                       (Data.Functor.Foldable.$p1Foldable @ (Test.Tree a) $dFoldable)
                       @ a1
                       @ (Test.Tree a)
                       (let {
                          g :: Test.Tree a
                               -> Data.Functor.Foldable.Base (Test.Tree a) (Test.Tree a)
                          = Data.Functor.Foldable.project @ (Test.Tree a) $dFoldable
                        } in
                        letrec {
                          a4 :: Test.Tree a -> Test.Tree a
                            {- Arity: 1, Strictness: <L,U>m, Inline: INLINE[0],
                               Unfolding: InlineRule (1, True, False)
                                          (\ w :: Test.Tree a ->
                                           case $wa3 w of ww { (#,#) ww1 ww2 ->
                                           Test.Tree @ a ww1 ww2 }) -}
                          = \ w :: Test.Tree a ->
                            case $wa3 w of ww { (#,#) ww1 ww2 -> Test.Tree @ a ww1 ww2 }
                          f2 :: Data.Functor.Foldable.Base (Test.Tree a) (Test.Tree a)
                                -> Data.Functor.Foldable.Base (Test.Tree a) (Test.Tree a)
                          = GHC.Base.fmap
                              @ (Data.Functor.Foldable.Base (Test.Tree a))
                              $dFunctor
                              @ (Test.Tree a)
                              @ (Test.Tree a)
                              a4
                          $wa3 :: Test.Tree a
                                  -> (# a,
                                        Data.IntMap.Base.IntMap
                                          (Data.Vector.Vector (Test.Tree a)) #)
                            {- Arity: 1, Strictness: <L,U>, Inline: [0] -}
                          = \ w :: Test.Tree a ->
                            case (f2 (eta @ (Test.Tree a) (g w)))
                                   `cast`
                                 (Sub (Test.TFCo:R:BaseTree[0] <a>_N) <Test.Tree
                                                                         a>_N) of wild { Test.BTree leaf branches ->
                            (# leaf, branches #) }
                        } in
                        \ x :: a1 ->
                        case $wa3
                               (case $wa1 x of ww { (#,#) ww1 ww2 ->
                                Test.Tree @ a ww1 ww2 }) of ww { (#,#) ww1 ww2 ->
                        Test.Tree @ a ww1 ww2 })
                   $wa1 :: a1
                           -> (# a,
                                 Data.IntMap.Base.IntMap (Data.Vector.Vector (Test.Tree a)) #)
                     {- Arity: 1, Strictness: <L,U>, Inline: [0] -}
                   = \ w :: a1 ->
                     case (f1 (eta1 w))
                            `cast`
                          (Sub (Test.TFCo:R:BaseTree[0] <a>_N) <Test.Tree
                                                                  a>_N) of wild { Test.BTree leaf branches ->
                     (# leaf, branches #) }
                 } in
                 let {
                   a4 :: a1 -> Test.Tree a
                     {- Arity: 1, Strictness: <L,U>m, Inline: INLINE[0],
                        Unfolding: InlineRule (1, True, False)
                                   (\ w :: a1 ->
                                    case $wa1 w of ww { (#,#) ww1 ww2 -> Test.Tree @ a ww1 ww2 }) -}
                   = \ w :: a1 ->
                     case $wa1 w of ww { (#,#) ww1 ww2 -> Test.Tree @ a ww1 ww2 }
                 } in
                 a4) -}
2b8039d4a97b7ffc3fe307ae41a5ec0f
  $w$capo ::
    Data.Functor.Foldable.Foldable (Test.Tree a) =>
    (a1
     -> Data.Functor.Foldable.Base
          (Test.Tree a) (Data.Either.Either (Test.Tree a) a1))
    -> a1 -> Test.Tree a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(U(C(U),A),A,A,A,A,A,A)><L,C(U)>, Inline: [0],
     Unfolding: (\ @ a
                   @ a1
                   w :: Data.Functor.Foldable.Foldable (Test.Tree a)
                   w1 :: a1
                         -> Data.Functor.Foldable.Base
                              (Test.Tree a) (Data.Either.Either (Test.Tree a) a1) ->
                 letrec {
                   f1 :: Data.Functor.Foldable.Base
                           (Test.Tree a) (Data.Either.Either (Test.Tree a) a1)
                         -> Data.Functor.Foldable.Base (Test.Tree a) (Test.Tree a)
                   = GHC.Base.fmap
                       @ (Data.Functor.Foldable.Base (Test.Tree a))
                       (Data.Functor.Foldable.$p1Foldable @ (Test.Tree a) w)
                       @ (Data.Either.Either (Test.Tree a) a1)
                       @ (Test.Tree a)
                       (\ ds1 :: Data.Either.Either (Test.Tree a) a1 ->
                        case ds1 of wild {
                          Data.Either.Left x -> x
                          Data.Either.Right y
                          -> case $wa1 y of ww { (#,#) ww1 ww2 -> Test.Tree @ a ww1 ww2 } })
                   $wa1 :: a1
                           -> (# a,
                                 Data.IntMap.Base.IntMap (Data.Vector.Vector (Test.Tree a)) #)
                     {- Arity: 1, Strictness: <L,U>, Inline: [0] -}
                   = \ w2 :: a1 ->
                     case (f1 (w1 w2))
                            `cast`
                          (Sub (Test.TFCo:R:BaseTree[0] <a>_N) <Test.Tree
                                                                  a>_N) of wild { Test.BTree leaf branches ->
                     (# leaf, branches #) }
                 } in
                 let {
                   a3 :: a1 -> Test.Tree a
                     {- Arity: 1, Strictness: <L,U>m, Inline: INLINE[0],
                        Unfolding: InlineRule (1, True, False)
                                   (\ w2 :: a1 ->
                                    case $wa1 w2 of ww { (#,#) ww1 ww2 ->
                                    Test.Tree @ a ww1 ww2 }) -}
                   = \ w2 :: a1 ->
                     case $wa1 w2 of ww { (#,#) ww1 ww2 -> Test.Tree @ a ww1 ww2 }
                 } in
                 a3) -}
b829169d58b9378c7f20971f304cf84c
  $w$cfmap ::
    (a1 -> b)
    -> a
    -> Data.IntMap.Base.IntMap (Data.Vector.Vector a1)
    -> (# a, Data.IntMap.Base.IntMap (Data.Vector.Vector b) #)
  {- Arity: 3, Strictness: <L,C(U)><L,U><L,1*U>, Inline: [0],
     Unfolding: (\ @ a
                   @ a1
                   @ b
                   w :: a1 -> b
                   ww :: a
                   ww1 :: Data.IntMap.Base.IntMap (Data.Vector.Vector a1) ->
                 (# ww,
                    Data.IntMap.Strict.map
                      @ (Data.Vector.Vector a1)
                      @ (Data.Vector.Vector b)
                      (\ eta :: Data.Vector.Vector a1 ->
                       case eta of v2 { Data.Vector.Vector ipv ipv1 ipv2 ->
                       GHC.ST.runSTRep
                         @ (Data.Vector.Vector b)
                         (\ @ s s1 :: GHC.Prim.State# s[OneShot] ->
                          case GHC.Prim.newArray#
                                 @ b
                                 @ (Control.Monad.Primitive.PrimState (GHC.ST.ST s))
                                 ipv1
                                 (Data.Vector.Mutable.uninitialised @ b)
                                 s1
                                   `cast`
                                 (GHC.Prim.State#
                                    (Sym (Control.Monad.Primitive.TFCo:R:PrimStateST[0]
                                              <s>_N)))_R of ds1 { (#,#) ipv3 ipv4 ->
                          letrec {
                            $wa :: GHC.Types.SPEC
                                   -> GHC.Prim.Int#
                                   -> GHC.Prim.Int#
                                   -> GHC.Prim.State# s
                                   -> (# GHC.Prim.State# s, GHC.Types.Int #)
                              {- Arity: 4, Strictness: <S,1*U><L,U><L,U><L,U>, Inline: [0] -}
                            = \ w1 :: GHC.Types.SPEC
                                ww2 :: GHC.Prim.Int#
                                ww3 :: GHC.Prim.Int#
                                w2 :: GHC.Prim.State# s[OneShot] ->
                              case w1 of ds5 { DEFAULT ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww3 ipv1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.writeArray#
                                          @ (Control.Monad.Primitive.PrimState (GHC.ST.ST s))
                                          @ b
                                          ipv4
                                          ww2
                                          (case GHC.Prim.indexArray#
                                                  @ a1
                                                  ipv2
                                                  (GHC.Prim.+# ipv ww3) of ds2 { (##) ipv5 ->
                                           w ipv5 })
                                          w2
                                            `cast`
                                          (GHC.Prim.State#
                                             (Sym (Control.Monad.Primitive.TFCo:R:PrimStateST[0]
                                                       <s>_N)))_R of s'# { DEFAULT ->
                                   $wa
                                     GHC.Types.SPEC
                                     (GHC.Prim.+# ww2 1)
                                     (GHC.Prim.+# ww3 1)
                                     s'#
                                       `cast`
                                     (GHC.Prim.State#
                                        (Control.Monad.Primitive.TFCo:R:PrimStateST[0] <s>_N))_R }
                                GHC.Types.True -> (# w2, GHC.Types.I# ww2 #) } }
                          } in
                          case $wa
                                 GHC.Types.SPEC
                                 0
                                 0
                                 ipv3
                                   `cast`
                                 (GHC.Prim.State#
                                    (Control.Monad.Primitive.TFCo:R:PrimStateST[0]
                                         <s>_N))_R of ds2 { (#,#) ipv6 ipv7 ->
                          case ipv7 of dt5 { GHC.Types.I# dt6 ->
                          case GHC.Prim.unsafeFreezeArray#
                                 @ (Control.Monad.Primitive.PrimState (GHC.ST.ST s))
                                 @ b
                                 ipv4
                                 ipv6
                                   `cast`
                                 (GHC.Prim.State#
                                    (Sym (Control.Monad.Primitive.TFCo:R:PrimStateST[0]
                                              <s>_N)))_R of ds4 { (#,#) ipv5 ipv9 ->
                          (# ipv5
                               `cast`
                             (GHC.Prim.State#
                                (Control.Monad.Primitive.TFCo:R:PrimStateST[0] <s>_N))_R,
                             Data.Vector.Vector @ b 0 dt6 ipv9 #) } } } }) })
                      ww1 #)) -}
c84406aca2f8b5cac8bffb3063d3462b
  $wa2 ::
    Data.IntSet.Base.Key
    -> (# GHC.Types.Int,
          Data.IntMap.Base.IntMap
            (Data.Vector.Vector (Test.Tree GHC.Types.Int)) #)
  {- Arity: 1, Strictness: <L,U(U)>, Inline: [0] -}
2b8039d4a97b7ffc3fe307ae41a5ec0f
  data BTree a b
    = BTree a (Data.IntMap.Base.IntMap (Data.Vector.Vector b))
2b8039d4a97b7ffc3fe307ae41a5ec0f
  axiom TFCo:R:BaseTree::
      Data.Functor.Foldable.Base (Test.Tree a) = Test.BTree a
2b8039d4a97b7ffc3fe307ae41a5ec0f
  data Tree a
    = Tree a
           (Data.IntMap.Base.IntMap (Data.Vector.Vector (Test.Tree a)))
    RecFlag: Recursive
3b095cd6d0f4b1282e698a64a928b99a
  generateTree :: GHC.Types.Int -> Test.Tree GHC.Types.Int
  {- Arity: 1, Strictness: <L,U(U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case Test.$wa2 w of ww { (#,#) ww1 ww2 ->
                 Test.Tree @ GHC.Types.Int ww1 ww2 }) -}
7b9d47c8a7c3dbbdffb1951d262b33ee
  takeTree :: GHC.Types.Int -> Test.Tree a -> Test.Tree a
  {- Strictness: b,
     Unfolding: InlineRule (0, True, True)
                (\ @ a ->
                 GHC.Err.undefined
                   @ (GHC.Types.Int -> Test.Tree a -> Test.Tree a)) -}
instance Data.Functor.Foldable.Foldable [Test.Tree]
  = Test.$fFoldableTree
instance GHC.Base.Functor [Test.BTree] = Test.$fFunctorBTree
instance GHC.Show.Show [Test.Tree] = Test.$fShowTree
instance Data.Functor.Foldable.Unfoldable [Test.Tree]
  = Test.$fUnfoldableTree
family instance Data.Functor.Foldable.Base [Test.Tree]
  = Test.TFCo:R:BaseTree
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

