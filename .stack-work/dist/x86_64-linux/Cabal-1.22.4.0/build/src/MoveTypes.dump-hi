
==================== FINAL INTERFACE ====================
2016-01-02 04:04:57.87924 UTC

interface hches_KF6MDI5eODG4Q8cKhuw0mn:MoveTypes [family instance module] 7102
  interface hash: cfe9d6a430171b094ae20be6faa8a752
  ABI hash: 037506a59a7cfcb7817533d6dc2ef4c1
  export-list hash: 498b71925c658336be41ddd6cd272aaa
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 963eed8901a42deb2fbed49c5293189c
  sig of: Nothing
  used TH splices: True
  where
exports:
  MoveTypes.Bishop
  MoveTypes.Knight
  MoveTypes.Queen
  MoveTypes.Rook
  MoveTypes.moveToDoc
  MoveTypes.promotionToDoc
  MoveTypes.promotionTypeToDoc
  MoveTypes.Move{MoveTypes.Move MoveTypes.from MoveTypes.to}
  MoveTypes.Moves{MoveTypes.Moves MoveTypes.moves MoveTypes.promotions}
  MoveTypes.Promotion{MoveTypes.Promotion MoveTypes.move MoveTypes.pType}
  MoveTypes.PromotionType{MoveTypes.PromotionType}
  Data.Vector.Unboxed.Base.MVector|{MoveTypes.MV_Move MoveTypes.MV_Promotion}
  Data.Vector.Unboxed.Base.Vector|{MoveTypes.V_Move MoveTypes.V_Promotion}
module dependencies: BitBoard Board FEN Index Utils
package dependencies: ansi-terminal-0.6.2.3@ansit_KW0LUY2zB7JCYzE4ZYrwBg
                      ansi-wl-pprint-0.6.7.3@ansiw_KPlSW7tbqXS51Lj59n3FC4
                      array-0.5.1.0@array_E0sTtauuKsGDLZoT7lTbgZ
                      attoparsec-0.13.0.1@attop_FtJZAZu3GDOJSwmSRnXnPH base-4.8.1.0
                      binary-0.7.5.0@binar_IvYoLp9H6Xy3zEH13MmZwd
                      bytestring-0.10.6.0@bytes_6elQVSg5cWdFrvRnfxTUrH
                      containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN
                      deepseq-1.4.1.1@deeps_LbCWUlehDDeLxurARKDH5o ghc-prim-0.4.0.0
                      hashable-1.2.3.3@hasha_2GTZqecVp8NJZrNuKzGxfy integer-gmp-1.0.0.0
                      pretty-1.1.2.0@prett_7UQTOB05U7lIYPkFOVraeR
                      primitive-0.6.1.0@primi_5Jnw7oEuYtM9dmKXelGXVb
                      scientific-0.3.4.4@scien_03wvk1zJytY0wVzR42F1U4
                      template-haskell-2.10.0.0 text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh
                      transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X
                      vector-th-unbox-0.2.1.3@vecto_7UKBkJbwJOEKV3lSwERBE0
                      vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF
orphans: attoparsec-0.13.0.1@attop_FtJZAZu3GDOJSwmSRnXnPH:Data.Attoparsec.ByteString.Char8
         base-4.8.1.0:GHC.Base base-4.8.1.0:GHC.Float
         binary-0.7.5.0@binar_IvYoLp9H6Xy3zEH13MmZwd:Data.Binary.Generic
         bytestring-0.10.6.0@bytes_6elQVSg5cWdFrvRnfxTUrH:Data.ByteString.Builder
         hashable-1.2.3.3@hasha_2GTZqecVp8NJZrNuKzGxfy:Data.Hashable.Generic
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Lazy
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Show
         transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X:Control.Monad.Trans.Error
         vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector.Fusion.Bundle
         vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector.Unboxed
family instance modules: attoparsec-0.13.0.1@attop_FtJZAZu3GDOJSwmSRnXnPH:Data.Attoparsec.Internal.Types
                         base-4.8.1.0:Control.Applicative base-4.8.1.0:Data.Either
                         base-4.8.1.0:Data.Functor.Identity base-4.8.1.0:Data.Monoid
                         base-4.8.1.0:Data.Type.Equality base-4.8.1.0:Data.Void
                         base-4.8.1.0:GHC.Exts base-4.8.1.0:GHC.Generics
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntMap.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntSet.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Map.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Sequence
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Set.Base
                         pretty-1.1.2.0@prett_7UQTOB05U7lIYPkFOVraeR:Text.PrettyPrint.HughesPJ
                         primitive-0.6.1.0@primi_5Jnw7oEuYtM9dmKXelGXVb:Control.Monad.Primitive
                         template-haskell-2.10.0.0:Language.Haskell.TH.Syntax
                         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text
                         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Lazy
                         vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector
                         vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector.Primitive
                         vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector.Unboxed
                         vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector.Unboxed.Base
import  -/  ansi-wl-pprint-0.6.7.3@ansiw_KPlSW7tbqXS51Lj59n3FC4:Text.PrettyPrint.ANSI.Leijen 8c4176551c95005818f5e57d74e5ea69
import  -/  base-4.8.1.0:Data.Bits 5341167fdd5958c2b3f0dac8924f1efd
import  -/  base-4.8.1.0:Data.Tuple 012ad951a59a9d85fe1de36a2f012986
import  -/  base-4.8.1.0:Data.Word 448c480b98a0c18988a37db5ab829b22
import  -/  base-4.8.1.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.1.0:GHC.Show b8c65ca3124f92a166c9f05120382442
import  -/  base-4.8.1.0:GHC.Word ef6286c279d61931eb675109b4b93579
import  -/  base-4.8.1.0:Prelude 518f762991bc287d78f21a73c974da1f
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  BitBoard 3c244b8ec8b253f65c50911201be3573
  exports: ad24690e2a3640cdb930e8fadfacb8b5
import  -/  Board 1137853594eeb2bf744304f00d9faa6d
  exports: 0920de90788b9006e313d85981d5679a
import  -/  Index 9a6c2fae8693bbf252fe29180f05c4cb
  exports: f5dacf2693e1be2d2c1d237e19d3ec25
  Index 117acc87da1ca0c97ed41ed158620142
  indexToDoc 95b611e988f9f152a46f50871a4f0423
import  -/  vector-th-unbox-0.2.1.3@vecto_7UKBkJbwJOEKV3lSwERBE0:Data.Vector.Unboxed.Deriving ca39b75552a17b45193a0bf900b2bb7a
import  -/  vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector.Generic.Base f9e814d2cdc449478d6b1a8e12059519
import  -/  vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector.Generic.Mutable.Base 74328ab2ccb574f6522896e090906e9d
import  -/  vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector.Unboxed 8bd91cd1a3cd2cbd12faec978422ccd8
import  -/  vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector.Unboxed.Base 0761e27d6792efb778c5ac79292248a5
24f475939d5d9fc6d72491ae555f4744
  $bBishop :: MoveTypes.PromotionType
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                MoveTypes.$bBishop1
                  `cast`
                (Sym (MoveTypes.NTCo:PromotionType[0])) -}
b7728d3251c34f884e882d8658d78caf
  $bBishop1 :: GHC.Word.Word8
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Word.W8# __word 1) -}
3f434c5c61dea12c943c995358e2239e
  $bKnight :: MoveTypes.PromotionType
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                MoveTypes.$bKnight1
                  `cast`
                (Sym (MoveTypes.NTCo:PromotionType[0])) -}
200c29818275d13863c417a3a6162b2b
  $bKnight1 :: GHC.Word.Word8
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Word.W8# __word 0) -}
eed9de6c341261a1bf4a28ae5fbb9d3d
  $bQueen :: MoveTypes.PromotionType
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                MoveTypes.$bQueen1
                  `cast`
                (Sym (MoveTypes.NTCo:PromotionType[0])) -}
945af0446fa31dbd3dd8abb7f705de5a
  $bQueen1 :: GHC.Word.Word8
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Word.W8# __word 3) -}
37c20135f034e17ff51a0bd4e0339c87
  $bRook :: MoveTypes.PromotionType
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                MoveTypes.$bRook1 `cast` (Sym (MoveTypes.NTCo:PromotionType[0])) -}
21bf3594e7a247c0d5ff91f93737f804
  $bRook1 :: GHC.Word.Word8
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Word.W8# __word 2) -}
f87b40583b48531412a65b59dc7a4f4f
  $fMVectorMVectorMove ::
    Data.Vector.Generic.Mutable.Base.MVector
      Data.Vector.Unboxed.Base.MVector MoveTypes.Move
  DFunId[0]
  {- Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Vector.Unboxed.Base.MVector
                  @ MoveTypes.Move
                  MoveTypes.$fMVectorMVectorMove_$cbasicLength
                  MoveTypes.$fMVectorMVectorMove_$cbasicUnsafeSlice
                  MoveTypes.$fMVectorMVectorMove_$cbasicOverlaps
                  MoveTypes.$fMVectorMVectorMove_$cbasicUnsafeNew
                  MoveTypes.$fMVectorMVectorMove_$cbasicInitialize
                  MoveTypes.$fMVectorMVectorMove_$cbasicUnsafeReplicate
                  MoveTypes.$fMVectorMVectorMove_$cbasicUnsafeRead
                  MoveTypes.$fMVectorMVectorMove_$cbasicUnsafeWrite
                  MoveTypes.$fMVectorMVectorMove_$cbasicClear
                  MoveTypes.$fMVectorMVectorMove_$cbasicSet
                  MoveTypes.$fMVectorMVectorMove_$cbasicUnsafeCopy
                  MoveTypes.$fMVectorMVectorMove_$cbasicUnsafeMove
                  MoveTypes.$fMVectorMVectorMove_$cbasicUnsafeGrow -}
f87b40583b48531412a65b59dc7a4f4f
  $fMVectorMVectorMove_$cbasicClear ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Unboxed.Base.MVector
      (Control.Monad.Primitive.PrimState m) MoveTypes.Move
    -> m ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(LLC(C(S))LL)L),U(U(A,A,1*C1(C1(U)),C(U),A),A)><S,1*U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   ds :: Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m) MoveTypes.Move ->
                 GHC.Prim.seq
                   @ (Data.Vector.Unboxed.Base.MVector
                        (Control.Monad.Primitive.PrimState m) MoveTypes.Move)
                   @ (m ())
                   ds
                   (GHC.Base.>>
                      @ m
                      (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                      @ ()
                      @ ()
                      (GHC.Base.return
                         @ m
                         (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                         @ ()
                         GHC.Tuple.())
                      (GHC.Base.return
                         @ m
                         (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                         @ ()
                         GHC.Tuple.()))) -}
f87b40583b48531412a65b59dc7a4f4f
  $fMVectorMVectorMove_$cbasicInitialize ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Unboxed.Base.MVector
      (Control.Monad.Primitive.PrimState m) MoveTypes.Move
    -> m ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(LLC(C(S))LL)L),U(1*U(A,A,1*C1(C1(U)),A,A),C(U))><S(LSS),1*U(A,U(U,U,U),U(U,U,U))>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   ds :: Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m) MoveTypes.Move ->
                 case ds
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:MVectorsMove[0]
                                     <Control.Monad.Primitive.PrimState m>_N))
                           (Trans
                                (MoveTypes.NTCo:R:MVectorsMove[0]
                                     <Control.Monad.Primitive.PrimState m>_N)
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,)[0]
                                          <Control.Monad.Primitive.PrimState m>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N)))) of wild { Data.Vector.Unboxed.Base.MV_2 dt as bs ->
                 GHC.Base.>>
                   @ m
                   (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                   @ ()
                   @ ()
                   (case as
                           `cast`
                         (Trans
                              (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                        <Control.Monad.Primitive.PrimState m>_N))
                              (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                   <Control.Monad.Primitive.PrimState
                                      m>_N)) of wild1 { Data.Vector.Primitive.Mutable.MVector dt1 dt2 dt3 ->
                    let {
                      size :: GHC.Types.Int
                      = Data.Vector.Primitive.$fVectorVectora_$ssizeOf
                          (GHC.Err.undefined @ GHC.Types.Int)
                    } in
                    case GHC.Num.$fNumInt_$c*
                           (GHC.Types.I# dt1)
                           size of wild2 { GHC.Types.I# doff# ->
                    case GHC.Num.$fNumInt_$c*
                           (GHC.Types.I# dt2)
                           size of wild3 { GHC.Types.I# sz# ->
                    Control.Monad.Primitive.primitive
                      @ m
                      $dPrimMonad
                      @ ()
                      (\ s# :: GHC.Prim.State#
                                 (Control.Monad.Primitive.PrimState m)[OneShot] ->
                       case GHC.Word.$cfromInteger
                              __integer 0 of wild4 { GHC.Word.W8# x# ->
                       case GHC.Base.id
                              @ GHC.Types.Int
                              (GHC.Types.I# doff#) of wild5 { GHC.Types.I# x#1 ->
                       case ((Data.Primitive.Internal.Operations.setWord8Array#
                                @ (Control.Monad.Primitive.PrimState m)
                                dt3
                                (GHC.Int.I64# x#1) `cast` (Sym (Foreign.C.Types.NTCo:CPtrdiff[0]))
                                (GHC.Word.W64# (GHC.Prim.int2Word# sz#))
                                  `cast`
                                (Sym (Foreign.C.Types.NTCo:CSize[0]))
                                x#)
                               `cast`
                             (Trans
                                  (GHC.Types.NTCo:IO[0] <()>_R)
                                  ((GHC.Prim.State#
                                      (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R
                                   ->_R ((# (GHC.Prim.State#
                                               (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R,
                                            <()>_R #))_R))
                               s#
                                 `cast`
                               (GHC.Prim.State#
                                  (Trans
                                       (UnivCo mkUnsafeCo nominal (Control.Monad.Primitive.PrimState
                                                                     m) GHC.Prim.RealWorld)
                                       (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0]))))_R)
                              `cast`
                            ((# (GHC.Prim.State#
                                   (Trans
                                        (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])
                                        (UnivCo mkUnsafeCo nominal GHC.Prim.RealWorld (Control.Monad.Primitive.PrimState
                                                                                         m))))_R,
                                UnivCo mkUnsafeCo representational () GHC.Prim.Any #))_R of ds1 { (#,#) ipv ipv1 ->
                       (# ipv, GHC.Tuple.() #) } } }) } } })
                   (case bs
                           `cast`
                         (Trans
                              (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                        <Control.Monad.Primitive.PrimState m>_N))
                              (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                   <Control.Monad.Primitive.PrimState
                                      m>_N)) of wild1 { Data.Vector.Primitive.Mutable.MVector dt1 dt2 dt3 ->
                    let {
                      size :: GHC.Types.Int
                      = Data.Vector.Primitive.$fVectorVectora_$ssizeOf
                          (GHC.Err.undefined @ GHC.Types.Int)
                    } in
                    case GHC.Num.$fNumInt_$c*
                           (GHC.Types.I# dt1)
                           size of wild2 { GHC.Types.I# doff# ->
                    case GHC.Num.$fNumInt_$c*
                           (GHC.Types.I# dt2)
                           size of wild3 { GHC.Types.I# sz# ->
                    Control.Monad.Primitive.primitive
                      @ m
                      $dPrimMonad
                      @ ()
                      (\ s# :: GHC.Prim.State#
                                 (Control.Monad.Primitive.PrimState m)[OneShot] ->
                       case GHC.Word.$cfromInteger
                              __integer 0 of wild4 { GHC.Word.W8# x# ->
                       case GHC.Base.id
                              @ GHC.Types.Int
                              (GHC.Types.I# doff#) of wild5 { GHC.Types.I# x#1 ->
                       case ((Data.Primitive.Internal.Operations.setWord8Array#
                                @ (Control.Monad.Primitive.PrimState m)
                                dt3
                                (GHC.Int.I64# x#1) `cast` (Sym (Foreign.C.Types.NTCo:CPtrdiff[0]))
                                (GHC.Word.W64# (GHC.Prim.int2Word# sz#))
                                  `cast`
                                (Sym (Foreign.C.Types.NTCo:CSize[0]))
                                x#)
                               `cast`
                             (Trans
                                  (GHC.Types.NTCo:IO[0] <()>_R)
                                  ((GHC.Prim.State#
                                      (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R
                                   ->_R ((# (GHC.Prim.State#
                                               (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R,
                                            <()>_R #))_R))
                               s#
                                 `cast`
                               (GHC.Prim.State#
                                  (Trans
                                       (UnivCo mkUnsafeCo nominal (Control.Monad.Primitive.PrimState
                                                                     m) GHC.Prim.RealWorld)
                                       (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0]))))_R)
                              `cast`
                            ((# (GHC.Prim.State#
                                   (Trans
                                        (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])
                                        (UnivCo mkUnsafeCo nominal GHC.Prim.RealWorld (Control.Monad.Primitive.PrimState
                                                                                         m))))_R,
                                UnivCo mkUnsafeCo representational () GHC.Prim.Any #))_R of ds1 { (#,#) ipv ipv1 ->
                       (# ipv, GHC.Tuple.() #) } } }) } } }) }) -}
f87b40583b48531412a65b59dc7a4f4f
  $fMVectorMVectorMove_$cbasicLength ::
    Data.Vector.Unboxed.Base.MVector s MoveTypes.Move -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSS),1*U(U,1*H,1*H)>m,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ s ds :: Data.Vector.Unboxed.Base.MVector s MoveTypes.Move ->
                 case ds
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:MVectorsMove[0] <s>_N))
                           (Trans
                                (MoveTypes.NTCo:R:MVectorsMove[0] <s>_N)
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,)[0]
                                          <s>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N)))) of wild { Data.Vector.Unboxed.Base.MV_2 dt ds1 ds2 ->
                 GHC.Types.I# dt }) -}
f87b40583b48531412a65b59dc7a4f4f
  $fMVectorMVectorMove_$cbasicOverlaps ::
    Data.Vector.Unboxed.Base.MVector s MoveTypes.Move
    -> Data.Vector.Unboxed.Base.MVector s MoveTypes.Move
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LSS),1*U(A,U(U,U,U),U(U,U,U))><S,1*U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   ds :: Data.Vector.Unboxed.Base.MVector s MoveTypes.Move
                   ds1 :: Data.Vector.Unboxed.Base.MVector s MoveTypes.Move ->
                 case ds
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:MVectorsMove[0] <s>_N))
                           (Trans
                                (MoveTypes.NTCo:R:MVectorsMove[0] <s>_N)
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,)[0]
                                          <s>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N)))) of wild { Data.Vector.Unboxed.Base.MV_2 dt as1 bs1 ->
                 case ds1
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:MVectorsMove[0] <s>_N))
                           (Trans
                                (MoveTypes.NTCo:R:MVectorsMove[0] <s>_N)
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,)[0]
                                          <s>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N)))) of wild1 { Data.Vector.Unboxed.Base.MV_2 dt1 as2 bs2 ->
                 case as1
                        `cast`
                      (Trans
                           (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0] <s>_N))
                           (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                <s>_N)) of wild2 { Data.Vector.Primitive.Mutable.MVector dt2 dt3 dt4 ->
                 let {
                   i :: GHC.Types.Int = GHC.Types.I# dt2
                 } in
                 case as2
                        `cast`
                      (Trans
                           (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0] <s>_N))
                           (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                <s>_N)) of wild3 { Data.Vector.Primitive.Mutable.MVector dt5 dt6 dt7 ->
                 let {
                   j :: GHC.Types.Int = GHC.Types.I# dt5
                 } in
                 let {
                   between :: forall a8.
                              GHC.Classes.Ord a8 =>
                              a8 -> a8 -> a8 -> GHC.Types.Bool
                     {- Arity: 4 -}
                   = \ @ a8 $dOrd :: GHC.Classes.Ord a8 x :: a8 y :: a8 z :: a8 ->
                     GHC.Classes.&&
                       (GHC.Classes.>= @ a8 $dOrd x y)
                       (GHC.Classes.< @ a8 $dOrd x z)
                 } in
                 GHC.Classes.||
                   (GHC.Classes.&&
                      (GHC.Prim.tagToEnum#
                         @ GHC.Types.Bool
                         (GHC.Prim.sameMutableByteArray# @ s dt4 dt7))
                      (GHC.Classes.||
                         (between
                            @ GHC.Types.Int
                            GHC.Classes.$fOrdInt
                            i
                            j
                            (GHC.Num.$fNumInt_$c+ j (GHC.Types.I# dt6)))
                         (between
                            @ GHC.Types.Int
                            GHC.Classes.$fOrdInt
                            j
                            i
                            (GHC.Num.$fNumInt_$c+ i (GHC.Types.I# dt3)))))
                   (case bs1
                           `cast`
                         (Trans
                              (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0] <s>_N))
                              (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                   <s>_N)) of wild4 { Data.Vector.Primitive.Mutable.MVector dt8 dt9 dt10 ->
                    let {
                      i1 :: GHC.Types.Int = GHC.Types.I# dt8
                    } in
                    case bs2
                           `cast`
                         (Trans
                              (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0] <s>_N))
                              (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                   <s>_N)) of wild5 { Data.Vector.Primitive.Mutable.MVector dt11 dt12 dt13 ->
                    let {
                      j1 :: GHC.Types.Int = GHC.Types.I# dt11
                    } in
                    let {
                      between1 :: forall a8.
                                  GHC.Classes.Ord a8 =>
                                  a8 -> a8 -> a8 -> GHC.Types.Bool
                        {- Arity: 4 -}
                      = \ @ a8 $dOrd :: GHC.Classes.Ord a8 x :: a8 y :: a8 z :: a8 ->
                        GHC.Classes.&&
                          (GHC.Classes.>= @ a8 $dOrd x y)
                          (GHC.Classes.< @ a8 $dOrd x z)
                    } in
                    GHC.Classes.&&
                      (GHC.Prim.tagToEnum#
                         @ GHC.Types.Bool
                         (GHC.Prim.sameMutableByteArray# @ s dt10 dt13))
                      (GHC.Classes.||
                         (between1
                            @ GHC.Types.Int
                            GHC.Classes.$fOrdInt
                            i1
                            j1
                            (GHC.Num.$fNumInt_$c+ j1 (GHC.Types.I# dt12)))
                         (between1
                            @ GHC.Types.Int
                            GHC.Classes.$fOrdInt
                            j1
                            i1
                            (GHC.Num.$fNumInt_$c+ i1 (GHC.Types.I# dt9)))) } }) } } } }) -}
f87b40583b48531412a65b59dc7a4f4f
  $fMVectorMVectorMove_$cbasicSet ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Unboxed.Base.MVector
      (Control.Monad.Primitive.PrimState m) MoveTypes.Move
    -> MoveTypes.Move -> m ()
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(LLC(C(S))LL)L),U(1*U(A,A,1*C1(C1(U)),A,A),C(U))><S(LSS),1*U(A,U(U,U,U),U(U,U,U))><S,1*U(U,U)>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   ds :: Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m) MoveTypes.Move
                   val :: MoveTypes.Move ->
                 case ds
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:MVectorsMove[0]
                                     <Control.Monad.Primitive.PrimState m>_N))
                           (Trans
                                (MoveTypes.NTCo:R:MVectorsMove[0]
                                     <Control.Monad.Primitive.PrimState m>_N)
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,)[0]
                                          <Control.Monad.Primitive.PrimState m>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N)))) of wild { Data.Vector.Unboxed.Base.MV_2 dt as bs ->
                 case val of wild1 { MoveTypes.Move dt1 dt2 ->
                 GHC.Base.>>
                   @ m
                   (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                   @ ()
                   @ ()
                   (case as
                           `cast`
                         (Trans
                              (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                        <Control.Monad.Primitive.PrimState m>_N))
                              (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                   <Control.Monad.Primitive.PrimState
                                      m>_N)) of wild2 { Data.Vector.Primitive.Mutable.MVector dt3 dt4 dt5 ->
                    Control.Monad.Primitive.primitive
                      @ m
                      $dPrimMonad
                      @ ()
                      (\ s# :: GHC.Prim.State#
                                 (Control.Monad.Primitive.PrimState m)[OneShot] ->
                       case GHC.Base.id
                              @ GHC.Types.Int
                              (GHC.Types.I# dt3) of wild3 { GHC.Types.I# x#1 ->
                       case ((Data.Primitive.Internal.Operations.setIntArray#
                                @ (Control.Monad.Primitive.PrimState m)
                                dt5
                                (GHC.Int.I64# x#1) `cast` (Sym (Foreign.C.Types.NTCo:CPtrdiff[0]))
                                (GHC.Word.W64# (GHC.Prim.int2Word# dt4))
                                  `cast`
                                (Sym (Foreign.C.Types.NTCo:CSize[0]))
                                dt1)
                               `cast`
                             (Trans
                                  (GHC.Types.NTCo:IO[0] <()>_R)
                                  ((GHC.Prim.State#
                                      (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R
                                   ->_R ((# (GHC.Prim.State#
                                               (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R,
                                            <()>_R #))_R))
                               s#
                                 `cast`
                               (GHC.Prim.State#
                                  (Trans
                                       (UnivCo mkUnsafeCo nominal (Control.Monad.Primitive.PrimState
                                                                     m) GHC.Prim.RealWorld)
                                       (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0]))))_R)
                              `cast`
                            ((# (GHC.Prim.State#
                                   (Trans
                                        (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])
                                        (UnivCo mkUnsafeCo nominal GHC.Prim.RealWorld (Control.Monad.Primitive.PrimState
                                                                                         m))))_R,
                                UnivCo mkUnsafeCo representational () GHC.Prim.Any #))_R of ds1 { (#,#) ipv ipv1 ->
                       (# ipv, GHC.Tuple.() #) } }) })
                   (case bs
                           `cast`
                         (Trans
                              (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                        <Control.Monad.Primitive.PrimState m>_N))
                              (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                   <Control.Monad.Primitive.PrimState
                                      m>_N)) of wild2 { Data.Vector.Primitive.Mutable.MVector dt3 dt4 dt5 ->
                    Control.Monad.Primitive.primitive
                      @ m
                      $dPrimMonad
                      @ ()
                      (\ s# :: GHC.Prim.State#
                                 (Control.Monad.Primitive.PrimState m)[OneShot] ->
                       case GHC.Base.id
                              @ GHC.Types.Int
                              (GHC.Types.I# dt3) of wild3 { GHC.Types.I# x#1 ->
                       case ((Data.Primitive.Internal.Operations.setIntArray#
                                @ (Control.Monad.Primitive.PrimState m)
                                dt5
                                (GHC.Int.I64# x#1) `cast` (Sym (Foreign.C.Types.NTCo:CPtrdiff[0]))
                                (GHC.Word.W64# (GHC.Prim.int2Word# dt4))
                                  `cast`
                                (Sym (Foreign.C.Types.NTCo:CSize[0]))
                                dt2)
                               `cast`
                             (Trans
                                  (GHC.Types.NTCo:IO[0] <()>_R)
                                  ((GHC.Prim.State#
                                      (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R
                                   ->_R ((# (GHC.Prim.State#
                                               (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R,
                                            <()>_R #))_R))
                               s#
                                 `cast`
                               (GHC.Prim.State#
                                  (Trans
                                       (UnivCo mkUnsafeCo nominal (Control.Monad.Primitive.PrimState
                                                                     m) GHC.Prim.RealWorld)
                                       (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0]))))_R)
                              `cast`
                            ((# (GHC.Prim.State#
                                   (Trans
                                        (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])
                                        (UnivCo mkUnsafeCo nominal GHC.Prim.RealWorld (Control.Monad.Primitive.PrimState
                                                                                         m))))_R,
                                UnivCo mkUnsafeCo representational () GHC.Prim.Any #))_R of ds1 { (#,#) ipv ipv1 ->
                       (# ipv, GHC.Tuple.() #) } }) }) } }) -}
f87b40583b48531412a65b59dc7a4f4f
  $fMVectorMVectorMove_$cbasicUnsafeCopy ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Unboxed.Base.MVector
      (Control.Monad.Primitive.PrimState m) MoveTypes.Move
    -> Data.Vector.Unboxed.Base.MVector
         (Control.Monad.Primitive.PrimState m) MoveTypes.Move
    -> m ()
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(LLC(C(S))LL)L),U(1*U(A,A,1*C1(C1(U)),A,A),C(U))><S(LSS),1*U(A,U(U,U,U),U(U,U,U))><S,1*U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   ds :: Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m) MoveTypes.Move
                   ds1 :: Data.Vector.Unboxed.Base.MVector
                            (Control.Monad.Primitive.PrimState m) MoveTypes.Move ->
                 case ds
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:MVectorsMove[0]
                                     <Control.Monad.Primitive.PrimState m>_N))
                           (Trans
                                (MoveTypes.NTCo:R:MVectorsMove[0]
                                     <Control.Monad.Primitive.PrimState m>_N)
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,)[0]
                                          <Control.Monad.Primitive.PrimState m>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N)))) of wild { Data.Vector.Unboxed.Base.MV_2 dt as1 bs1 ->
                 case ds1
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:MVectorsMove[0]
                                     <Control.Monad.Primitive.PrimState m>_N))
                           (Trans
                                (MoveTypes.NTCo:R:MVectorsMove[0]
                                     <Control.Monad.Primitive.PrimState m>_N)
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,)[0]
                                          <Control.Monad.Primitive.PrimState m>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N)))) of wild1 { Data.Vector.Unboxed.Base.MV_2 dt1 as2 bs2 ->
                 GHC.Base.>>
                   @ m
                   (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                   @ ()
                   @ ()
                   (case as1
                           `cast`
                         (Trans
                              (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                        <Control.Monad.Primitive.PrimState m>_N))
                              (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                   <Control.Monad.Primitive.PrimState
                                      m>_N)) of wild2 { Data.Vector.Primitive.Mutable.MVector dt2 dt3 dt4 ->
                    case as2
                           `cast`
                         (Trans
                              (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                        <Control.Monad.Primitive.PrimState m>_N))
                              (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                   <Control.Monad.Primitive.PrimState
                                      m>_N)) of wild3 { Data.Vector.Primitive.Mutable.MVector dt5 dt6 dt7 ->
                    let {
                      sz :: GHC.Types.Int
                      = Data.Vector.Primitive.$fVectorVectora_$ssizeOf
                          (GHC.Err.undefined @ GHC.Types.Int)
                    } in
                    Control.Monad.Primitive.primitive
                      @ m
                      $dPrimMonad
                      @ ()
                      (\ s# :: GHC.Prim.State#
                                 (Control.Monad.Primitive.PrimState m)[OneShot] ->
                       case Data.Primitive.ByteArray.unI#
                              (GHC.Num.$fNumInt_$c* (GHC.Types.I# dt3) sz) of wild4 { DEFAULT ->
                       case Data.Primitive.ByteArray.unI#
                              (GHC.Num.$fNumInt_$c* (GHC.Types.I# dt2) sz) of wild5 { DEFAULT ->
                       case Data.Primitive.ByteArray.unI#
                              (GHC.Num.$fNumInt_$c* (GHC.Types.I# dt5) sz) of wild6 { DEFAULT ->
                       case GHC.Prim.copyMutableByteArray#
                              @ (Control.Monad.Primitive.PrimState m)
                              dt7
                              wild6
                              dt4
                              wild5
                              wild4
                              s# of s'# { DEFAULT ->
                       (# s'#, GHC.Tuple.() #) } } } }) } })
                   (case bs1
                           `cast`
                         (Trans
                              (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                        <Control.Monad.Primitive.PrimState m>_N))
                              (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                   <Control.Monad.Primitive.PrimState
                                      m>_N)) of wild2 { Data.Vector.Primitive.Mutable.MVector dt2 dt3 dt4 ->
                    case bs2
                           `cast`
                         (Trans
                              (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                        <Control.Monad.Primitive.PrimState m>_N))
                              (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                   <Control.Monad.Primitive.PrimState
                                      m>_N)) of wild3 { Data.Vector.Primitive.Mutable.MVector dt5 dt6 dt7 ->
                    let {
                      sz :: GHC.Types.Int
                      = Data.Vector.Primitive.$fVectorVectora_$ssizeOf
                          (GHC.Err.undefined @ GHC.Types.Int)
                    } in
                    Control.Monad.Primitive.primitive
                      @ m
                      $dPrimMonad
                      @ ()
                      (\ s# :: GHC.Prim.State#
                                 (Control.Monad.Primitive.PrimState m)[OneShot] ->
                       case Data.Primitive.ByteArray.unI#
                              (GHC.Num.$fNumInt_$c* (GHC.Types.I# dt3) sz) of wild4 { DEFAULT ->
                       case Data.Primitive.ByteArray.unI#
                              (GHC.Num.$fNumInt_$c* (GHC.Types.I# dt2) sz) of wild5 { DEFAULT ->
                       case Data.Primitive.ByteArray.unI#
                              (GHC.Num.$fNumInt_$c* (GHC.Types.I# dt5) sz) of wild6 { DEFAULT ->
                       case GHC.Prim.copyMutableByteArray#
                              @ (Control.Monad.Primitive.PrimState m)
                              dt7
                              wild6
                              dt4
                              wild5
                              wild4
                              s# of s'# { DEFAULT ->
                       (# s'#, GHC.Tuple.() #) } } } }) } }) } }) -}
f87b40583b48531412a65b59dc7a4f4f
  $fMVectorMVectorMove_$cbasicUnsafeGrow ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Unboxed.Base.MVector
      (Control.Monad.Primitive.PrimState m) MoveTypes.Move
    -> GHC.Types.Int
    -> m (Data.Vector.Unboxed.Base.MVector
            (Control.Monad.Primitive.PrimState m) MoveTypes.Move)
  {- Arity: 3,
     Strictness: <S(SL),U(U,C(U))><L,1*U(U,U(U,U,U),U(U,U,U))><L,U(U)>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   eta :: Data.Vector.Unboxed.Base.MVector
                            (Control.Monad.Primitive.PrimState m) MoveTypes.Move
                   eta1 :: GHC.Types.Int ->
                 GHC.Base.liftM
                   @ (Data.Vector.Unboxed.Base.MVector
                        (Control.Monad.Primitive.PrimState m)
                        (GHC.Types.Int, GHC.Types.Int))
                   @ (Data.Vector.Unboxed.Base.MVector
                        (Control.Monad.Primitive.PrimState m) MoveTypes.Move)
                   @ m
                   (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                   (\ tpl :: Data.Vector.Unboxed.Base.MVector
                               (Control.Monad.Primitive.PrimState m)
                               (GHC.Types.Int, GHC.Types.Int) ->
                    tpl)
                     `cast`
                   (<Data.Vector.Unboxed.Base.MVector
                       (Control.Monad.Primitive.PrimState m)
                       (GHC.Types.Int, GHC.Types.Int)>_R
                    ->_R Trans
                             (Sym (MoveTypes.NTCo:R:MVectorsMove[0]
                                       <Control.Monad.Primitive.PrimState m>_N))
                             (Sub (Sym (MoveTypes.TFCo:R:MVectorsMove[0]
                                            <Control.Monad.Primitive.PrimState m>_N))))
                   (let {
                      $dMonad :: GHC.Base.Monad m
                      = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                    } in
                    case eta
                           `cast`
                         (Trans
                              (Sub (MoveTypes.TFCo:R:MVectorsMove[0]
                                        <Control.Monad.Primitive.PrimState m>_N))
                              (Trans
                                   (MoveTypes.NTCo:R:MVectorsMove[0]
                                        <Control.Monad.Primitive.PrimState m>_N)
                                   (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,)[0]
                                             <Control.Monad.Primitive.PrimState m>_N
                                             <GHC.Types.Int>_N
                                             <GHC.Types.Int>_N)))) of wild { Data.Vector.Unboxed.Base.MV_2 dt as bs ->
                    let {
                      n_ :: GHC.Types.Int = GHC.Types.I# dt
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                      @ (Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m)
                           (GHC.Types.Int, GHC.Types.Int))
                      (GHC.Base.liftM
                         @ (Data.Vector.Primitive.Mutable.MVector
                              (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                         @ (Data.Vector.Unboxed.Base.MVector
                              (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                         @ m
                         (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                         (\ tpl :: Data.Vector.Primitive.Mutable.MVector
                                     (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                          tpl)
                           `cast`
                         (<Data.Vector.Primitive.Mutable.MVector
                             (Control.Monad.Primitive.PrimState m) GHC.Types.Int>_R
                          ->_R Trans
                                   (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                             <Control.Monad.Primitive.PrimState m>_N))
                                   (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                  <Control.Monad.Primitive.PrimState m>_N))))
                         (let {
                            $dMonad1 :: GHC.Base.Monad m
                            = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                          } in
                          let {
                            n :: GHC.Types.Int
                            = Data.Vector.Primitive.$fVectorVectora2
                                @ (Control.Monad.Primitive.PrimState m)
                                as
                                  `cast`
                                (Trans
                                     (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                               <Control.Monad.Primitive.PrimState m>_N))
                                     (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                          <Control.Monad.Primitive.PrimState m>_N))
                          } in
                          GHC.Base.>>=
                            @ m
                            $dMonad1
                            @ (Data.Vector.Primitive.Mutable.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                            @ (Data.Vector.Primitive.Mutable.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                            (let {
                               size :: GHC.Types.Int
                               = Data.Vector.Primitive.$fVectorVectora_$ssizeOf
                                   (GHC.Err.undefined @ GHC.Types.Int)
                             } in
                             case GHC.Num.$fNumInt_$c+ n eta1 of wild1 { GHC.Types.I# x ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.<# x 0) of wild2 {
                               GHC.Types.False
                               -> case GHC.Real.$fIntegralInt_$cdiv
                                         GHC.Base.maxInt
                                         size of wild3 { GHC.Types.I# y ->
                                  case GHC.Prim.tagToEnum#
                                         @ GHC.Types.Bool
                                         (GHC.Prim.># x y) of wild4 {
                                    GHC.Types.False
                                    -> GHC.Base.liftM
                                         @ (Data.Primitive.ByteArray.MutableByteArray
                                              (Control.Monad.Primitive.PrimState m))
                                         @ (Data.Vector.Primitive.Mutable.MVector
                                              (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                                         @ m
                                         (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                                         (Data.Vector.Primitive.Mutable.$WMVector
                                            @ (Control.Monad.Primitive.PrimState m)
                                            @ GHC.Types.Int
                                            (GHC.Types.I# 0)
                                            wild1)
                                         (case GHC.Num.$fNumInt_$c*
                                                 wild1
                                                 size of wild5 { GHC.Types.I# n# ->
                                          Control.Monad.Primitive.primitive
                                            @ m
                                            $dPrimMonad
                                            @ (Data.Primitive.ByteArray.MutableByteArray
                                                 (Control.Monad.Primitive.PrimState m))
                                            (\ s# :: GHC.Prim.State#
                                                       (Control.Monad.Primitive.PrimState
                                                          m)[OneShot] ->
                                             case GHC.Prim.newByteArray#
                                                    @ (Control.Monad.Primitive.PrimState m)
                                                    n#
                                                    s# of ds1 { (#,#) ipv ipv1 ->
                                             (# ipv,
                                                Data.Primitive.ByteArray.MutableByteArray
                                                  @ (Control.Monad.Primitive.PrimState m)
                                                  ipv1 #) }) })
                                    GHC.Types.True
                                    -> GHC.Base.$
                                         @ [GHC.Types.Char]
                                         @ (m (Data.Vector.Primitive.Mutable.MVector
                                                 (Control.Monad.Primitive.PrimState m)
                                                 GHC.Types.Int))
                                         (GHC.Err.error
                                            @ (m (Data.Vector.Primitive.Mutable.MVector
                                                    (Control.Monad.Primitive.PrimState m)
                                                    GHC.Types.Int)))
                                         (GHC.Base.augment
                                            @ GHC.Types.Char
                                            (\ @ b
                                               c :: GHC.Types.Char -> b -> b[OneShot]
                                               n1 :: b[OneShot] ->
                                             GHC.CString.unpackFoldrCString#
                                               @ b
                                               "Primitive.basicUnsafeNew: length to large: "#
                                               c
                                               n1)
                                            (GHC.Show.$fShowInt_$cshow wild1)) } }
                               GHC.Types.True
                               -> GHC.Base.$
                                    @ [GHC.Types.Char]
                                    @ (m (Data.Vector.Primitive.Mutable.MVector
                                            (Control.Monad.Primitive.PrimState m) GHC.Types.Int))
                                    (GHC.Err.error
                                       @ (m (Data.Vector.Primitive.Mutable.MVector
                                               (Control.Monad.Primitive.PrimState m)
                                               GHC.Types.Int)))
                                    (GHC.Base.augment
                                       @ GHC.Types.Char
                                       (\ @ b
                                          c :: GHC.Types.Char -> b -> b[OneShot]
                                          n1 :: b[OneShot] ->
                                        GHC.CString.unpackFoldrCString#
                                          @ b
                                          "Primitive.basicUnsafeNew: negative length: "#
                                          c
                                          n1)
                                       (GHC.Show.$fShowInt_$cshow wild1)) } })
                            (\ v' :: Data.Vector.Primitive.Mutable.MVector
                                       (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                             GHC.Base.>>
                               @ m
                               $dMonad1
                               @ ()
                               @ (Data.Vector.Primitive.Mutable.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                               (case Data.Vector.Primitive.$fVectorVectora1
                                       @ (Control.Monad.Primitive.PrimState m)
                                       (GHC.Types.I# 0)
                                       n
                                       v' of wild1 { Data.Vector.Primitive.Mutable.MVector dt1 dt2 dt3 ->
                                case as
                                       `cast`
                                     (Trans
                                          (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                    <Control.Monad.Primitive.PrimState m>_N))
                                          (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                               <Control.Monad.Primitive.PrimState
                                                  m>_N)) of wild2 { Data.Vector.Primitive.Mutable.MVector dt4 dt5 dt6 ->
                                let {
                                  sz :: GHC.Types.Int
                                  = Data.Vector.Primitive.$fVectorVectora_$ssizeOf
                                      (GHC.Err.undefined @ GHC.Types.Int)
                                } in
                                Control.Monad.Primitive.primitive
                                  @ m
                                  $dPrimMonad
                                  @ ()
                                  (\ s# :: GHC.Prim.State#
                                             (Control.Monad.Primitive.PrimState m)[OneShot] ->
                                   case Data.Primitive.ByteArray.unI#
                                          (GHC.Num.$fNumInt_$c*
                                             (GHC.Types.I# dt2)
                                             sz) of wild3 { DEFAULT ->
                                   case Data.Primitive.ByteArray.unI#
                                          (GHC.Num.$fNumInt_$c*
                                             (GHC.Types.I# dt1)
                                             sz) of wild4 { DEFAULT ->
                                   case Data.Primitive.ByteArray.unI#
                                          (GHC.Num.$fNumInt_$c*
                                             (GHC.Types.I# dt4)
                                             sz) of wild5 { DEFAULT ->
                                   case GHC.Prim.copyMutableByteArray#
                                          @ (Control.Monad.Primitive.PrimState m)
                                          dt6
                                          wild5
                                          dt3
                                          wild4
                                          wild3
                                          s# of s'# { DEFAULT ->
                                   (# s'#, GHC.Tuple.() #) } } } }) } })
                               (GHC.Base.return
                                  @ m
                                  $dMonad1
                                  @ (Data.Vector.Primitive.Mutable.MVector
                                       (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                                  v'))))
                      (\ as' :: Data.Vector.Unboxed.Base.MVector
                                  (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (Data.Vector.Unboxed.Base.MVector
                              (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                         @ (Data.Vector.Unboxed.Base.MVector
                              (Control.Monad.Primitive.PrimState m)
                              (GHC.Types.Int, GHC.Types.Int))
                         (GHC.Base.liftM
                            @ (Data.Vector.Primitive.Mutable.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                            @ (Data.Vector.Unboxed.Base.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                            @ m
                            (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                            (\ tpl :: Data.Vector.Primitive.Mutable.MVector
                                        (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                             tpl)
                              `cast`
                            (<Data.Vector.Primitive.Mutable.MVector
                                (Control.Monad.Primitive.PrimState m) GHC.Types.Int>_R
                             ->_R Trans
                                      (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                                <Control.Monad.Primitive.PrimState m>_N))
                                      (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                     <Control.Monad.Primitive.PrimState m>_N))))
                            (let {
                               $dMonad1 :: GHC.Base.Monad m
                               = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                             } in
                             let {
                               n :: GHC.Types.Int
                               = Data.Vector.Primitive.$fVectorVectora2
                                   @ (Control.Monad.Primitive.PrimState m)
                                   bs
                                     `cast`
                                   (Trans
                                        (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                  <Control.Monad.Primitive.PrimState m>_N))
                                        (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                             <Control.Monad.Primitive.PrimState m>_N))
                             } in
                             GHC.Base.>>=
                               @ m
                               $dMonad1
                               @ (Data.Vector.Primitive.Mutable.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                               @ (Data.Vector.Primitive.Mutable.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                               (let {
                                  size :: GHC.Types.Int
                                  = Data.Vector.Primitive.$fVectorVectora_$ssizeOf
                                      (GHC.Err.undefined @ GHC.Types.Int)
                                } in
                                case GHC.Num.$fNumInt_$c+ n eta1 of wild1 { GHC.Types.I# x ->
                                case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.<# x 0) of wild2 {
                                  GHC.Types.False
                                  -> case GHC.Real.$fIntegralInt_$cdiv
                                            GHC.Base.maxInt
                                            size of wild3 { GHC.Types.I# y ->
                                     case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.># x y) of wild4 {
                                       GHC.Types.False
                                       -> GHC.Base.liftM
                                            @ (Data.Primitive.ByteArray.MutableByteArray
                                                 (Control.Monad.Primitive.PrimState m))
                                            @ (Data.Vector.Primitive.Mutable.MVector
                                                 (Control.Monad.Primitive.PrimState m)
                                                 GHC.Types.Int)
                                            @ m
                                            (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                                            (Data.Vector.Primitive.Mutable.$WMVector
                                               @ (Control.Monad.Primitive.PrimState m)
                                               @ GHC.Types.Int
                                               (GHC.Types.I# 0)
                                               wild1)
                                            (case GHC.Num.$fNumInt_$c*
                                                    wild1
                                                    size of wild5 { GHC.Types.I# n# ->
                                             Control.Monad.Primitive.primitive
                                               @ m
                                               $dPrimMonad
                                               @ (Data.Primitive.ByteArray.MutableByteArray
                                                    (Control.Monad.Primitive.PrimState m))
                                               (\ s# :: GHC.Prim.State#
                                                          (Control.Monad.Primitive.PrimState
                                                             m)[OneShot] ->
                                                case GHC.Prim.newByteArray#
                                                       @ (Control.Monad.Primitive.PrimState m)
                                                       n#
                                                       s# of ds1 { (#,#) ipv ipv1 ->
                                                (# ipv,
                                                   Data.Primitive.ByteArray.MutableByteArray
                                                     @ (Control.Monad.Primitive.PrimState m)
                                                     ipv1 #) }) })
                                       GHC.Types.True
                                       -> GHC.Base.$
                                            @ [GHC.Types.Char]
                                            @ (m (Data.Vector.Primitive.Mutable.MVector
                                                    (Control.Monad.Primitive.PrimState m)
                                                    GHC.Types.Int))
                                            (GHC.Err.error
                                               @ (m (Data.Vector.Primitive.Mutable.MVector
                                                       (Control.Monad.Primitive.PrimState m)
                                                       GHC.Types.Int)))
                                            (GHC.Base.augment
                                               @ GHC.Types.Char
                                               (\ @ b
                                                  c :: GHC.Types.Char -> b -> b[OneShot]
                                                  n1 :: b[OneShot] ->
                                                GHC.CString.unpackFoldrCString#
                                                  @ b
                                                  "Primitive.basicUnsafeNew: length to large: "#
                                                  c
                                                  n1)
                                               (GHC.Show.$fShowInt_$cshow wild1)) } }
                                  GHC.Types.True
                                  -> GHC.Base.$
                                       @ [GHC.Types.Char]
                                       @ (m (Data.Vector.Primitive.Mutable.MVector
                                               (Control.Monad.Primitive.PrimState m) GHC.Types.Int))
                                       (GHC.Err.error
                                          @ (m (Data.Vector.Primitive.Mutable.MVector
                                                  (Control.Monad.Primitive.PrimState m)
                                                  GHC.Types.Int)))
                                       (GHC.Base.augment
                                          @ GHC.Types.Char
                                          (\ @ b
                                             c :: GHC.Types.Char -> b -> b[OneShot]
                                             n1 :: b[OneShot] ->
                                           GHC.CString.unpackFoldrCString#
                                             @ b
                                             "Primitive.basicUnsafeNew: negative length: "#
                                             c
                                             n1)
                                          (GHC.Show.$fShowInt_$cshow wild1)) } })
                               (\ v' :: Data.Vector.Primitive.Mutable.MVector
                                          (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                                GHC.Base.>>
                                  @ m
                                  $dMonad1
                                  @ ()
                                  @ (Data.Vector.Primitive.Mutable.MVector
                                       (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                                  (case Data.Vector.Primitive.$fVectorVectora1
                                          @ (Control.Monad.Primitive.PrimState m)
                                          (GHC.Types.I# 0)
                                          n
                                          v' of wild1 { Data.Vector.Primitive.Mutable.MVector dt1 dt2 dt3 ->
                                   case bs
                                          `cast`
                                        (Trans
                                             (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                       <Control.Monad.Primitive.PrimState m>_N))
                                             (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                                  <Control.Monad.Primitive.PrimState
                                                     m>_N)) of wild2 { Data.Vector.Primitive.Mutable.MVector dt4 dt5 dt6 ->
                                   let {
                                     sz :: GHC.Types.Int
                                     = Data.Vector.Primitive.$fVectorVectora_$ssizeOf
                                         (GHC.Err.undefined @ GHC.Types.Int)
                                   } in
                                   Control.Monad.Primitive.primitive
                                     @ m
                                     $dPrimMonad
                                     @ ()
                                     (\ s# :: GHC.Prim.State#
                                                (Control.Monad.Primitive.PrimState m)[OneShot] ->
                                      case Data.Primitive.ByteArray.unI#
                                             (GHC.Num.$fNumInt_$c*
                                                (GHC.Types.I# dt2)
                                                sz) of wild3 { DEFAULT ->
                                      case Data.Primitive.ByteArray.unI#
                                             (GHC.Num.$fNumInt_$c*
                                                (GHC.Types.I# dt1)
                                                sz) of wild4 { DEFAULT ->
                                      case Data.Primitive.ByteArray.unI#
                                             (GHC.Num.$fNumInt_$c*
                                                (GHC.Types.I# dt4)
                                                sz) of wild5 { DEFAULT ->
                                      case GHC.Prim.copyMutableByteArray#
                                             @ (Control.Monad.Primitive.PrimState m)
                                             dt6
                                             wild5
                                             dt3
                                             wild4
                                             wild3
                                             s# of s'# { DEFAULT ->
                                      (# s'#, GHC.Tuple.() #) } } } }) } })
                                  (GHC.Base.return
                                     @ m
                                     $dMonad1
                                     @ (Data.Vector.Primitive.Mutable.MVector
                                          (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                                     v'))))
                         (\ bs' :: Data.Vector.Unboxed.Base.MVector
                                     (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                          GHC.Base.$
                            @ (Data.Vector.Unboxed.Base.MVector
                                 (Control.Monad.Primitive.PrimState m)
                                 (GHC.Types.Int, GHC.Types.Int))
                            @ (m (Data.Vector.Unboxed.Base.MVector
                                    (Control.Monad.Primitive.PrimState m)
                                    (GHC.Types.Int, GHC.Types.Int)))
                            (GHC.Base.return
                               @ m
                               $dMonad
                               @ (Data.Vector.Unboxed.Base.MVector
                                    (Control.Monad.Primitive.PrimState m)
                                    (GHC.Types.Int, GHC.Types.Int)))
                            (case GHC.Num.$fNumInt_$c+ eta1 n_ of dt1 { GHC.Types.I# dt2 ->
                             case as'
                                    `cast`
                                  (Trans
                                       (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                 <Control.Monad.Primitive.PrimState m>_N))
                                       (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                            <Control.Monad.Primitive.PrimState
                                               m>_N)) of nt { Data.Vector.Primitive.Mutable.MVector ipv ipv1 ipv2 ->
                             case bs'
                                    `cast`
                                  (Trans
                                       (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                 <Control.Monad.Primitive.PrimState m>_N))
                                       (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                            <Control.Monad.Primitive.PrimState
                                               m>_N)) of nt1 { Data.Vector.Primitive.Mutable.MVector ipv3 ipv4 ipv5 ->
                             (Data.Vector.Unboxed.Base.MV_2
                                @ (Control.Monad.Primitive.PrimState m)
                                @ GHC.Types.Int
                                @ GHC.Types.Int
                                dt2
                                nt
                                  `cast`
                                (Trans
                                     (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                               <Control.Monad.Primitive.PrimState m>_N))
                                     (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                    <Control.Monad.Primitive.PrimState m>_N))))
                                nt1
                                  `cast`
                                (Trans
                                     (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                               <Control.Monad.Primitive.PrimState m>_N))
                                     (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                    <Control.Monad.Primitive.PrimState m>_N)))))
                               `cast`
                             (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,)[0]
                                            <Control.Monad.Primitive.PrimState m>_N
                                            <GHC.Types.Int>_N
                                            <GHC.Types.Int>_N))) } } }))) })) -}
f87b40583b48531412a65b59dc7a4f4f
  $fMVectorMVectorMove_$cbasicUnsafeMove ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Unboxed.Base.MVector
      (Control.Monad.Primitive.PrimState m) MoveTypes.Move
    -> Data.Vector.Unboxed.Base.MVector
         (Control.Monad.Primitive.PrimState m) MoveTypes.Move
    -> m ()
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(LLC(C(S))LL)L),U(1*U(A,A,1*C1(C1(U)),A,A),C(U))><S(LSS),1*U(A,U(U,U,U),U(U,U,U))><S,1*U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   ds :: Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m) MoveTypes.Move
                   ds1 :: Data.Vector.Unboxed.Base.MVector
                            (Control.Monad.Primitive.PrimState m) MoveTypes.Move ->
                 case ds
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:MVectorsMove[0]
                                     <Control.Monad.Primitive.PrimState m>_N))
                           (Trans
                                (MoveTypes.NTCo:R:MVectorsMove[0]
                                     <Control.Monad.Primitive.PrimState m>_N)
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,)[0]
                                          <Control.Monad.Primitive.PrimState m>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N)))) of wild { Data.Vector.Unboxed.Base.MV_2 dt as1 bs1 ->
                 case ds1
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:MVectorsMove[0]
                                     <Control.Monad.Primitive.PrimState m>_N))
                           (Trans
                                (MoveTypes.NTCo:R:MVectorsMove[0]
                                     <Control.Monad.Primitive.PrimState m>_N)
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,)[0]
                                          <Control.Monad.Primitive.PrimState m>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N)))) of wild1 { Data.Vector.Unboxed.Base.MV_2 dt1 as2 bs2 ->
                 GHC.Base.>>
                   @ m
                   (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                   @ ()
                   @ ()
                   (Data.Vector.Unboxed.Base.$fMVectorMVectorInt_$cbasicUnsafeMove
                      @ m
                      $dPrimMonad
                      as1
                      as2)
                   (Data.Vector.Unboxed.Base.$fMVectorMVectorInt_$cbasicUnsafeMove
                      @ m
                      $dPrimMonad
                      bs1
                      bs2) } }) -}
f87b40583b48531412a65b59dc7a4f4f
  $fMVectorMVectorMove_$cbasicUnsafeNew ::
    Control.Monad.Primitive.PrimMonad m =>
    GHC.Types.Int
    -> m (Data.Vector.Unboxed.Base.MVector
            (Control.Monad.Primitive.PrimState m) MoveTypes.Move)
  {- Arity: 2, Strictness: <S(SL),U(U,C(U))><L,U(U)>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   eta :: GHC.Types.Int ->
                 GHC.Base.liftM
                   @ (Data.Vector.Unboxed.Base.MVector
                        (Control.Monad.Primitive.PrimState m)
                        (GHC.Types.Int, GHC.Types.Int))
                   @ (Data.Vector.Unboxed.Base.MVector
                        (Control.Monad.Primitive.PrimState m) MoveTypes.Move)
                   @ m
                   (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                   (\ tpl :: Data.Vector.Unboxed.Base.MVector
                               (Control.Monad.Primitive.PrimState m)
                               (GHC.Types.Int, GHC.Types.Int) ->
                    tpl)
                     `cast`
                   (<Data.Vector.Unboxed.Base.MVector
                       (Control.Monad.Primitive.PrimState m)
                       (GHC.Types.Int, GHC.Types.Int)>_R
                    ->_R Trans
                             (Sym (MoveTypes.NTCo:R:MVectorsMove[0]
                                       <Control.Monad.Primitive.PrimState m>_N))
                             (Sub (Sym (MoveTypes.TFCo:R:MVectorsMove[0]
                                            <Control.Monad.Primitive.PrimState m>_N))))
                   (let {
                      $dMonad :: GHC.Base.Monad m
                      = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                      @ (Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m)
                           (GHC.Types.Int, GHC.Types.Int))
                      (GHC.Base.liftM
                         @ (Data.Vector.Primitive.Mutable.MVector
                              (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                         @ (Data.Vector.Unboxed.Base.MVector
                              (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                         @ m
                         (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                         (\ tpl :: Data.Vector.Primitive.Mutable.MVector
                                     (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                          tpl)
                           `cast`
                         (<Data.Vector.Primitive.Mutable.MVector
                             (Control.Monad.Primitive.PrimState m) GHC.Types.Int>_R
                          ->_R Trans
                                   (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                             <Control.Monad.Primitive.PrimState m>_N))
                                   (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                  <Control.Monad.Primitive.PrimState m>_N))))
                         (let {
                            size :: GHC.Types.Int
                            = Data.Vector.Primitive.$fVectorVectora_$ssizeOf
                                (GHC.Err.undefined @ GHC.Types.Int)
                          } in
                          case eta of wild { GHC.Types.I# x ->
                          case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.<# x 0) of wild1 {
                            GHC.Types.False
                            -> case GHC.Real.$fIntegralInt_$cdiv
                                      GHC.Base.maxInt
                                      size of wild2 { GHC.Types.I# y ->
                               case GHC.Prim.tagToEnum#
                                      @ GHC.Types.Bool
                                      (GHC.Prim.># x y) of wild3 {
                                 GHC.Types.False
                                 -> GHC.Base.liftM
                                      @ (Data.Primitive.ByteArray.MutableByteArray
                                           (Control.Monad.Primitive.PrimState m))
                                      @ (Data.Vector.Primitive.Mutable.MVector
                                           (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                                      @ m
                                      (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                                      (Data.Vector.Primitive.Mutable.$WMVector
                                         @ (Control.Monad.Primitive.PrimState m)
                                         @ GHC.Types.Int
                                         (GHC.Types.I# 0)
                                         wild)
                                      (case GHC.Num.$fNumInt_$c*
                                              wild
                                              size of wild4 { GHC.Types.I# n# ->
                                       Control.Monad.Primitive.primitive
                                         @ m
                                         $dPrimMonad
                                         @ (Data.Primitive.ByteArray.MutableByteArray
                                              (Control.Monad.Primitive.PrimState m))
                                         (\ s# :: GHC.Prim.State#
                                                    (Control.Monad.Primitive.PrimState
                                                       m)[OneShot] ->
                                          case GHC.Prim.newByteArray#
                                                 @ (Control.Monad.Primitive.PrimState m)
                                                 n#
                                                 s# of ds1 { (#,#) ipv ipv1 ->
                                          (# ipv,
                                             Data.Primitive.ByteArray.MutableByteArray
                                               @ (Control.Monad.Primitive.PrimState m)
                                               ipv1 #) }) })
                                 GHC.Types.True
                                 -> GHC.Base.$
                                      @ [GHC.Types.Char]
                                      @ (m (Data.Vector.Primitive.Mutable.MVector
                                              (Control.Monad.Primitive.PrimState m) GHC.Types.Int))
                                      (GHC.Err.error
                                         @ (m (Data.Vector.Primitive.Mutable.MVector
                                                 (Control.Monad.Primitive.PrimState m)
                                                 GHC.Types.Int)))
                                      (GHC.Base.augment
                                         @ GHC.Types.Char
                                         (\ @ b
                                            c :: GHC.Types.Char -> b -> b[OneShot]
                                            n :: b[OneShot] ->
                                          GHC.CString.unpackFoldrCString#
                                            @ b
                                            "Primitive.basicUnsafeNew: length to large: "#
                                            c
                                            n)
                                         (GHC.Show.$fShowInt_$cshow wild)) } }
                            GHC.Types.True
                            -> GHC.Base.$
                                 @ [GHC.Types.Char]
                                 @ (m (Data.Vector.Primitive.Mutable.MVector
                                         (Control.Monad.Primitive.PrimState m) GHC.Types.Int))
                                 (GHC.Err.error
                                    @ (m (Data.Vector.Primitive.Mutable.MVector
                                            (Control.Monad.Primitive.PrimState m) GHC.Types.Int)))
                                 (GHC.Base.augment
                                    @ GHC.Types.Char
                                    (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                                     GHC.CString.unpackFoldrCString#
                                       @ b
                                       "Primitive.basicUnsafeNew: negative length: "#
                                       c
                                       n)
                                    (GHC.Show.$fShowInt_$cshow wild)) } }))
                      (\ as :: Data.Vector.Unboxed.Base.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (Data.Vector.Unboxed.Base.MVector
                              (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                         @ (Data.Vector.Unboxed.Base.MVector
                              (Control.Monad.Primitive.PrimState m)
                              (GHC.Types.Int, GHC.Types.Int))
                         (GHC.Base.liftM
                            @ (Data.Vector.Primitive.Mutable.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                            @ (Data.Vector.Unboxed.Base.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                            @ m
                            (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                            (\ tpl :: Data.Vector.Primitive.Mutable.MVector
                                        (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                             tpl)
                              `cast`
                            (<Data.Vector.Primitive.Mutable.MVector
                                (Control.Monad.Primitive.PrimState m) GHC.Types.Int>_R
                             ->_R Trans
                                      (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                                <Control.Monad.Primitive.PrimState m>_N))
                                      (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                     <Control.Monad.Primitive.PrimState m>_N))))
                            (let {
                               size :: GHC.Types.Int
                               = Data.Vector.Primitive.$fVectorVectora_$ssizeOf
                                   (GHC.Err.undefined @ GHC.Types.Int)
                             } in
                             case eta of wild { GHC.Types.I# x ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.<# x 0) of wild1 {
                               GHC.Types.False
                               -> case GHC.Real.$fIntegralInt_$cdiv
                                         GHC.Base.maxInt
                                         size of wild2 { GHC.Types.I# y ->
                                  case GHC.Prim.tagToEnum#
                                         @ GHC.Types.Bool
                                         (GHC.Prim.># x y) of wild3 {
                                    GHC.Types.False
                                    -> GHC.Base.liftM
                                         @ (Data.Primitive.ByteArray.MutableByteArray
                                              (Control.Monad.Primitive.PrimState m))
                                         @ (Data.Vector.Primitive.Mutable.MVector
                                              (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                                         @ m
                                         (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                                         (Data.Vector.Primitive.Mutable.$WMVector
                                            @ (Control.Monad.Primitive.PrimState m)
                                            @ GHC.Types.Int
                                            (GHC.Types.I# 0)
                                            wild)
                                         (case GHC.Num.$fNumInt_$c*
                                                 wild
                                                 size of wild4 { GHC.Types.I# n# ->
                                          Control.Monad.Primitive.primitive
                                            @ m
                                            $dPrimMonad
                                            @ (Data.Primitive.ByteArray.MutableByteArray
                                                 (Control.Monad.Primitive.PrimState m))
                                            (\ s# :: GHC.Prim.State#
                                                       (Control.Monad.Primitive.PrimState
                                                          m)[OneShot] ->
                                             case GHC.Prim.newByteArray#
                                                    @ (Control.Monad.Primitive.PrimState m)
                                                    n#
                                                    s# of ds1 { (#,#) ipv ipv1 ->
                                             (# ipv,
                                                Data.Primitive.ByteArray.MutableByteArray
                                                  @ (Control.Monad.Primitive.PrimState m)
                                                  ipv1 #) }) })
                                    GHC.Types.True
                                    -> GHC.Base.$
                                         @ [GHC.Types.Char]
                                         @ (m (Data.Vector.Primitive.Mutable.MVector
                                                 (Control.Monad.Primitive.PrimState m)
                                                 GHC.Types.Int))
                                         (GHC.Err.error
                                            @ (m (Data.Vector.Primitive.Mutable.MVector
                                                    (Control.Monad.Primitive.PrimState m)
                                                    GHC.Types.Int)))
                                         (GHC.Base.augment
                                            @ GHC.Types.Char
                                            (\ @ b
                                               c :: GHC.Types.Char -> b -> b[OneShot]
                                               n :: b[OneShot] ->
                                             GHC.CString.unpackFoldrCString#
                                               @ b
                                               "Primitive.basicUnsafeNew: length to large: "#
                                               c
                                               n)
                                            (GHC.Show.$fShowInt_$cshow wild)) } }
                               GHC.Types.True
                               -> GHC.Base.$
                                    @ [GHC.Types.Char]
                                    @ (m (Data.Vector.Primitive.Mutable.MVector
                                            (Control.Monad.Primitive.PrimState m) GHC.Types.Int))
                                    (GHC.Err.error
                                       @ (m (Data.Vector.Primitive.Mutable.MVector
                                               (Control.Monad.Primitive.PrimState m)
                                               GHC.Types.Int)))
                                    (GHC.Base.augment
                                       @ GHC.Types.Char
                                       (\ @ b
                                          c :: GHC.Types.Char -> b -> b[OneShot]
                                          n :: b[OneShot] ->
                                        GHC.CString.unpackFoldrCString#
                                          @ b
                                          "Primitive.basicUnsafeNew: negative length: "#
                                          c
                                          n)
                                       (GHC.Show.$fShowInt_$cshow wild)) } }))
                         (\ bs :: Data.Vector.Unboxed.Base.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                          GHC.Base.$
                            @ (Data.Vector.Unboxed.Base.MVector
                                 (Control.Monad.Primitive.PrimState m)
                                 (GHC.Types.Int, GHC.Types.Int))
                            @ (m (Data.Vector.Unboxed.Base.MVector
                                    (Control.Monad.Primitive.PrimState m)
                                    (GHC.Types.Int, GHC.Types.Int)))
                            (GHC.Base.return
                               @ m
                               $dMonad
                               @ (Data.Vector.Unboxed.Base.MVector
                                    (Control.Monad.Primitive.PrimState m)
                                    (GHC.Types.Int, GHC.Types.Int)))
                            (Data.Vector.Unboxed.Base.$WMV_2
                               @ (Control.Monad.Primitive.PrimState m)
                               @ GHC.Types.Int
                               @ GHC.Types.Int
                               eta
                               as
                               bs))))) -}
f87b40583b48531412a65b59dc7a4f4f
  $fMVectorMVectorMove_$cbasicUnsafeRead ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Unboxed.Base.MVector
      (Control.Monad.Primitive.PrimState m) MoveTypes.Move
    -> GHC.Types.Int -> m MoveTypes.Move
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(SL),U(U,C(U))><L,1*U(A,U(U,A,U),U(U,A,U))><L,U(U)>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   eta :: Data.Vector.Unboxed.Base.MVector
                            (Control.Monad.Primitive.PrimState m) MoveTypes.Move
                   eta1 :: GHC.Types.Int ->
                 GHC.Base.liftM
                   @ (Index.Index, Index.Index)
                   @ MoveTypes.Move
                   @ m
                   (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                   (Data.Tuple.uncurry
                      @ Index.Index
                      @ Index.Index
                      @ MoveTypes.Move
                      MoveTypes.$WMove)
                   (let {
                      $dMonad :: GHC.Base.Monad m
                      = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                    } in
                    case eta
                           `cast`
                         (Trans
                              (Sub (MoveTypes.TFCo:R:MVectorsMove[0]
                                        <Control.Monad.Primitive.PrimState m>_N))
                              (Trans
                                   (MoveTypes.NTCo:R:MVectorsMove[0]
                                        <Control.Monad.Primitive.PrimState m>_N)
                                   (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,)[0]
                                             <Control.Monad.Primitive.PrimState m>_N
                                             <GHC.Types.Int>_N
                                             <GHC.Types.Int>_N)))) of wild { Data.Vector.Unboxed.Base.MV_2 dt as bs ->
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ GHC.Types.Int
                      @ (GHC.Types.Int, GHC.Types.Int)
                      (case as
                              `cast`
                            (Trans
                                 (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                           <Control.Monad.Primitive.PrimState m>_N))
                                 (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                      <Control.Monad.Primitive.PrimState
                                         m>_N)) of wild1 { Data.Vector.Primitive.Mutable.MVector dt1 dt2 dt3 ->
                       case GHC.Num.$fNumInt_$c+
                              (GHC.Types.I# dt1)
                              eta1 of wild2 { GHC.Types.I# i# ->
                       Control.Monad.Primitive.primitive
                         @ m
                         $dPrimMonad
                         @ GHC.Types.Int
                         (Data.Primitive.Types.$fPrimInt_$creadByteArray#
                            @ (Control.Monad.Primitive.PrimState m)
                            dt3
                            i#) } })
                      (\ a21 :: GHC.Types.Int ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ GHC.Types.Int
                         @ (GHC.Types.Int, GHC.Types.Int)
                         (case bs
                                 `cast`
                               (Trans
                                    (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                              <Control.Monad.Primitive.PrimState m>_N))
                                    (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                         <Control.Monad.Primitive.PrimState
                                            m>_N)) of wild1 { Data.Vector.Primitive.Mutable.MVector dt1 dt2 dt3 ->
                          case GHC.Num.$fNumInt_$c+
                                 (GHC.Types.I# dt1)
                                 eta1 of wild2 { GHC.Types.I# i# ->
                          Control.Monad.Primitive.primitive
                            @ m
                            $dPrimMonad
                            @ GHC.Types.Int
                            (Data.Primitive.Types.$fPrimInt_$creadByteArray#
                               @ (Control.Monad.Primitive.PrimState m)
                               dt3
                               i#) } })
                         (\ b1 :: GHC.Types.Int ->
                          GHC.Base.return
                            @ m
                            $dMonad
                            @ (GHC.Types.Int, GHC.Types.Int)
                            (a21, b1))) })) -}
f87b40583b48531412a65b59dc7a4f4f
  $fMVectorMVectorMove_$cbasicUnsafeReplicate ::
    Control.Monad.Primitive.PrimMonad m =>
    GHC.Types.Int
    -> MoveTypes.Move
    -> m (Data.Vector.Unboxed.Base.MVector
            (Control.Monad.Primitive.PrimState m) MoveTypes.Move)
  {- Arity: 3, Strictness: <S(SL),U(U,C(U))><L,U(U)><L,1*U(U,U)>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   eta :: GHC.Types.Int
                   eta1 :: MoveTypes.Move ->
                 GHC.Base.liftM
                   @ (Data.Vector.Unboxed.Base.MVector
                        (Control.Monad.Primitive.PrimState m)
                        (GHC.Types.Int, GHC.Types.Int))
                   @ (Data.Vector.Unboxed.Base.MVector
                        (Control.Monad.Primitive.PrimState m) MoveTypes.Move)
                   @ m
                   (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                   (\ tpl :: Data.Vector.Unboxed.Base.MVector
                               (Control.Monad.Primitive.PrimState m)
                               (GHC.Types.Int, GHC.Types.Int) ->
                    tpl)
                     `cast`
                   (<Data.Vector.Unboxed.Base.MVector
                       (Control.Monad.Primitive.PrimState m)
                       (GHC.Types.Int, GHC.Types.Int)>_R
                    ->_R Trans
                             (Sym (MoveTypes.NTCo:R:MVectorsMove[0]
                                       <Control.Monad.Primitive.PrimState m>_N))
                             (Sub (Sym (MoveTypes.TFCo:R:MVectorsMove[0]
                                            <Control.Monad.Primitive.PrimState m>_N))))
                   (let {
                      $dMonad :: GHC.Base.Monad m
                      = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                    } in
                    case eta1 of wild { MoveTypes.Move dt dt1 ->
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                      @ (Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m)
                           (GHC.Types.Int, GHC.Types.Int))
                      (GHC.Base.liftM
                         @ (Data.Vector.Primitive.Mutable.MVector
                              (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                         @ (Data.Vector.Unboxed.Base.MVector
                              (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                         @ m
                         (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                         (\ tpl :: Data.Vector.Primitive.Mutable.MVector
                                     (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                          tpl)
                           `cast`
                         (<Data.Vector.Primitive.Mutable.MVector
                             (Control.Monad.Primitive.PrimState m) GHC.Types.Int>_R
                          ->_R Trans
                                   (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                             <Control.Monad.Primitive.PrimState m>_N))
                                   (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                  <Control.Monad.Primitive.PrimState m>_N))))
                         (let {
                            $dMonad1 :: GHC.Base.Monad m
                            = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                          } in
                          GHC.Base.>>=
                            @ m
                            $dMonad1
                            @ (Data.Vector.Primitive.Mutable.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                            @ (Data.Vector.Primitive.Mutable.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                            (let {
                               size :: GHC.Types.Int
                               = Data.Vector.Primitive.$fVectorVectora_$ssizeOf
                                   (GHC.Err.undefined @ GHC.Types.Int)
                             } in
                             case eta of wild1 { GHC.Types.I# x ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.<# x 0) of wild2 {
                               GHC.Types.False
                               -> case GHC.Real.$fIntegralInt_$cdiv
                                         GHC.Base.maxInt
                                         size of wild3 { GHC.Types.I# y ->
                                  case GHC.Prim.tagToEnum#
                                         @ GHC.Types.Bool
                                         (GHC.Prim.># x y) of wild4 {
                                    GHC.Types.False
                                    -> GHC.Base.liftM
                                         @ (Data.Primitive.ByteArray.MutableByteArray
                                              (Control.Monad.Primitive.PrimState m))
                                         @ (Data.Vector.Primitive.Mutable.MVector
                                              (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                                         @ m
                                         (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                                         (Data.Vector.Primitive.Mutable.$WMVector
                                            @ (Control.Monad.Primitive.PrimState m)
                                            @ GHC.Types.Int
                                            (GHC.Types.I# 0)
                                            wild1)
                                         (case GHC.Num.$fNumInt_$c*
                                                 wild1
                                                 size of wild5 { GHC.Types.I# n# ->
                                          Control.Monad.Primitive.primitive
                                            @ m
                                            $dPrimMonad
                                            @ (Data.Primitive.ByteArray.MutableByteArray
                                                 (Control.Monad.Primitive.PrimState m))
                                            (\ s# :: GHC.Prim.State#
                                                       (Control.Monad.Primitive.PrimState
                                                          m)[OneShot] ->
                                             case GHC.Prim.newByteArray#
                                                    @ (Control.Monad.Primitive.PrimState m)
                                                    n#
                                                    s# of ds1 { (#,#) ipv ipv1 ->
                                             (# ipv,
                                                Data.Primitive.ByteArray.MutableByteArray
                                                  @ (Control.Monad.Primitive.PrimState m)
                                                  ipv1 #) }) })
                                    GHC.Types.True
                                    -> GHC.Base.$
                                         @ [GHC.Types.Char]
                                         @ (m (Data.Vector.Primitive.Mutable.MVector
                                                 (Control.Monad.Primitive.PrimState m)
                                                 GHC.Types.Int))
                                         (GHC.Err.error
                                            @ (m (Data.Vector.Primitive.Mutable.MVector
                                                    (Control.Monad.Primitive.PrimState m)
                                                    GHC.Types.Int)))
                                         (GHC.Base.augment
                                            @ GHC.Types.Char
                                            (\ @ b
                                               c :: GHC.Types.Char -> b -> b[OneShot]
                                               n :: b[OneShot] ->
                                             GHC.CString.unpackFoldrCString#
                                               @ b
                                               "Primitive.basicUnsafeNew: length to large: "#
                                               c
                                               n)
                                            (GHC.Show.$fShowInt_$cshow wild1)) } }
                               GHC.Types.True
                               -> GHC.Base.$
                                    @ [GHC.Types.Char]
                                    @ (m (Data.Vector.Primitive.Mutable.MVector
                                            (Control.Monad.Primitive.PrimState m) GHC.Types.Int))
                                    (GHC.Err.error
                                       @ (m (Data.Vector.Primitive.Mutable.MVector
                                               (Control.Monad.Primitive.PrimState m)
                                               GHC.Types.Int)))
                                    (GHC.Base.augment
                                       @ GHC.Types.Char
                                       (\ @ b
                                          c :: GHC.Types.Char -> b -> b[OneShot]
                                          n :: b[OneShot] ->
                                        GHC.CString.unpackFoldrCString#
                                          @ b
                                          "Primitive.basicUnsafeNew: negative length: "#
                                          c
                                          n)
                                       (GHC.Show.$fShowInt_$cshow wild1)) } })
                            (\ v1 :: Data.Vector.Primitive.Mutable.MVector
                                       (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                             GHC.Base.>>
                               @ m
                               $dMonad1
                               @ ()
                               @ (Data.Vector.Primitive.Mutable.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                               (case v1 of wild1 { Data.Vector.Primitive.Mutable.MVector dt2 dt3 dt4 ->
                                Control.Monad.Primitive.primitive
                                  @ m
                                  $dPrimMonad
                                  @ ()
                                  (\ s# :: GHC.Prim.State#
                                             (Control.Monad.Primitive.PrimState m)[OneShot] ->
                                   case GHC.Base.id
                                          @ GHC.Types.Int
                                          (GHC.Types.I# dt2) of wild2 { GHC.Types.I# x#1 ->
                                   case ((Data.Primitive.Internal.Operations.setIntArray#
                                            @ (Control.Monad.Primitive.PrimState m)
                                            dt4
                                            (GHC.Int.I64# x#1)
                                              `cast`
                                            (Sym (Foreign.C.Types.NTCo:CPtrdiff[0]))
                                            (GHC.Word.W64# (GHC.Prim.int2Word# dt3))
                                              `cast`
                                            (Sym (Foreign.C.Types.NTCo:CSize[0]))
                                            dt)
                                           `cast`
                                         (Trans
                                              (GHC.Types.NTCo:IO[0] <()>_R)
                                              ((GHC.Prim.State#
                                                  (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R
                                               ->_R ((# (GHC.Prim.State#
                                                           (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R,
                                                        <()>_R #))_R))
                                           s#
                                             `cast`
                                           (GHC.Prim.State#
                                              (Trans
                                                   (UnivCo mkUnsafeCo nominal (Control.Monad.Primitive.PrimState
                                                                                 m) GHC.Prim.RealWorld)
                                                   (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0]))))_R)
                                          `cast`
                                        ((# (GHC.Prim.State#
                                               (Trans
                                                    (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])
                                                    (UnivCo mkUnsafeCo nominal GHC.Prim.RealWorld (Control.Monad.Primitive.PrimState
                                                                                                     m))))_R,
                                            UnivCo mkUnsafeCo representational () GHC.Prim.Any #))_R of ds1 { (#,#) ipv ipv1 ->
                                   (# ipv, GHC.Tuple.() #) } }) })
                               (GHC.Base.return
                                  @ m
                                  $dMonad1
                                  @ (Data.Vector.Primitive.Mutable.MVector
                                       (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                                  v1))))
                      (\ as :: Data.Vector.Unboxed.Base.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (Data.Vector.Unboxed.Base.MVector
                              (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                         @ (Data.Vector.Unboxed.Base.MVector
                              (Control.Monad.Primitive.PrimState m)
                              (GHC.Types.Int, GHC.Types.Int))
                         (GHC.Base.liftM
                            @ (Data.Vector.Primitive.Mutable.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                            @ (Data.Vector.Unboxed.Base.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                            @ m
                            (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                            (\ tpl :: Data.Vector.Primitive.Mutable.MVector
                                        (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                             tpl)
                              `cast`
                            (<Data.Vector.Primitive.Mutable.MVector
                                (Control.Monad.Primitive.PrimState m) GHC.Types.Int>_R
                             ->_R Trans
                                      (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                                <Control.Monad.Primitive.PrimState m>_N))
                                      (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                     <Control.Monad.Primitive.PrimState m>_N))))
                            (let {
                               $dMonad1 :: GHC.Base.Monad m
                               = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                             } in
                             GHC.Base.>>=
                               @ m
                               $dMonad1
                               @ (Data.Vector.Primitive.Mutable.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                               @ (Data.Vector.Primitive.Mutable.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                               (let {
                                  size :: GHC.Types.Int
                                  = Data.Vector.Primitive.$fVectorVectora_$ssizeOf
                                      (GHC.Err.undefined @ GHC.Types.Int)
                                } in
                                case eta of wild1 { GHC.Types.I# x ->
                                case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.<# x 0) of wild2 {
                                  GHC.Types.False
                                  -> case GHC.Real.$fIntegralInt_$cdiv
                                            GHC.Base.maxInt
                                            size of wild3 { GHC.Types.I# y ->
                                     case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.># x y) of wild4 {
                                       GHC.Types.False
                                       -> GHC.Base.liftM
                                            @ (Data.Primitive.ByteArray.MutableByteArray
                                                 (Control.Monad.Primitive.PrimState m))
                                            @ (Data.Vector.Primitive.Mutable.MVector
                                                 (Control.Monad.Primitive.PrimState m)
                                                 GHC.Types.Int)
                                            @ m
                                            (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                                            (Data.Vector.Primitive.Mutable.$WMVector
                                               @ (Control.Monad.Primitive.PrimState m)
                                               @ GHC.Types.Int
                                               (GHC.Types.I# 0)
                                               wild1)
                                            (case GHC.Num.$fNumInt_$c*
                                                    wild1
                                                    size of wild5 { GHC.Types.I# n# ->
                                             Control.Monad.Primitive.primitive
                                               @ m
                                               $dPrimMonad
                                               @ (Data.Primitive.ByteArray.MutableByteArray
                                                    (Control.Monad.Primitive.PrimState m))
                                               (\ s# :: GHC.Prim.State#
                                                          (Control.Monad.Primitive.PrimState
                                                             m)[OneShot] ->
                                                case GHC.Prim.newByteArray#
                                                       @ (Control.Monad.Primitive.PrimState m)
                                                       n#
                                                       s# of ds1 { (#,#) ipv ipv1 ->
                                                (# ipv,
                                                   Data.Primitive.ByteArray.MutableByteArray
                                                     @ (Control.Monad.Primitive.PrimState m)
                                                     ipv1 #) }) })
                                       GHC.Types.True
                                       -> GHC.Base.$
                                            @ [GHC.Types.Char]
                                            @ (m (Data.Vector.Primitive.Mutable.MVector
                                                    (Control.Monad.Primitive.PrimState m)
                                                    GHC.Types.Int))
                                            (GHC.Err.error
                                               @ (m (Data.Vector.Primitive.Mutable.MVector
                                                       (Control.Monad.Primitive.PrimState m)
                                                       GHC.Types.Int)))
                                            (GHC.Base.augment
                                               @ GHC.Types.Char
                                               (\ @ b
                                                  c :: GHC.Types.Char -> b -> b[OneShot]
                                                  n :: b[OneShot] ->
                                                GHC.CString.unpackFoldrCString#
                                                  @ b
                                                  "Primitive.basicUnsafeNew: length to large: "#
                                                  c
                                                  n)
                                               (GHC.Show.$fShowInt_$cshow wild1)) } }
                                  GHC.Types.True
                                  -> GHC.Base.$
                                       @ [GHC.Types.Char]
                                       @ (m (Data.Vector.Primitive.Mutable.MVector
                                               (Control.Monad.Primitive.PrimState m) GHC.Types.Int))
                                       (GHC.Err.error
                                          @ (m (Data.Vector.Primitive.Mutable.MVector
                                                  (Control.Monad.Primitive.PrimState m)
                                                  GHC.Types.Int)))
                                       (GHC.Base.augment
                                          @ GHC.Types.Char
                                          (\ @ b
                                             c :: GHC.Types.Char -> b -> b[OneShot]
                                             n :: b[OneShot] ->
                                           GHC.CString.unpackFoldrCString#
                                             @ b
                                             "Primitive.basicUnsafeNew: negative length: "#
                                             c
                                             n)
                                          (GHC.Show.$fShowInt_$cshow wild1)) } })
                               (\ v1 :: Data.Vector.Primitive.Mutable.MVector
                                          (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                                GHC.Base.>>
                                  @ m
                                  $dMonad1
                                  @ ()
                                  @ (Data.Vector.Primitive.Mutable.MVector
                                       (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                                  (case v1 of wild1 { Data.Vector.Primitive.Mutable.MVector dt2 dt3 dt4 ->
                                   Control.Monad.Primitive.primitive
                                     @ m
                                     $dPrimMonad
                                     @ ()
                                     (\ s# :: GHC.Prim.State#
                                                (Control.Monad.Primitive.PrimState m)[OneShot] ->
                                      case GHC.Base.id
                                             @ GHC.Types.Int
                                             (GHC.Types.I# dt2) of wild2 { GHC.Types.I# x#1 ->
                                      case ((Data.Primitive.Internal.Operations.setIntArray#
                                               @ (Control.Monad.Primitive.PrimState m)
                                               dt4
                                               (GHC.Int.I64# x#1)
                                                 `cast`
                                               (Sym (Foreign.C.Types.NTCo:CPtrdiff[0]))
                                               (GHC.Word.W64# (GHC.Prim.int2Word# dt3))
                                                 `cast`
                                               (Sym (Foreign.C.Types.NTCo:CSize[0]))
                                               dt1)
                                              `cast`
                                            (Trans
                                                 (GHC.Types.NTCo:IO[0] <()>_R)
                                                 ((GHC.Prim.State#
                                                     (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R
                                                  ->_R ((# (GHC.Prim.State#
                                                              (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R,
                                                           <()>_R #))_R))
                                              s#
                                                `cast`
                                              (GHC.Prim.State#
                                                 (Trans
                                                      (UnivCo mkUnsafeCo nominal (Control.Monad.Primitive.PrimState
                                                                                    m) GHC.Prim.RealWorld)
                                                      (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0]))))_R)
                                             `cast`
                                           ((# (GHC.Prim.State#
                                                  (Trans
                                                       (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])
                                                       (UnivCo mkUnsafeCo nominal GHC.Prim.RealWorld (Control.Monad.Primitive.PrimState
                                                                                                        m))))_R,
                                               UnivCo mkUnsafeCo representational () GHC.Prim.Any #))_R of ds1 { (#,#) ipv ipv1 ->
                                      (# ipv, GHC.Tuple.() #) } }) })
                                  (GHC.Base.return
                                     @ m
                                     $dMonad1
                                     @ (Data.Vector.Primitive.Mutable.MVector
                                          (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                                     v1))))
                         (\ bs :: Data.Vector.Unboxed.Base.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                          GHC.Base.$
                            @ (Data.Vector.Unboxed.Base.MVector
                                 (Control.Monad.Primitive.PrimState m)
                                 (GHC.Types.Int, GHC.Types.Int))
                            @ (m (Data.Vector.Unboxed.Base.MVector
                                    (Control.Monad.Primitive.PrimState m)
                                    (GHC.Types.Int, GHC.Types.Int)))
                            (GHC.Base.return
                               @ m
                               $dMonad
                               @ (Data.Vector.Unboxed.Base.MVector
                                    (Control.Monad.Primitive.PrimState m)
                                    (GHC.Types.Int, GHC.Types.Int)))
                            (Data.Vector.Unboxed.Base.$WMV_2
                               @ (Control.Monad.Primitive.PrimState m)
                               @ GHC.Types.Int
                               @ GHC.Types.Int
                               eta
                               as
                               bs))) })) -}
f87b40583b48531412a65b59dc7a4f4f
  $fMVectorMVectorMove_$cbasicUnsafeSlice ::
    GHC.Types.Int
    -> GHC.Types.Int
    -> Data.Vector.Unboxed.Base.MVector s MoveTypes.Move
    -> Data.Vector.Unboxed.Base.MVector s MoveTypes.Move
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,1*U(U)><S,1*U(U)><S(LSS),1*U(A,U(U,A,U),U(U,A,U))>m,
     Inline: INLINE (sat-args=3),
     Unfolding: InlineRule (3, False, False)
                (\ @ s
                   idx :: GHC.Types.Int
                   len :: GHC.Types.Int
                   ds :: Data.Vector.Unboxed.Base.MVector s MoveTypes.Move ->
                 case ds
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:MVectorsMove[0] <s>_N))
                           (Trans
                                (MoveTypes.NTCo:R:MVectorsMove[0] <s>_N)
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,)[0]
                                          <s>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N)))) of wild { Data.Vector.Unboxed.Base.MV_2 dt as bs ->
                 case len of dt1 { GHC.Types.I# dt2 ->
                 case (GHC.Base.$
                         @ (Data.Vector.Primitive.Mutable.MVector s GHC.Types.Int)
                         @ (Data.Vector.Unboxed.Base.MVector s GHC.Types.Int)
                         (\ tpl :: Data.Vector.Primitive.Mutable.MVector s GHC.Types.Int ->
                          tpl)
                           `cast`
                         (<Data.Vector.Primitive.Mutable.MVector s GHC.Types.Int>_R
                          ->_R Trans
                                   (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0] <s>_N))
                                   (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                  <s>_N))))
                         (Data.Vector.Primitive.$fVectorVectora1
                            @ s
                            idx
                            dt1
                            as
                              `cast`
                            (Trans
                                 (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0] <s>_N))
                                 (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0] <s>_N))))
                        `cast`
                      (Trans
                           (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0] <s>_N))
                           (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                <s>_N)) of nt { Data.Vector.Primitive.Mutable.MVector ipv ipv1 ipv2 ->
                 case (GHC.Base.$
                         @ (Data.Vector.Primitive.Mutable.MVector s GHC.Types.Int)
                         @ (Data.Vector.Unboxed.Base.MVector s GHC.Types.Int)
                         (\ tpl :: Data.Vector.Primitive.Mutable.MVector s GHC.Types.Int ->
                          tpl)
                           `cast`
                         (<Data.Vector.Primitive.Mutable.MVector s GHC.Types.Int>_R
                          ->_R Trans
                                   (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0] <s>_N))
                                   (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                  <s>_N))))
                         (Data.Vector.Primitive.$fVectorVectora1
                            @ s
                            idx
                            dt1
                            bs
                              `cast`
                            (Trans
                                 (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0] <s>_N))
                                 (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0] <s>_N))))
                        `cast`
                      (Trans
                           (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0] <s>_N))
                           (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                <s>_N)) of nt1 { Data.Vector.Primitive.Mutable.MVector ipv3 ipv4 ipv5 ->
                 (Data.Vector.Unboxed.Base.MV_2
                    @ s
                    @ GHC.Types.Int
                    @ GHC.Types.Int
                    dt2
                    nt
                      `cast`
                    (Trans
                         (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0] <s>_N))
                         (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0] <s>_N))))
                    nt1
                      `cast`
                    (Trans
                         (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0] <s>_N))
                         (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                        <s>_N)))))
                   `cast`
                 (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,)[0]
                                <s>_N <GHC.Types.Int>_N <GHC.Types.Int>_N))) } } } })
                  `cast`
                (forall s.
                 <GHC.Types.Int>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R <Data.Vector.Unboxed.Base.MVector s MoveTypes.Move>_R
                 ->_R Trans
                          (Sym (MoveTypes.NTCo:R:MVectorsMove[0] <s>_N))
                          (Sub (Sym (MoveTypes.TFCo:R:MVectorsMove[0] <s>_N)))) -}
f87b40583b48531412a65b59dc7a4f4f
  $fMVectorMVectorMove_$cbasicUnsafeWrite ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Unboxed.Base.MVector
      (Control.Monad.Primitive.PrimState m) MoveTypes.Move
    -> GHC.Types.Int -> MoveTypes.Move -> m ()
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(S(LLC(C(S))LL)L),U(1*U(A,A,1*C1(C1(U)),A,A),C(U))><S(LSS),1*U(A,U(U,A,U),U(U,A,U))><L,U(U)><S,1*U(U,U)>,
     Inline: INLINE (sat-args=3),
     Unfolding: InlineRule (3, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   ds :: Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m) MoveTypes.Move
                   idx :: GHC.Types.Int
                   val :: MoveTypes.Move ->
                 case ds
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:MVectorsMove[0]
                                     <Control.Monad.Primitive.PrimState m>_N))
                           (Trans
                                (MoveTypes.NTCo:R:MVectorsMove[0]
                                     <Control.Monad.Primitive.PrimState m>_N)
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,)[0]
                                          <Control.Monad.Primitive.PrimState m>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N)))) of wild { Data.Vector.Unboxed.Base.MV_2 dt as bs ->
                 case val of wild1 { MoveTypes.Move dt1 dt2 ->
                 GHC.Base.>>
                   @ m
                   (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                   @ ()
                   @ ()
                   (case as
                           `cast`
                         (Trans
                              (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                        <Control.Monad.Primitive.PrimState m>_N))
                              (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                   <Control.Monad.Primitive.PrimState
                                      m>_N)) of wild2 { Data.Vector.Primitive.Mutable.MVector dt3 dt4 dt5 ->
                    case GHC.Num.$fNumInt_$c+
                           (GHC.Types.I# dt3)
                           idx of wild3 { GHC.Types.I# i# ->
                    Control.Monad.Primitive.primitive
                      @ m
                      $dPrimMonad
                      @ ()
                      (\ s# :: GHC.Prim.State#
                                 (Control.Monad.Primitive.PrimState m)[OneShot] ->
                       case GHC.Prim.writeIntArray#
                              @ (Control.Monad.Primitive.PrimState m)
                              dt5
                              i#
                              dt1
                              s# of s'# { DEFAULT ->
                       (# s'#, GHC.Tuple.() #) }) } })
                   (case bs
                           `cast`
                         (Trans
                              (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                        <Control.Monad.Primitive.PrimState m>_N))
                              (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                   <Control.Monad.Primitive.PrimState
                                      m>_N)) of wild2 { Data.Vector.Primitive.Mutable.MVector dt3 dt4 dt5 ->
                    case GHC.Num.$fNumInt_$c+
                           (GHC.Types.I# dt3)
                           idx of wild3 { GHC.Types.I# i# ->
                    Control.Monad.Primitive.primitive
                      @ m
                      $dPrimMonad
                      @ ()
                      (\ s# :: GHC.Prim.State#
                                 (Control.Monad.Primitive.PrimState m)[OneShot] ->
                       case GHC.Prim.writeIntArray#
                              @ (Control.Monad.Primitive.PrimState m)
                              dt5
                              i#
                              dt2
                              s# of s'# { DEFAULT ->
                       (# s'#, GHC.Tuple.() #) }) } }) } }) -}
7974ea60cb767d2cccb374fcf473a0ab
  $fMVectorMVectorPromotion ::
    Data.Vector.Generic.Mutable.Base.MVector
      Data.Vector.Unboxed.Base.MVector MoveTypes.Promotion
  DFunId[0]
  {- Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Vector.Unboxed.Base.MVector
                  @ MoveTypes.Promotion
                  MoveTypes.$fMVectorMVectorPromotion_$cbasicLength
                  MoveTypes.$fMVectorMVectorPromotion_$cbasicUnsafeSlice
                  MoveTypes.$fMVectorMVectorPromotion_$cbasicOverlaps
                  MoveTypes.$fMVectorMVectorPromotion_$cbasicUnsafeNew
                  MoveTypes.$fMVectorMVectorPromotion_$cbasicInitialize
                  MoveTypes.$fMVectorMVectorPromotion_$cbasicUnsafeReplicate
                  MoveTypes.$fMVectorMVectorPromotion_$cbasicUnsafeRead
                  MoveTypes.$fMVectorMVectorPromotion_$cbasicUnsafeWrite
                  MoveTypes.$fMVectorMVectorPromotion_$cbasicClear
                  MoveTypes.$fMVectorMVectorPromotion_$cbasicSet
                  MoveTypes.$fMVectorMVectorPromotion_$cbasicUnsafeCopy
                  MoveTypes.$fMVectorMVectorPromotion_$cbasicUnsafeMove
                  MoveTypes.$fMVectorMVectorPromotion_$cbasicUnsafeGrow -}
7974ea60cb767d2cccb374fcf473a0ab
  $fMVectorMVectorPromotion_$cbasicClear ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Unboxed.Base.MVector
      (Control.Monad.Primitive.PrimState m) MoveTypes.Promotion
    -> m ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),U(U(U,U,U,U,U),A)><S,1*U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   ds :: Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m) MoveTypes.Promotion ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                 } in
                 GHC.Prim.seq
                   @ (Data.Vector.Unboxed.Base.MVector
                        (Control.Monad.Primitive.PrimState m) MoveTypes.Promotion)
                   @ (m ())
                   ds
                   (GHC.Base.>>
                      @ m
                      $dMonad
                      @ ()
                      @ ()
                      (GHC.Base.return
                         @ m
                         (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                         @ ()
                         GHC.Tuple.())
                      (GHC.Base.>>
                         @ m
                         $dMonad
                         @ ()
                         @ ()
                         (GHC.Base.return
                            @ m
                            (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                            @ ()
                            GHC.Tuple.())
                         (GHC.Base.return
                            @ m
                            (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                            @ ()
                            GHC.Tuple.())))) -}
7974ea60cb767d2cccb374fcf473a0ab
  $fMVectorMVectorPromotion_$cbasicInitialize ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Unboxed.Base.MVector
      (Control.Monad.Primitive.PrimState m) MoveTypes.Promotion
    -> m ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),U(1*U,C(U))><S(LSSS),1*U(A,U(U,U,U),U(U,U,U),U(U,U,U))>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   ds :: Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m) MoveTypes.Promotion ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                 } in
                 case ds
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:MVectorsPromotion[0]
                                     <Control.Monad.Primitive.PrimState m>_N))
                           (Trans
                                (MoveTypes.NTCo:R:MVectorsPromotion[0]
                                     <Control.Monad.Primitive.PrimState m>_N)
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,,)[0]
                                          <Control.Monad.Primitive.PrimState m>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Word.Word8>_N)))) of wild { Data.Vector.Unboxed.Base.MV_3 dt as bs cs ->
                 GHC.Base.>>
                   @ m
                   $dMonad
                   @ ()
                   @ ()
                   (case as
                           `cast`
                         (Trans
                              (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                        <Control.Monad.Primitive.PrimState m>_N))
                              (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                   <Control.Monad.Primitive.PrimState
                                      m>_N)) of wild1 { Data.Vector.Primitive.Mutable.MVector dt1 dt2 dt3 ->
                    let {
                      size :: GHC.Types.Int
                      = Data.Vector.Primitive.$fVectorVectora_$ssizeOf
                          (GHC.Err.undefined @ GHC.Types.Int)
                    } in
                    case GHC.Num.$fNumInt_$c*
                           (GHC.Types.I# dt1)
                           size of wild2 { GHC.Types.I# doff# ->
                    case GHC.Num.$fNumInt_$c*
                           (GHC.Types.I# dt2)
                           size of wild3 { GHC.Types.I# sz# ->
                    Control.Monad.Primitive.primitive
                      @ m
                      $dPrimMonad
                      @ ()
                      (\ s# :: GHC.Prim.State#
                                 (Control.Monad.Primitive.PrimState m)[OneShot] ->
                       case GHC.Word.$cfromInteger
                              __integer 0 of wild4 { GHC.Word.W8# x# ->
                       case GHC.Base.id
                              @ GHC.Types.Int
                              (GHC.Types.I# doff#) of wild5 { GHC.Types.I# x#1 ->
                       case ((Data.Primitive.Internal.Operations.setWord8Array#
                                @ (Control.Monad.Primitive.PrimState m)
                                dt3
                                (GHC.Int.I64# x#1) `cast` (Sym (Foreign.C.Types.NTCo:CPtrdiff[0]))
                                (GHC.Word.W64# (GHC.Prim.int2Word# sz#))
                                  `cast`
                                (Sym (Foreign.C.Types.NTCo:CSize[0]))
                                x#)
                               `cast`
                             (Trans
                                  (GHC.Types.NTCo:IO[0] <()>_R)
                                  ((GHC.Prim.State#
                                      (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R
                                   ->_R ((# (GHC.Prim.State#
                                               (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R,
                                            <()>_R #))_R))
                               s#
                                 `cast`
                               (GHC.Prim.State#
                                  (Trans
                                       (UnivCo mkUnsafeCo nominal (Control.Monad.Primitive.PrimState
                                                                     m) GHC.Prim.RealWorld)
                                       (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0]))))_R)
                              `cast`
                            ((# (GHC.Prim.State#
                                   (Trans
                                        (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])
                                        (UnivCo mkUnsafeCo nominal GHC.Prim.RealWorld (Control.Monad.Primitive.PrimState
                                                                                         m))))_R,
                                UnivCo mkUnsafeCo representational () GHC.Prim.Any #))_R of ds1 { (#,#) ipv ipv1 ->
                       (# ipv, GHC.Tuple.() #) } } }) } } })
                   (GHC.Base.>>
                      @ m
                      $dMonad
                      @ ()
                      @ ()
                      (case bs
                              `cast`
                            (Trans
                                 (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                           <Control.Monad.Primitive.PrimState m>_N))
                                 (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                      <Control.Monad.Primitive.PrimState
                                         m>_N)) of wild1 { Data.Vector.Primitive.Mutable.MVector dt1 dt2 dt3 ->
                       let {
                         size :: GHC.Types.Int
                         = Data.Vector.Primitive.$fVectorVectora_$ssizeOf
                             (GHC.Err.undefined @ GHC.Types.Int)
                       } in
                       case GHC.Num.$fNumInt_$c*
                              (GHC.Types.I# dt1)
                              size of wild2 { GHC.Types.I# doff# ->
                       case GHC.Num.$fNumInt_$c*
                              (GHC.Types.I# dt2)
                              size of wild3 { GHC.Types.I# sz# ->
                       Control.Monad.Primitive.primitive
                         @ m
                         $dPrimMonad
                         @ ()
                         (\ s# :: GHC.Prim.State#
                                    (Control.Monad.Primitive.PrimState m)[OneShot] ->
                          case GHC.Word.$cfromInteger
                                 __integer 0 of wild4 { GHC.Word.W8# x# ->
                          case GHC.Base.id
                                 @ GHC.Types.Int
                                 (GHC.Types.I# doff#) of wild5 { GHC.Types.I# x#1 ->
                          case ((Data.Primitive.Internal.Operations.setWord8Array#
                                   @ (Control.Monad.Primitive.PrimState m)
                                   dt3
                                   (GHC.Int.I64# x#1)
                                     `cast`
                                   (Sym (Foreign.C.Types.NTCo:CPtrdiff[0]))
                                   (GHC.Word.W64# (GHC.Prim.int2Word# sz#))
                                     `cast`
                                   (Sym (Foreign.C.Types.NTCo:CSize[0]))
                                   x#)
                                  `cast`
                                (Trans
                                     (GHC.Types.NTCo:IO[0] <()>_R)
                                     ((GHC.Prim.State#
                                         (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R
                                      ->_R ((# (GHC.Prim.State#
                                                  (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R,
                                               <()>_R #))_R))
                                  s#
                                    `cast`
                                  (GHC.Prim.State#
                                     (Trans
                                          (UnivCo mkUnsafeCo nominal (Control.Monad.Primitive.PrimState
                                                                        m) GHC.Prim.RealWorld)
                                          (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0]))))_R)
                                 `cast`
                               ((# (GHC.Prim.State#
                                      (Trans
                                           (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])
                                           (UnivCo mkUnsafeCo nominal GHC.Prim.RealWorld (Control.Monad.Primitive.PrimState
                                                                                            m))))_R,
                                   UnivCo mkUnsafeCo representational () GHC.Prim.Any #))_R of ds1 { (#,#) ipv ipv1 ->
                          (# ipv, GHC.Tuple.() #) } } }) } } })
                      (case cs
                              `cast`
                            (Trans
                                 (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                           <Control.Monad.Primitive.PrimState m>_N))
                                 (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                      <Control.Monad.Primitive.PrimState
                                         m>_N)) of wild1 { Data.Vector.Primitive.Mutable.MVector dt1 dt2 dt3 ->
                       let {
                         size :: GHC.Types.Int
                         = Data.Vector.Unboxed.Base.$fMVectorMVectorBool_$ssizeOf
                             (GHC.Err.undefined @ GHC.Word.Word8)
                       } in
                       case GHC.Num.$fNumInt_$c*
                              (GHC.Types.I# dt1)
                              size of wild2 { GHC.Types.I# doff# ->
                       case GHC.Num.$fNumInt_$c*
                              (GHC.Types.I# dt2)
                              size of wild3 { GHC.Types.I# sz# ->
                       Control.Monad.Primitive.primitive
                         @ m
                         $dPrimMonad
                         @ ()
                         (\ s# :: GHC.Prim.State#
                                    (Control.Monad.Primitive.PrimState m)[OneShot] ->
                          case GHC.Word.$cfromInteger
                                 __integer 0 of wild4 { GHC.Word.W8# x# ->
                          case GHC.Base.id
                                 @ GHC.Types.Int
                                 (GHC.Types.I# doff#) of wild5 { GHC.Types.I# x#1 ->
                          case ((Data.Primitive.Internal.Operations.setWord8Array#
                                   @ (Control.Monad.Primitive.PrimState m)
                                   dt3
                                   (GHC.Int.I64# x#1)
                                     `cast`
                                   (Sym (Foreign.C.Types.NTCo:CPtrdiff[0]))
                                   (GHC.Word.W64# (GHC.Prim.int2Word# sz#))
                                     `cast`
                                   (Sym (Foreign.C.Types.NTCo:CSize[0]))
                                   x#)
                                  `cast`
                                (Trans
                                     (GHC.Types.NTCo:IO[0] <()>_R)
                                     ((GHC.Prim.State#
                                         (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R
                                      ->_R ((# (GHC.Prim.State#
                                                  (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R,
                                               <()>_R #))_R))
                                  s#
                                    `cast`
                                  (GHC.Prim.State#
                                     (Trans
                                          (UnivCo mkUnsafeCo nominal (Control.Monad.Primitive.PrimState
                                                                        m) GHC.Prim.RealWorld)
                                          (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0]))))_R)
                                 `cast`
                               ((# (GHC.Prim.State#
                                      (Trans
                                           (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])
                                           (UnivCo mkUnsafeCo nominal GHC.Prim.RealWorld (Control.Monad.Primitive.PrimState
                                                                                            m))))_R,
                                   UnivCo mkUnsafeCo representational () GHC.Prim.Any #))_R of ds1 { (#,#) ipv ipv1 ->
                          (# ipv, GHC.Tuple.() #) } } }) } } })) }) -}
7974ea60cb767d2cccb374fcf473a0ab
  $fMVectorMVectorPromotion_$cbasicLength ::
    Data.Vector.Unboxed.Base.MVector s MoveTypes.Promotion
    -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LSSS),1*U(U,1*H,1*H,1*H)>m,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ s
                   ds :: Data.Vector.Unboxed.Base.MVector s MoveTypes.Promotion ->
                 case ds
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:MVectorsPromotion[0] <s>_N))
                           (Trans
                                (MoveTypes.NTCo:R:MVectorsPromotion[0] <s>_N)
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,,)[0]
                                          <s>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Word.Word8>_N)))) of wild { Data.Vector.Unboxed.Base.MV_3 dt ds1 ds2 ds3 ->
                 GHC.Types.I# dt }) -}
7974ea60cb767d2cccb374fcf473a0ab
  $fMVectorMVectorPromotion_$cbasicOverlaps ::
    Data.Vector.Unboxed.Base.MVector s MoveTypes.Promotion
    -> Data.Vector.Unboxed.Base.MVector s MoveTypes.Promotion
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LSSS),1*U(A,U(U,U,U),U(U,U,U),U(U,U,U))><S,1*U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   ds :: Data.Vector.Unboxed.Base.MVector s MoveTypes.Promotion
                   ds1 :: Data.Vector.Unboxed.Base.MVector s MoveTypes.Promotion ->
                 case ds
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:MVectorsPromotion[0] <s>_N))
                           (Trans
                                (MoveTypes.NTCo:R:MVectorsPromotion[0] <s>_N)
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,,)[0]
                                          <s>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Word.Word8>_N)))) of wild { Data.Vector.Unboxed.Base.MV_3 dt as1 bs1 cs1 ->
                 case ds1
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:MVectorsPromotion[0] <s>_N))
                           (Trans
                                (MoveTypes.NTCo:R:MVectorsPromotion[0] <s>_N)
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,,)[0]
                                          <s>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Word.Word8>_N)))) of wild1 { Data.Vector.Unboxed.Base.MV_3 dt1 as2 bs2 cs2 ->
                 case as1
                        `cast`
                      (Trans
                           (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0] <s>_N))
                           (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                <s>_N)) of wild2 { Data.Vector.Primitive.Mutable.MVector dt2 dt3 dt4 ->
                 let {
                   i :: GHC.Types.Int = GHC.Types.I# dt2
                 } in
                 case as2
                        `cast`
                      (Trans
                           (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0] <s>_N))
                           (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                <s>_N)) of wild3 { Data.Vector.Primitive.Mutable.MVector dt5 dt6 dt7 ->
                 let {
                   j :: GHC.Types.Int = GHC.Types.I# dt5
                 } in
                 let {
                   between :: forall a8.
                              GHC.Classes.Ord a8 =>
                              a8 -> a8 -> a8 -> GHC.Types.Bool
                     {- Arity: 4 -}
                   = \ @ a8 $dOrd :: GHC.Classes.Ord a8 x :: a8 y :: a8 z :: a8 ->
                     GHC.Classes.&&
                       (GHC.Classes.>= @ a8 $dOrd x y)
                       (GHC.Classes.< @ a8 $dOrd x z)
                 } in
                 GHC.Classes.||
                   (GHC.Classes.&&
                      (GHC.Prim.tagToEnum#
                         @ GHC.Types.Bool
                         (GHC.Prim.sameMutableByteArray# @ s dt4 dt7))
                      (GHC.Classes.||
                         (between
                            @ GHC.Types.Int
                            GHC.Classes.$fOrdInt
                            i
                            j
                            (GHC.Num.$fNumInt_$c+ j (GHC.Types.I# dt6)))
                         (between
                            @ GHC.Types.Int
                            GHC.Classes.$fOrdInt
                            j
                            i
                            (GHC.Num.$fNumInt_$c+ i (GHC.Types.I# dt3)))))
                   (case bs1
                           `cast`
                         (Trans
                              (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0] <s>_N))
                              (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                   <s>_N)) of wild4 { Data.Vector.Primitive.Mutable.MVector dt8 dt9 dt10 ->
                    let {
                      i1 :: GHC.Types.Int = GHC.Types.I# dt8
                    } in
                    case bs2
                           `cast`
                         (Trans
                              (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0] <s>_N))
                              (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                   <s>_N)) of wild5 { Data.Vector.Primitive.Mutable.MVector dt11 dt12 dt13 ->
                    let {
                      j1 :: GHC.Types.Int = GHC.Types.I# dt11
                    } in
                    let {
                      between1 :: forall a8.
                                  GHC.Classes.Ord a8 =>
                                  a8 -> a8 -> a8 -> GHC.Types.Bool
                        {- Arity: 4 -}
                      = \ @ a8 $dOrd :: GHC.Classes.Ord a8 x :: a8 y :: a8 z :: a8 ->
                        GHC.Classes.&&
                          (GHC.Classes.>= @ a8 $dOrd x y)
                          (GHC.Classes.< @ a8 $dOrd x z)
                    } in
                    GHC.Classes.||
                      (GHC.Classes.&&
                         (GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.sameMutableByteArray# @ s dt10 dt13))
                         (GHC.Classes.||
                            (between1
                               @ GHC.Types.Int
                               GHC.Classes.$fOrdInt
                               i1
                               j1
                               (GHC.Num.$fNumInt_$c+ j1 (GHC.Types.I# dt12)))
                            (between1
                               @ GHC.Types.Int
                               GHC.Classes.$fOrdInt
                               j1
                               i1
                               (GHC.Num.$fNumInt_$c+ i1 (GHC.Types.I# dt9)))))
                      (case cs1
                              `cast`
                            (Trans
                                 (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0] <s>_N))
                                 (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                      <s>_N)) of wild6 { Data.Vector.Primitive.Mutable.MVector dt14 dt15 dt16 ->
                       let {
                         i2 :: GHC.Types.Int = GHC.Types.I# dt14
                       } in
                       case cs2
                              `cast`
                            (Trans
                                 (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0] <s>_N))
                                 (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                      <s>_N)) of wild7 { Data.Vector.Primitive.Mutable.MVector dt17 dt18 dt19 ->
                       let {
                         j2 :: GHC.Types.Int = GHC.Types.I# dt17
                       } in
                       let {
                         between2 :: forall a20.
                                     GHC.Classes.Ord a20 =>
                                     a20 -> a20 -> a20 -> GHC.Types.Bool
                           {- Arity: 4 -}
                         = \ @ a20
                             $dOrd :: GHC.Classes.Ord a20
                             x :: a20
                             y :: a20
                             z :: a20 ->
                           GHC.Classes.&&
                             (GHC.Classes.>= @ a20 $dOrd x y)
                             (GHC.Classes.< @ a20 $dOrd x z)
                       } in
                       GHC.Classes.&&
                         (GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.sameMutableByteArray# @ s dt16 dt19))
                         (GHC.Classes.||
                            (between2
                               @ GHC.Types.Int
                               GHC.Classes.$fOrdInt
                               i2
                               j2
                               (GHC.Num.$fNumInt_$c+ j2 (GHC.Types.I# dt18)))
                            (between2
                               @ GHC.Types.Int
                               GHC.Classes.$fOrdInt
                               j2
                               i2
                               (GHC.Num.$fNumInt_$c+
                                  i2
                                  (GHC.Types.I# dt15)))) } }) } }) } } } }) -}
7974ea60cb767d2cccb374fcf473a0ab
  $fMVectorMVectorPromotion_$cbasicSet ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Unboxed.Base.MVector
      (Control.Monad.Primitive.PrimState m) MoveTypes.Promotion
    -> MoveTypes.Promotion -> m ()
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(SL),U(1*U,C(U))><S(LSSS),1*U(A,U(U,U,U),U(U,U,U),U(U,U,U))><S,1*U(U,U,U)>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   ds :: Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m) MoveTypes.Promotion
                   val :: MoveTypes.Promotion ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                 } in
                 case ds
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:MVectorsPromotion[0]
                                     <Control.Monad.Primitive.PrimState m>_N))
                           (Trans
                                (MoveTypes.NTCo:R:MVectorsPromotion[0]
                                     <Control.Monad.Primitive.PrimState m>_N)
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,,)[0]
                                          <Control.Monad.Primitive.PrimState m>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Word.Word8>_N)))) of wild { Data.Vector.Unboxed.Base.MV_3 dt as bs cs ->
                 case val of wild1 { MoveTypes.Promotion dt1 dt2 dt3 ->
                 GHC.Base.>>
                   @ m
                   $dMonad
                   @ ()
                   @ ()
                   (case as
                           `cast`
                         (Trans
                              (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                        <Control.Monad.Primitive.PrimState m>_N))
                              (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                   <Control.Monad.Primitive.PrimState
                                      m>_N)) of wild2 { Data.Vector.Primitive.Mutable.MVector dt4 dt5 dt6 ->
                    Control.Monad.Primitive.primitive
                      @ m
                      $dPrimMonad
                      @ ()
                      (\ s# :: GHC.Prim.State#
                                 (Control.Monad.Primitive.PrimState m)[OneShot] ->
                       case GHC.Base.id
                              @ GHC.Types.Int
                              (GHC.Types.I# dt4) of wild3 { GHC.Types.I# x#1 ->
                       case ((Data.Primitive.Internal.Operations.setIntArray#
                                @ (Control.Monad.Primitive.PrimState m)
                                dt6
                                (GHC.Int.I64# x#1) `cast` (Sym (Foreign.C.Types.NTCo:CPtrdiff[0]))
                                (GHC.Word.W64# (GHC.Prim.int2Word# dt5))
                                  `cast`
                                (Sym (Foreign.C.Types.NTCo:CSize[0]))
                                dt1)
                               `cast`
                             (Trans
                                  (GHC.Types.NTCo:IO[0] <()>_R)
                                  ((GHC.Prim.State#
                                      (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R
                                   ->_R ((# (GHC.Prim.State#
                                               (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R,
                                            <()>_R #))_R))
                               s#
                                 `cast`
                               (GHC.Prim.State#
                                  (Trans
                                       (UnivCo mkUnsafeCo nominal (Control.Monad.Primitive.PrimState
                                                                     m) GHC.Prim.RealWorld)
                                       (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0]))))_R)
                              `cast`
                            ((# (GHC.Prim.State#
                                   (Trans
                                        (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])
                                        (UnivCo mkUnsafeCo nominal GHC.Prim.RealWorld (Control.Monad.Primitive.PrimState
                                                                                         m))))_R,
                                UnivCo mkUnsafeCo representational () GHC.Prim.Any #))_R of ds1 { (#,#) ipv ipv1 ->
                       (# ipv, GHC.Tuple.() #) } }) })
                   (GHC.Base.>>
                      @ m
                      $dMonad
                      @ ()
                      @ ()
                      (case bs
                              `cast`
                            (Trans
                                 (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                           <Control.Monad.Primitive.PrimState m>_N))
                                 (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                      <Control.Monad.Primitive.PrimState
                                         m>_N)) of wild2 { Data.Vector.Primitive.Mutable.MVector dt4 dt5 dt6 ->
                       Control.Monad.Primitive.primitive
                         @ m
                         $dPrimMonad
                         @ ()
                         (\ s# :: GHC.Prim.State#
                                    (Control.Monad.Primitive.PrimState m)[OneShot] ->
                          case GHC.Base.id
                                 @ GHC.Types.Int
                                 (GHC.Types.I# dt4) of wild3 { GHC.Types.I# x#1 ->
                          case ((Data.Primitive.Internal.Operations.setIntArray#
                                   @ (Control.Monad.Primitive.PrimState m)
                                   dt6
                                   (GHC.Int.I64# x#1)
                                     `cast`
                                   (Sym (Foreign.C.Types.NTCo:CPtrdiff[0]))
                                   (GHC.Word.W64# (GHC.Prim.int2Word# dt5))
                                     `cast`
                                   (Sym (Foreign.C.Types.NTCo:CSize[0]))
                                   dt2)
                                  `cast`
                                (Trans
                                     (GHC.Types.NTCo:IO[0] <()>_R)
                                     ((GHC.Prim.State#
                                         (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R
                                      ->_R ((# (GHC.Prim.State#
                                                  (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R,
                                               <()>_R #))_R))
                                  s#
                                    `cast`
                                  (GHC.Prim.State#
                                     (Trans
                                          (UnivCo mkUnsafeCo nominal (Control.Monad.Primitive.PrimState
                                                                        m) GHC.Prim.RealWorld)
                                          (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0]))))_R)
                                 `cast`
                               ((# (GHC.Prim.State#
                                      (Trans
                                           (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])
                                           (UnivCo mkUnsafeCo nominal GHC.Prim.RealWorld (Control.Monad.Primitive.PrimState
                                                                                            m))))_R,
                                   UnivCo mkUnsafeCo representational () GHC.Prim.Any #))_R of ds1 { (#,#) ipv ipv1 ->
                          (# ipv, GHC.Tuple.() #) } }) })
                      (case cs
                              `cast`
                            (Trans
                                 (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                           <Control.Monad.Primitive.PrimState m>_N))
                                 (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                      <Control.Monad.Primitive.PrimState
                                         m>_N)) of wild2 { Data.Vector.Primitive.Mutable.MVector dt4 dt5 dt6 ->
                       Control.Monad.Primitive.primitive
                         @ m
                         $dPrimMonad
                         @ ()
                         (\ s# :: GHC.Prim.State#
                                    (Control.Monad.Primitive.PrimState m)[OneShot] ->
                          case GHC.Base.id
                                 @ GHC.Types.Int
                                 (GHC.Types.I# dt4) of wild3 { GHC.Types.I# x#1 ->
                          case ((Data.Primitive.Internal.Operations.setWord8Array#
                                   @ (Control.Monad.Primitive.PrimState m)
                                   dt6
                                   (GHC.Int.I64# x#1)
                                     `cast`
                                   (Sym (Foreign.C.Types.NTCo:CPtrdiff[0]))
                                   (GHC.Word.W64# (GHC.Prim.int2Word# dt5))
                                     `cast`
                                   (Sym (Foreign.C.Types.NTCo:CSize[0]))
                                   dt3)
                                  `cast`
                                (Trans
                                     (GHC.Types.NTCo:IO[0] <()>_R)
                                     ((GHC.Prim.State#
                                         (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R
                                      ->_R ((# (GHC.Prim.State#
                                                  (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R,
                                               <()>_R #))_R))
                                  s#
                                    `cast`
                                  (GHC.Prim.State#
                                     (Trans
                                          (UnivCo mkUnsafeCo nominal (Control.Monad.Primitive.PrimState
                                                                        m) GHC.Prim.RealWorld)
                                          (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0]))))_R)
                                 `cast`
                               ((# (GHC.Prim.State#
                                      (Trans
                                           (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])
                                           (UnivCo mkUnsafeCo nominal GHC.Prim.RealWorld (Control.Monad.Primitive.PrimState
                                                                                            m))))_R,
                                   UnivCo mkUnsafeCo representational () GHC.Prim.Any #))_R of ds1 { (#,#) ipv ipv1 ->
                          (# ipv, GHC.Tuple.() #) } }) })) } }) -}
7974ea60cb767d2cccb374fcf473a0ab
  $fMVectorMVectorPromotion_$cbasicUnsafeCopy ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Unboxed.Base.MVector
      (Control.Monad.Primitive.PrimState m) MoveTypes.Promotion
    -> Data.Vector.Unboxed.Base.MVector
         (Control.Monad.Primitive.PrimState m) MoveTypes.Promotion
    -> m ()
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(SL),U(1*U,C(U))><S(LSSS),1*U(A,U(U,U,U),U(U,U,U),U(U,U,U))><S,1*U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   ds :: Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m) MoveTypes.Promotion
                   ds1 :: Data.Vector.Unboxed.Base.MVector
                            (Control.Monad.Primitive.PrimState m) MoveTypes.Promotion ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                 } in
                 case ds
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:MVectorsPromotion[0]
                                     <Control.Monad.Primitive.PrimState m>_N))
                           (Trans
                                (MoveTypes.NTCo:R:MVectorsPromotion[0]
                                     <Control.Monad.Primitive.PrimState m>_N)
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,,)[0]
                                          <Control.Monad.Primitive.PrimState m>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Word.Word8>_N)))) of wild { Data.Vector.Unboxed.Base.MV_3 dt as1 bs1 cs1 ->
                 case ds1
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:MVectorsPromotion[0]
                                     <Control.Monad.Primitive.PrimState m>_N))
                           (Trans
                                (MoveTypes.NTCo:R:MVectorsPromotion[0]
                                     <Control.Monad.Primitive.PrimState m>_N)
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,,)[0]
                                          <Control.Monad.Primitive.PrimState m>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Word.Word8>_N)))) of wild1 { Data.Vector.Unboxed.Base.MV_3 dt1 as2 bs2 cs2 ->
                 GHC.Base.>>
                   @ m
                   $dMonad
                   @ ()
                   @ ()
                   (case as1
                           `cast`
                         (Trans
                              (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                        <Control.Monad.Primitive.PrimState m>_N))
                              (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                   <Control.Monad.Primitive.PrimState
                                      m>_N)) of wild2 { Data.Vector.Primitive.Mutable.MVector dt2 dt3 dt4 ->
                    case as2
                           `cast`
                         (Trans
                              (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                        <Control.Monad.Primitive.PrimState m>_N))
                              (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                   <Control.Monad.Primitive.PrimState
                                      m>_N)) of wild3 { Data.Vector.Primitive.Mutable.MVector dt5 dt6 dt7 ->
                    let {
                      sz :: GHC.Types.Int
                      = Data.Vector.Primitive.$fVectorVectora_$ssizeOf
                          (GHC.Err.undefined @ GHC.Types.Int)
                    } in
                    Control.Monad.Primitive.primitive
                      @ m
                      $dPrimMonad
                      @ ()
                      (\ s# :: GHC.Prim.State#
                                 (Control.Monad.Primitive.PrimState m)[OneShot] ->
                       case Data.Primitive.ByteArray.unI#
                              (GHC.Num.$fNumInt_$c* (GHC.Types.I# dt3) sz) of wild4 { DEFAULT ->
                       case Data.Primitive.ByteArray.unI#
                              (GHC.Num.$fNumInt_$c* (GHC.Types.I# dt2) sz) of wild5 { DEFAULT ->
                       case Data.Primitive.ByteArray.unI#
                              (GHC.Num.$fNumInt_$c* (GHC.Types.I# dt5) sz) of wild6 { DEFAULT ->
                       case GHC.Prim.copyMutableByteArray#
                              @ (Control.Monad.Primitive.PrimState m)
                              dt7
                              wild6
                              dt4
                              wild5
                              wild4
                              s# of s'# { DEFAULT ->
                       (# s'#, GHC.Tuple.() #) } } } }) } })
                   (GHC.Base.>>
                      @ m
                      $dMonad
                      @ ()
                      @ ()
                      (case bs1
                              `cast`
                            (Trans
                                 (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                           <Control.Monad.Primitive.PrimState m>_N))
                                 (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                      <Control.Monad.Primitive.PrimState
                                         m>_N)) of wild2 { Data.Vector.Primitive.Mutable.MVector dt2 dt3 dt4 ->
                       case bs2
                              `cast`
                            (Trans
                                 (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                           <Control.Monad.Primitive.PrimState m>_N))
                                 (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                      <Control.Monad.Primitive.PrimState
                                         m>_N)) of wild3 { Data.Vector.Primitive.Mutable.MVector dt5 dt6 dt7 ->
                       let {
                         sz :: GHC.Types.Int
                         = Data.Vector.Primitive.$fVectorVectora_$ssizeOf
                             (GHC.Err.undefined @ GHC.Types.Int)
                       } in
                       Control.Monad.Primitive.primitive
                         @ m
                         $dPrimMonad
                         @ ()
                         (\ s# :: GHC.Prim.State#
                                    (Control.Monad.Primitive.PrimState m)[OneShot] ->
                          case Data.Primitive.ByteArray.unI#
                                 (GHC.Num.$fNumInt_$c* (GHC.Types.I# dt3) sz) of wild4 { DEFAULT ->
                          case Data.Primitive.ByteArray.unI#
                                 (GHC.Num.$fNumInt_$c* (GHC.Types.I# dt2) sz) of wild5 { DEFAULT ->
                          case Data.Primitive.ByteArray.unI#
                                 (GHC.Num.$fNumInt_$c* (GHC.Types.I# dt5) sz) of wild6 { DEFAULT ->
                          case GHC.Prim.copyMutableByteArray#
                                 @ (Control.Monad.Primitive.PrimState m)
                                 dt7
                                 wild6
                                 dt4
                                 wild5
                                 wild4
                                 s# of s'# { DEFAULT ->
                          (# s'#, GHC.Tuple.() #) } } } }) } })
                      (case cs1
                              `cast`
                            (Trans
                                 (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                           <Control.Monad.Primitive.PrimState m>_N))
                                 (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                      <Control.Monad.Primitive.PrimState
                                         m>_N)) of wild2 { Data.Vector.Primitive.Mutable.MVector dt2 dt3 dt4 ->
                       case cs2
                              `cast`
                            (Trans
                                 (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                           <Control.Monad.Primitive.PrimState m>_N))
                                 (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                      <Control.Monad.Primitive.PrimState
                                         m>_N)) of wild3 { Data.Vector.Primitive.Mutable.MVector dt5 dt6 dt7 ->
                       let {
                         sz :: GHC.Types.Int
                         = Data.Vector.Unboxed.Base.$fMVectorMVectorBool_$ssizeOf
                             (GHC.Err.undefined @ GHC.Word.Word8)
                       } in
                       Control.Monad.Primitive.primitive
                         @ m
                         $dPrimMonad
                         @ ()
                         (\ s# :: GHC.Prim.State#
                                    (Control.Monad.Primitive.PrimState m)[OneShot] ->
                          case Data.Primitive.ByteArray.unI#
                                 (GHC.Num.$fNumInt_$c* (GHC.Types.I# dt3) sz) of wild4 { DEFAULT ->
                          case Data.Primitive.ByteArray.unI#
                                 (GHC.Num.$fNumInt_$c* (GHC.Types.I# dt2) sz) of wild5 { DEFAULT ->
                          case Data.Primitive.ByteArray.unI#
                                 (GHC.Num.$fNumInt_$c* (GHC.Types.I# dt5) sz) of wild6 { DEFAULT ->
                          case GHC.Prim.copyMutableByteArray#
                                 @ (Control.Monad.Primitive.PrimState m)
                                 dt7
                                 wild6
                                 dt4
                                 wild5
                                 wild4
                                 s# of s'# { DEFAULT ->
                          (# s'#, GHC.Tuple.() #) } } } }) } })) } }) -}
7974ea60cb767d2cccb374fcf473a0ab
  $fMVectorMVectorPromotion_$cbasicUnsafeGrow ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Unboxed.Base.MVector
      (Control.Monad.Primitive.PrimState m) MoveTypes.Promotion
    -> GHC.Types.Int
    -> m (Data.Vector.Unboxed.Base.MVector
            (Control.Monad.Primitive.PrimState m) MoveTypes.Promotion)
  {- Arity: 3,
     Strictness: <S(SL),U(U,C(U))><L,1*U(U,U(U,U,U),U(U,U,U),U(U,U,U))><L,U(U)>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   eta :: Data.Vector.Unboxed.Base.MVector
                            (Control.Monad.Primitive.PrimState m) MoveTypes.Promotion
                   eta1 :: GHC.Types.Int ->
                 GHC.Base.liftM
                   @ (Data.Vector.Unboxed.Base.MVector
                        (Control.Monad.Primitive.PrimState m)
                        (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8))
                   @ (Data.Vector.Unboxed.Base.MVector
                        (Control.Monad.Primitive.PrimState m) MoveTypes.Promotion)
                   @ m
                   (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                   (\ tpl :: Data.Vector.Unboxed.Base.MVector
                               (Control.Monad.Primitive.PrimState m)
                               (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8) ->
                    tpl)
                     `cast`
                   (<Data.Vector.Unboxed.Base.MVector
                       (Control.Monad.Primitive.PrimState m)
                       (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8)>_R
                    ->_R Trans
                             (Sym (MoveTypes.NTCo:R:MVectorsPromotion[0]
                                       <Control.Monad.Primitive.PrimState m>_N))
                             (Sub (Sym (MoveTypes.TFCo:R:MVectorsPromotion[0]
                                            <Control.Monad.Primitive.PrimState m>_N))))
                   (let {
                      $dMonad :: GHC.Base.Monad m
                      = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                    } in
                    case eta
                           `cast`
                         (Trans
                              (Sub (MoveTypes.TFCo:R:MVectorsPromotion[0]
                                        <Control.Monad.Primitive.PrimState m>_N))
                              (Trans
                                   (MoveTypes.NTCo:R:MVectorsPromotion[0]
                                        <Control.Monad.Primitive.PrimState m>_N)
                                   (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,,)[0]
                                             <Control.Monad.Primitive.PrimState m>_N
                                             <GHC.Types.Int>_N
                                             <GHC.Types.Int>_N
                                             <GHC.Word.Word8>_N)))) of wild { Data.Vector.Unboxed.Base.MV_3 dt as bs cs ->
                    let {
                      n_ :: GHC.Types.Int = GHC.Types.I# dt
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                      @ (Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m)
                           (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8))
                      (GHC.Base.liftM
                         @ (Data.Vector.Primitive.Mutable.MVector
                              (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                         @ (Data.Vector.Unboxed.Base.MVector
                              (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                         @ m
                         (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                         (\ tpl :: Data.Vector.Primitive.Mutable.MVector
                                     (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                          tpl)
                           `cast`
                         (<Data.Vector.Primitive.Mutable.MVector
                             (Control.Monad.Primitive.PrimState m) GHC.Types.Int>_R
                          ->_R Trans
                                   (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                             <Control.Monad.Primitive.PrimState m>_N))
                                   (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                  <Control.Monad.Primitive.PrimState m>_N))))
                         (let {
                            $dMonad1 :: GHC.Base.Monad m
                            = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                          } in
                          let {
                            n :: GHC.Types.Int
                            = Data.Vector.Primitive.$fVectorVectora2
                                @ (Control.Monad.Primitive.PrimState m)
                                as
                                  `cast`
                                (Trans
                                     (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                               <Control.Monad.Primitive.PrimState m>_N))
                                     (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                          <Control.Monad.Primitive.PrimState m>_N))
                          } in
                          GHC.Base.>>=
                            @ m
                            $dMonad1
                            @ (Data.Vector.Primitive.Mutable.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                            @ (Data.Vector.Primitive.Mutable.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                            (let {
                               size :: GHC.Types.Int
                               = Data.Vector.Primitive.$fVectorVectora_$ssizeOf
                                   (GHC.Err.undefined @ GHC.Types.Int)
                             } in
                             case GHC.Num.$fNumInt_$c+ n eta1 of wild1 { GHC.Types.I# x ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.<# x 0) of wild2 {
                               GHC.Types.False
                               -> case GHC.Real.$fIntegralInt_$cdiv
                                         GHC.Base.maxInt
                                         size of wild3 { GHC.Types.I# y ->
                                  case GHC.Prim.tagToEnum#
                                         @ GHC.Types.Bool
                                         (GHC.Prim.># x y) of wild4 {
                                    GHC.Types.False
                                    -> GHC.Base.liftM
                                         @ (Data.Primitive.ByteArray.MutableByteArray
                                              (Control.Monad.Primitive.PrimState m))
                                         @ (Data.Vector.Primitive.Mutable.MVector
                                              (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                                         @ m
                                         (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                                         (Data.Vector.Primitive.Mutable.$WMVector
                                            @ (Control.Monad.Primitive.PrimState m)
                                            @ GHC.Types.Int
                                            (GHC.Types.I# 0)
                                            wild1)
                                         (case GHC.Num.$fNumInt_$c*
                                                 wild1
                                                 size of wild5 { GHC.Types.I# n# ->
                                          Control.Monad.Primitive.primitive
                                            @ m
                                            $dPrimMonad
                                            @ (Data.Primitive.ByteArray.MutableByteArray
                                                 (Control.Monad.Primitive.PrimState m))
                                            (\ s# :: GHC.Prim.State#
                                                       (Control.Monad.Primitive.PrimState
                                                          m)[OneShot] ->
                                             case GHC.Prim.newByteArray#
                                                    @ (Control.Monad.Primitive.PrimState m)
                                                    n#
                                                    s# of ds1 { (#,#) ipv ipv1 ->
                                             (# ipv,
                                                Data.Primitive.ByteArray.MutableByteArray
                                                  @ (Control.Monad.Primitive.PrimState m)
                                                  ipv1 #) }) })
                                    GHC.Types.True
                                    -> GHC.Base.$
                                         @ [GHC.Types.Char]
                                         @ (m (Data.Vector.Primitive.Mutable.MVector
                                                 (Control.Monad.Primitive.PrimState m)
                                                 GHC.Types.Int))
                                         (GHC.Err.error
                                            @ (m (Data.Vector.Primitive.Mutable.MVector
                                                    (Control.Monad.Primitive.PrimState m)
                                                    GHC.Types.Int)))
                                         (GHC.Base.augment
                                            @ GHC.Types.Char
                                            (\ @ b
                                               c :: GHC.Types.Char -> b -> b[OneShot]
                                               n1 :: b[OneShot] ->
                                             GHC.CString.unpackFoldrCString#
                                               @ b
                                               "Primitive.basicUnsafeNew: length to large: "#
                                               c
                                               n1)
                                            (GHC.Show.$fShowInt_$cshow wild1)) } }
                               GHC.Types.True
                               -> GHC.Base.$
                                    @ [GHC.Types.Char]
                                    @ (m (Data.Vector.Primitive.Mutable.MVector
                                            (Control.Monad.Primitive.PrimState m) GHC.Types.Int))
                                    (GHC.Err.error
                                       @ (m (Data.Vector.Primitive.Mutable.MVector
                                               (Control.Monad.Primitive.PrimState m)
                                               GHC.Types.Int)))
                                    (GHC.Base.augment
                                       @ GHC.Types.Char
                                       (\ @ b
                                          c :: GHC.Types.Char -> b -> b[OneShot]
                                          n1 :: b[OneShot] ->
                                        GHC.CString.unpackFoldrCString#
                                          @ b
                                          "Primitive.basicUnsafeNew: negative length: "#
                                          c
                                          n1)
                                       (GHC.Show.$fShowInt_$cshow wild1)) } })
                            (\ v' :: Data.Vector.Primitive.Mutable.MVector
                                       (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                             GHC.Base.>>
                               @ m
                               $dMonad1
                               @ ()
                               @ (Data.Vector.Primitive.Mutable.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                               (case Data.Vector.Primitive.$fVectorVectora1
                                       @ (Control.Monad.Primitive.PrimState m)
                                       (GHC.Types.I# 0)
                                       n
                                       v' of wild1 { Data.Vector.Primitive.Mutable.MVector dt1 dt2 dt3 ->
                                case as
                                       `cast`
                                     (Trans
                                          (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                    <Control.Monad.Primitive.PrimState m>_N))
                                          (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                               <Control.Monad.Primitive.PrimState
                                                  m>_N)) of wild2 { Data.Vector.Primitive.Mutable.MVector dt4 dt5 dt6 ->
                                let {
                                  sz :: GHC.Types.Int
                                  = Data.Vector.Primitive.$fVectorVectora_$ssizeOf
                                      (GHC.Err.undefined @ GHC.Types.Int)
                                } in
                                Control.Monad.Primitive.primitive
                                  @ m
                                  $dPrimMonad
                                  @ ()
                                  (\ s# :: GHC.Prim.State#
                                             (Control.Monad.Primitive.PrimState m)[OneShot] ->
                                   case Data.Primitive.ByteArray.unI#
                                          (GHC.Num.$fNumInt_$c*
                                             (GHC.Types.I# dt2)
                                             sz) of wild3 { DEFAULT ->
                                   case Data.Primitive.ByteArray.unI#
                                          (GHC.Num.$fNumInt_$c*
                                             (GHC.Types.I# dt1)
                                             sz) of wild4 { DEFAULT ->
                                   case Data.Primitive.ByteArray.unI#
                                          (GHC.Num.$fNumInt_$c*
                                             (GHC.Types.I# dt4)
                                             sz) of wild5 { DEFAULT ->
                                   case GHC.Prim.copyMutableByteArray#
                                          @ (Control.Monad.Primitive.PrimState m)
                                          dt6
                                          wild5
                                          dt3
                                          wild4
                                          wild3
                                          s# of s'# { DEFAULT ->
                                   (# s'#, GHC.Tuple.() #) } } } }) } })
                               (GHC.Base.return
                                  @ m
                                  $dMonad1
                                  @ (Data.Vector.Primitive.Mutable.MVector
                                       (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                                  v'))))
                      (\ as' :: Data.Vector.Unboxed.Base.MVector
                                  (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (Data.Vector.Unboxed.Base.MVector
                              (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                         @ (Data.Vector.Unboxed.Base.MVector
                              (Control.Monad.Primitive.PrimState m)
                              (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8))
                         (GHC.Base.liftM
                            @ (Data.Vector.Primitive.Mutable.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                            @ (Data.Vector.Unboxed.Base.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                            @ m
                            (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                            (\ tpl :: Data.Vector.Primitive.Mutable.MVector
                                        (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                             tpl)
                              `cast`
                            (<Data.Vector.Primitive.Mutable.MVector
                                (Control.Monad.Primitive.PrimState m) GHC.Types.Int>_R
                             ->_R Trans
                                      (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                                <Control.Monad.Primitive.PrimState m>_N))
                                      (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                     <Control.Monad.Primitive.PrimState m>_N))))
                            (let {
                               $dMonad1 :: GHC.Base.Monad m
                               = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                             } in
                             let {
                               n :: GHC.Types.Int
                               = Data.Vector.Primitive.$fVectorVectora2
                                   @ (Control.Monad.Primitive.PrimState m)
                                   bs
                                     `cast`
                                   (Trans
                                        (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                  <Control.Monad.Primitive.PrimState m>_N))
                                        (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                             <Control.Monad.Primitive.PrimState m>_N))
                             } in
                             GHC.Base.>>=
                               @ m
                               $dMonad1
                               @ (Data.Vector.Primitive.Mutable.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                               @ (Data.Vector.Primitive.Mutable.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                               (let {
                                  size :: GHC.Types.Int
                                  = Data.Vector.Primitive.$fVectorVectora_$ssizeOf
                                      (GHC.Err.undefined @ GHC.Types.Int)
                                } in
                                case GHC.Num.$fNumInt_$c+ n eta1 of wild1 { GHC.Types.I# x ->
                                case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.<# x 0) of wild2 {
                                  GHC.Types.False
                                  -> case GHC.Real.$fIntegralInt_$cdiv
                                            GHC.Base.maxInt
                                            size of wild3 { GHC.Types.I# y ->
                                     case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.># x y) of wild4 {
                                       GHC.Types.False
                                       -> GHC.Base.liftM
                                            @ (Data.Primitive.ByteArray.MutableByteArray
                                                 (Control.Monad.Primitive.PrimState m))
                                            @ (Data.Vector.Primitive.Mutable.MVector
                                                 (Control.Monad.Primitive.PrimState m)
                                                 GHC.Types.Int)
                                            @ m
                                            (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                                            (Data.Vector.Primitive.Mutable.$WMVector
                                               @ (Control.Monad.Primitive.PrimState m)
                                               @ GHC.Types.Int
                                               (GHC.Types.I# 0)
                                               wild1)
                                            (case GHC.Num.$fNumInt_$c*
                                                    wild1
                                                    size of wild5 { GHC.Types.I# n# ->
                                             Control.Monad.Primitive.primitive
                                               @ m
                                               $dPrimMonad
                                               @ (Data.Primitive.ByteArray.MutableByteArray
                                                    (Control.Monad.Primitive.PrimState m))
                                               (\ s# :: GHC.Prim.State#
                                                          (Control.Monad.Primitive.PrimState
                                                             m)[OneShot] ->
                                                case GHC.Prim.newByteArray#
                                                       @ (Control.Monad.Primitive.PrimState m)
                                                       n#
                                                       s# of ds1 { (#,#) ipv ipv1 ->
                                                (# ipv,
                                                   Data.Primitive.ByteArray.MutableByteArray
                                                     @ (Control.Monad.Primitive.PrimState m)
                                                     ipv1 #) }) })
                                       GHC.Types.True
                                       -> GHC.Base.$
                                            @ [GHC.Types.Char]
                                            @ (m (Data.Vector.Primitive.Mutable.MVector
                                                    (Control.Monad.Primitive.PrimState m)
                                                    GHC.Types.Int))
                                            (GHC.Err.error
                                               @ (m (Data.Vector.Primitive.Mutable.MVector
                                                       (Control.Monad.Primitive.PrimState m)
                                                       GHC.Types.Int)))
                                            (GHC.Base.augment
                                               @ GHC.Types.Char
                                               (\ @ b
                                                  c :: GHC.Types.Char -> b -> b[OneShot]
                                                  n1 :: b[OneShot] ->
                                                GHC.CString.unpackFoldrCString#
                                                  @ b
                                                  "Primitive.basicUnsafeNew: length to large: "#
                                                  c
                                                  n1)
                                               (GHC.Show.$fShowInt_$cshow wild1)) } }
                                  GHC.Types.True
                                  -> GHC.Base.$
                                       @ [GHC.Types.Char]
                                       @ (m (Data.Vector.Primitive.Mutable.MVector
                                               (Control.Monad.Primitive.PrimState m) GHC.Types.Int))
                                       (GHC.Err.error
                                          @ (m (Data.Vector.Primitive.Mutable.MVector
                                                  (Control.Monad.Primitive.PrimState m)
                                                  GHC.Types.Int)))
                                       (GHC.Base.augment
                                          @ GHC.Types.Char
                                          (\ @ b
                                             c :: GHC.Types.Char -> b -> b[OneShot]
                                             n1 :: b[OneShot] ->
                                           GHC.CString.unpackFoldrCString#
                                             @ b
                                             "Primitive.basicUnsafeNew: negative length: "#
                                             c
                                             n1)
                                          (GHC.Show.$fShowInt_$cshow wild1)) } })
                               (\ v' :: Data.Vector.Primitive.Mutable.MVector
                                          (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                                GHC.Base.>>
                                  @ m
                                  $dMonad1
                                  @ ()
                                  @ (Data.Vector.Primitive.Mutable.MVector
                                       (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                                  (case Data.Vector.Primitive.$fVectorVectora1
                                          @ (Control.Monad.Primitive.PrimState m)
                                          (GHC.Types.I# 0)
                                          n
                                          v' of wild1 { Data.Vector.Primitive.Mutable.MVector dt1 dt2 dt3 ->
                                   case bs
                                          `cast`
                                        (Trans
                                             (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                       <Control.Monad.Primitive.PrimState m>_N))
                                             (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                                  <Control.Monad.Primitive.PrimState
                                                     m>_N)) of wild2 { Data.Vector.Primitive.Mutable.MVector dt4 dt5 dt6 ->
                                   let {
                                     sz :: GHC.Types.Int
                                     = Data.Vector.Primitive.$fVectorVectora_$ssizeOf
                                         (GHC.Err.undefined @ GHC.Types.Int)
                                   } in
                                   Control.Monad.Primitive.primitive
                                     @ m
                                     $dPrimMonad
                                     @ ()
                                     (\ s# :: GHC.Prim.State#
                                                (Control.Monad.Primitive.PrimState m)[OneShot] ->
                                      case Data.Primitive.ByteArray.unI#
                                             (GHC.Num.$fNumInt_$c*
                                                (GHC.Types.I# dt2)
                                                sz) of wild3 { DEFAULT ->
                                      case Data.Primitive.ByteArray.unI#
                                             (GHC.Num.$fNumInt_$c*
                                                (GHC.Types.I# dt1)
                                                sz) of wild4 { DEFAULT ->
                                      case Data.Primitive.ByteArray.unI#
                                             (GHC.Num.$fNumInt_$c*
                                                (GHC.Types.I# dt4)
                                                sz) of wild5 { DEFAULT ->
                                      case GHC.Prim.copyMutableByteArray#
                                             @ (Control.Monad.Primitive.PrimState m)
                                             dt6
                                             wild5
                                             dt3
                                             wild4
                                             wild3
                                             s# of s'# { DEFAULT ->
                                      (# s'#, GHC.Tuple.() #) } } } }) } })
                                  (GHC.Base.return
                                     @ m
                                     $dMonad1
                                     @ (Data.Vector.Primitive.Mutable.MVector
                                          (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                                     v'))))
                         (\ bs' :: Data.Vector.Unboxed.Base.MVector
                                     (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                          GHC.Base.>>=
                            @ m
                            $dMonad
                            @ (Data.Vector.Unboxed.Base.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                            @ (Data.Vector.Unboxed.Base.MVector
                                 (Control.Monad.Primitive.PrimState m)
                                 (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8))
                            (GHC.Base.liftM
                               @ (Data.Vector.Primitive.Mutable.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                               @ (Data.Vector.Unboxed.Base.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                               @ m
                               (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                               (\ tpl :: Data.Vector.Primitive.Mutable.MVector
                                           (Control.Monad.Primitive.PrimState m) GHC.Word.Word8 ->
                                tpl)
                                 `cast`
                               (<Data.Vector.Primitive.Mutable.MVector
                                   (Control.Monad.Primitive.PrimState m) GHC.Word.Word8>_R
                                ->_R Trans
                                         (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                                   <Control.Monad.Primitive.PrimState m>_N))
                                         (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                                        <Control.Monad.Primitive.PrimState m>_N))))
                               (let {
                                  $dMonad1 :: GHC.Base.Monad m
                                  = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                                } in
                                let {
                                  n :: GHC.Types.Int
                                  = Data.Vector.Unboxed.Base.$fMVectorMVectorBool2
                                      @ (Control.Monad.Primitive.PrimState m)
                                      cs
                                        `cast`
                                      (Trans
                                           (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                                     <Control.Monad.Primitive.PrimState m>_N))
                                           (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                                <Control.Monad.Primitive.PrimState m>_N))
                                } in
                                GHC.Base.>>=
                                  @ m
                                  $dMonad1
                                  @ (Data.Vector.Primitive.Mutable.MVector
                                       (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                                  @ (Data.Vector.Primitive.Mutable.MVector
                                       (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                                  (let {
                                     size :: GHC.Types.Int
                                     = Data.Vector.Unboxed.Base.$fMVectorMVectorBool_$ssizeOf
                                         (GHC.Err.undefined @ GHC.Word.Word8)
                                   } in
                                   case GHC.Num.$fNumInt_$c+ n eta1 of wild1 { GHC.Types.I# x ->
                                   case GHC.Prim.tagToEnum#
                                          @ GHC.Types.Bool
                                          (GHC.Prim.<# x 0) of wild2 {
                                     GHC.Types.False
                                     -> case GHC.Real.$fIntegralInt_$cdiv
                                               GHC.Base.maxInt
                                               size of wild3 { GHC.Types.I# y ->
                                        case GHC.Prim.tagToEnum#
                                               @ GHC.Types.Bool
                                               (GHC.Prim.># x y) of wild4 {
                                          GHC.Types.False
                                          -> GHC.Base.liftM
                                               @ (Data.Primitive.ByteArray.MutableByteArray
                                                    (Control.Monad.Primitive.PrimState m))
                                               @ (Data.Vector.Primitive.Mutable.MVector
                                                    (Control.Monad.Primitive.PrimState m)
                                                    GHC.Word.Word8)
                                               @ m
                                               (Control.Monad.Primitive.$p1PrimMonad
                                                  @ m
                                                  $dPrimMonad)
                                               (Data.Vector.Primitive.Mutable.$WMVector
                                                  @ (Control.Monad.Primitive.PrimState m)
                                                  @ GHC.Word.Word8
                                                  (GHC.Types.I# 0)
                                                  wild1)
                                               (case GHC.Num.$fNumInt_$c*
                                                       wild1
                                                       size of wild5 { GHC.Types.I# n# ->
                                                Control.Monad.Primitive.primitive
                                                  @ m
                                                  $dPrimMonad
                                                  @ (Data.Primitive.ByteArray.MutableByteArray
                                                       (Control.Monad.Primitive.PrimState m))
                                                  (\ s# :: GHC.Prim.State#
                                                             (Control.Monad.Primitive.PrimState
                                                                m)[OneShot] ->
                                                   case GHC.Prim.newByteArray#
                                                          @ (Control.Monad.Primitive.PrimState m)
                                                          n#
                                                          s# of ds1 { (#,#) ipv ipv1 ->
                                                   (# ipv,
                                                      Data.Primitive.ByteArray.MutableByteArray
                                                        @ (Control.Monad.Primitive.PrimState m)
                                                        ipv1 #) }) })
                                          GHC.Types.True
                                          -> GHC.Base.$
                                               @ [GHC.Types.Char]
                                               @ (m (Data.Vector.Primitive.Mutable.MVector
                                                       (Control.Monad.Primitive.PrimState m)
                                                       GHC.Word.Word8))
                                               (GHC.Err.error
                                                  @ (m (Data.Vector.Primitive.Mutable.MVector
                                                          (Control.Monad.Primitive.PrimState m)
                                                          GHC.Word.Word8)))
                                               (GHC.Base.augment
                                                  @ GHC.Types.Char
                                                  (\ @ b
                                                     c :: GHC.Types.Char -> b -> b[OneShot]
                                                     n1 :: b[OneShot] ->
                                                   GHC.CString.unpackFoldrCString#
                                                     @ b
                                                     "Primitive.basicUnsafeNew: length to large: "#
                                                     c
                                                     n1)
                                                  (GHC.Show.$fShowInt_$cshow wild1)) } }
                                     GHC.Types.True
                                     -> GHC.Base.$
                                          @ [GHC.Types.Char]
                                          @ (m (Data.Vector.Primitive.Mutable.MVector
                                                  (Control.Monad.Primitive.PrimState m)
                                                  GHC.Word.Word8))
                                          (GHC.Err.error
                                             @ (m (Data.Vector.Primitive.Mutable.MVector
                                                     (Control.Monad.Primitive.PrimState m)
                                                     GHC.Word.Word8)))
                                          (GHC.Base.augment
                                             @ GHC.Types.Char
                                             (\ @ b
                                                c :: GHC.Types.Char -> b -> b[OneShot]
                                                n1 :: b[OneShot] ->
                                              GHC.CString.unpackFoldrCString#
                                                @ b
                                                "Primitive.basicUnsafeNew: negative length: "#
                                                c
                                                n1)
                                             (GHC.Show.$fShowInt_$cshow wild1)) } })
                                  (\ v' :: Data.Vector.Primitive.Mutable.MVector
                                             (Control.Monad.Primitive.PrimState m) GHC.Word.Word8 ->
                                   GHC.Base.>>
                                     @ m
                                     $dMonad1
                                     @ ()
                                     @ (Data.Vector.Primitive.Mutable.MVector
                                          (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                                     (case Data.Vector.Unboxed.Base.$fMVectorMVectorBool1
                                             @ (Control.Monad.Primitive.PrimState m)
                                             (GHC.Types.I# 0)
                                             n
                                             v' of wild1 { Data.Vector.Primitive.Mutable.MVector dt1 dt2 dt3 ->
                                      case cs
                                             `cast`
                                           (Trans
                                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                                          <Control.Monad.Primitive.PrimState m>_N))
                                                (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                                     <Control.Monad.Primitive.PrimState
                                                        m>_N)) of wild2 { Data.Vector.Primitive.Mutable.MVector dt4 dt5 dt6 ->
                                      let {
                                        sz :: GHC.Types.Int
                                        = Data.Vector.Unboxed.Base.$fMVectorMVectorBool_$ssizeOf
                                            (GHC.Err.undefined @ GHC.Word.Word8)
                                      } in
                                      Control.Monad.Primitive.primitive
                                        @ m
                                        $dPrimMonad
                                        @ ()
                                        (\ s# :: GHC.Prim.State#
                                                   (Control.Monad.Primitive.PrimState m)[OneShot] ->
                                         case Data.Primitive.ByteArray.unI#
                                                (GHC.Num.$fNumInt_$c*
                                                   (GHC.Types.I# dt2)
                                                   sz) of wild3 { DEFAULT ->
                                         case Data.Primitive.ByteArray.unI#
                                                (GHC.Num.$fNumInt_$c*
                                                   (GHC.Types.I# dt1)
                                                   sz) of wild4 { DEFAULT ->
                                         case Data.Primitive.ByteArray.unI#
                                                (GHC.Num.$fNumInt_$c*
                                                   (GHC.Types.I# dt4)
                                                   sz) of wild5 { DEFAULT ->
                                         case GHC.Prim.copyMutableByteArray#
                                                @ (Control.Monad.Primitive.PrimState m)
                                                dt6
                                                wild5
                                                dt3
                                                wild4
                                                wild3
                                                s# of s'# { DEFAULT ->
                                         (# s'#, GHC.Tuple.() #) } } } }) } })
                                     (GHC.Base.return
                                        @ m
                                        $dMonad1
                                        @ (Data.Vector.Primitive.Mutable.MVector
                                             (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                                        v'))))
                            (\ cs' :: Data.Vector.Unboxed.Base.MVector
                                        (Control.Monad.Primitive.PrimState m) GHC.Word.Word8 ->
                             GHC.Base.$
                               @ (Data.Vector.Unboxed.Base.MVector
                                    (Control.Monad.Primitive.PrimState m)
                                    (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8))
                               @ (m (Data.Vector.Unboxed.Base.MVector
                                       (Control.Monad.Primitive.PrimState m)
                                       (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8)))
                               (GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (Data.Vector.Unboxed.Base.MVector
                                       (Control.Monad.Primitive.PrimState m)
                                       (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8)))
                               (case GHC.Num.$fNumInt_$c+ eta1 n_ of dt1 { GHC.Types.I# dt2 ->
                                case as'
                                       `cast`
                                     (Trans
                                          (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                    <Control.Monad.Primitive.PrimState m>_N))
                                          (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                               <Control.Monad.Primitive.PrimState
                                                  m>_N)) of nt { Data.Vector.Primitive.Mutable.MVector ipv ipv1 ipv2 ->
                                case bs'
                                       `cast`
                                     (Trans
                                          (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                    <Control.Monad.Primitive.PrimState m>_N))
                                          (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                               <Control.Monad.Primitive.PrimState
                                                  m>_N)) of nt1 { Data.Vector.Primitive.Mutable.MVector ipv3 ipv4 ipv5 ->
                                case cs'
                                       `cast`
                                     (Trans
                                          (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                                    <Control.Monad.Primitive.PrimState m>_N))
                                          (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                               <Control.Monad.Primitive.PrimState
                                                  m>_N)) of nt2 { Data.Vector.Primitive.Mutable.MVector ipv6 ipv7 ipv8 ->
                                (Data.Vector.Unboxed.Base.MV_3
                                   @ (Control.Monad.Primitive.PrimState m)
                                   @ GHC.Types.Int
                                   @ GHC.Types.Int
                                   @ GHC.Word.Word8
                                   dt2
                                   nt
                                     `cast`
                                   (Trans
                                        (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                                  <Control.Monad.Primitive.PrimState m>_N))
                                        (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                       <Control.Monad.Primitive.PrimState m>_N))))
                                   nt1
                                     `cast`
                                   (Trans
                                        (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                                  <Control.Monad.Primitive.PrimState m>_N))
                                        (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                       <Control.Monad.Primitive.PrimState m>_N))))
                                   nt2
                                     `cast`
                                   (Trans
                                        (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                                  <Control.Monad.Primitive.PrimState m>_N))
                                        (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                                       <Control.Monad.Primitive.PrimState m>_N)))))
                                  `cast`
                                (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,,)[0]
                                               <Control.Monad.Primitive.PrimState m>_N
                                               <GHC.Types.Int>_N
                                               <GHC.Types.Int>_N
                                               <GHC.Word.Word8>_N))) } } } })))) })) -}
7974ea60cb767d2cccb374fcf473a0ab
  $fMVectorMVectorPromotion_$cbasicUnsafeMove ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Unboxed.Base.MVector
      (Control.Monad.Primitive.PrimState m) MoveTypes.Promotion
    -> Data.Vector.Unboxed.Base.MVector
         (Control.Monad.Primitive.PrimState m) MoveTypes.Promotion
    -> m ()
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(SL),U(1*U,C(U))><S(LSSS),1*U(A,U(U,U,U),U(U,U,U),U(U,U,U))><S,1*U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   ds :: Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m) MoveTypes.Promotion
                   ds1 :: Data.Vector.Unboxed.Base.MVector
                            (Control.Monad.Primitive.PrimState m) MoveTypes.Promotion ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                 } in
                 case ds
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:MVectorsPromotion[0]
                                     <Control.Monad.Primitive.PrimState m>_N))
                           (Trans
                                (MoveTypes.NTCo:R:MVectorsPromotion[0]
                                     <Control.Monad.Primitive.PrimState m>_N)
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,,)[0]
                                          <Control.Monad.Primitive.PrimState m>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Word.Word8>_N)))) of wild { Data.Vector.Unboxed.Base.MV_3 dt as1 bs1 cs1 ->
                 case ds1
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:MVectorsPromotion[0]
                                     <Control.Monad.Primitive.PrimState m>_N))
                           (Trans
                                (MoveTypes.NTCo:R:MVectorsPromotion[0]
                                     <Control.Monad.Primitive.PrimState m>_N)
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,,)[0]
                                          <Control.Monad.Primitive.PrimState m>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Word.Word8>_N)))) of wild1 { Data.Vector.Unboxed.Base.MV_3 dt1 as2 bs2 cs2 ->
                 GHC.Base.>>
                   @ m
                   $dMonad
                   @ ()
                   @ ()
                   (Data.Vector.Unboxed.Base.$fMVectorMVectorInt_$cbasicUnsafeMove
                      @ m
                      $dPrimMonad
                      as1
                      as2)
                   (GHC.Base.>>
                      @ m
                      $dMonad
                      @ ()
                      @ ()
                      (Data.Vector.Unboxed.Base.$fMVectorMVectorInt_$cbasicUnsafeMove
                         @ m
                         $dPrimMonad
                         bs1
                         bs2)
                      (Data.Vector.Unboxed.Base.$fMVectorMVectorWord8_$cbasicUnsafeMove
                         @ m
                         $dPrimMonad
                         cs1
                         cs2)) } }) -}
7974ea60cb767d2cccb374fcf473a0ab
  $fMVectorMVectorPromotion_$cbasicUnsafeNew ::
    Control.Monad.Primitive.PrimMonad m =>
    GHC.Types.Int
    -> m (Data.Vector.Unboxed.Base.MVector
            (Control.Monad.Primitive.PrimState m) MoveTypes.Promotion)
  {- Arity: 2, Strictness: <S(SL),U(U,C(U))><L,U(U)>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   eta :: GHC.Types.Int ->
                 GHC.Base.liftM
                   @ (Data.Vector.Unboxed.Base.MVector
                        (Control.Monad.Primitive.PrimState m)
                        (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8))
                   @ (Data.Vector.Unboxed.Base.MVector
                        (Control.Monad.Primitive.PrimState m) MoveTypes.Promotion)
                   @ m
                   (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                   (\ tpl :: Data.Vector.Unboxed.Base.MVector
                               (Control.Monad.Primitive.PrimState m)
                               (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8) ->
                    tpl)
                     `cast`
                   (<Data.Vector.Unboxed.Base.MVector
                       (Control.Monad.Primitive.PrimState m)
                       (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8)>_R
                    ->_R Trans
                             (Sym (MoveTypes.NTCo:R:MVectorsPromotion[0]
                                       <Control.Monad.Primitive.PrimState m>_N))
                             (Sub (Sym (MoveTypes.TFCo:R:MVectorsPromotion[0]
                                            <Control.Monad.Primitive.PrimState m>_N))))
                   (let {
                      $dMonad :: GHC.Base.Monad m
                      = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                      @ (Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m)
                           (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8))
                      (GHC.Base.liftM
                         @ (Data.Vector.Primitive.Mutable.MVector
                              (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                         @ (Data.Vector.Unboxed.Base.MVector
                              (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                         @ m
                         (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                         (\ tpl :: Data.Vector.Primitive.Mutable.MVector
                                     (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                          tpl)
                           `cast`
                         (<Data.Vector.Primitive.Mutable.MVector
                             (Control.Monad.Primitive.PrimState m) GHC.Types.Int>_R
                          ->_R Trans
                                   (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                             <Control.Monad.Primitive.PrimState m>_N))
                                   (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                  <Control.Monad.Primitive.PrimState m>_N))))
                         (let {
                            size :: GHC.Types.Int
                            = Data.Vector.Primitive.$fVectorVectora_$ssizeOf
                                (GHC.Err.undefined @ GHC.Types.Int)
                          } in
                          case eta of wild { GHC.Types.I# x ->
                          case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.<# x 0) of wild1 {
                            GHC.Types.False
                            -> case GHC.Real.$fIntegralInt_$cdiv
                                      GHC.Base.maxInt
                                      size of wild2 { GHC.Types.I# y ->
                               case GHC.Prim.tagToEnum#
                                      @ GHC.Types.Bool
                                      (GHC.Prim.># x y) of wild3 {
                                 GHC.Types.False
                                 -> GHC.Base.liftM
                                      @ (Data.Primitive.ByteArray.MutableByteArray
                                           (Control.Monad.Primitive.PrimState m))
                                      @ (Data.Vector.Primitive.Mutable.MVector
                                           (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                                      @ m
                                      (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                                      (Data.Vector.Primitive.Mutable.$WMVector
                                         @ (Control.Monad.Primitive.PrimState m)
                                         @ GHC.Types.Int
                                         (GHC.Types.I# 0)
                                         wild)
                                      (case GHC.Num.$fNumInt_$c*
                                              wild
                                              size of wild4 { GHC.Types.I# n# ->
                                       Control.Monad.Primitive.primitive
                                         @ m
                                         $dPrimMonad
                                         @ (Data.Primitive.ByteArray.MutableByteArray
                                              (Control.Monad.Primitive.PrimState m))
                                         (\ s# :: GHC.Prim.State#
                                                    (Control.Monad.Primitive.PrimState
                                                       m)[OneShot] ->
                                          case GHC.Prim.newByteArray#
                                                 @ (Control.Monad.Primitive.PrimState m)
                                                 n#
                                                 s# of ds1 { (#,#) ipv ipv1 ->
                                          (# ipv,
                                             Data.Primitive.ByteArray.MutableByteArray
                                               @ (Control.Monad.Primitive.PrimState m)
                                               ipv1 #) }) })
                                 GHC.Types.True
                                 -> GHC.Base.$
                                      @ [GHC.Types.Char]
                                      @ (m (Data.Vector.Primitive.Mutable.MVector
                                              (Control.Monad.Primitive.PrimState m) GHC.Types.Int))
                                      (GHC.Err.error
                                         @ (m (Data.Vector.Primitive.Mutable.MVector
                                                 (Control.Monad.Primitive.PrimState m)
                                                 GHC.Types.Int)))
                                      (GHC.Base.augment
                                         @ GHC.Types.Char
                                         (\ @ b
                                            c :: GHC.Types.Char -> b -> b[OneShot]
                                            n :: b[OneShot] ->
                                          GHC.CString.unpackFoldrCString#
                                            @ b
                                            "Primitive.basicUnsafeNew: length to large: "#
                                            c
                                            n)
                                         (GHC.Show.$fShowInt_$cshow wild)) } }
                            GHC.Types.True
                            -> GHC.Base.$
                                 @ [GHC.Types.Char]
                                 @ (m (Data.Vector.Primitive.Mutable.MVector
                                         (Control.Monad.Primitive.PrimState m) GHC.Types.Int))
                                 (GHC.Err.error
                                    @ (m (Data.Vector.Primitive.Mutable.MVector
                                            (Control.Monad.Primitive.PrimState m) GHC.Types.Int)))
                                 (GHC.Base.augment
                                    @ GHC.Types.Char
                                    (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                                     GHC.CString.unpackFoldrCString#
                                       @ b
                                       "Primitive.basicUnsafeNew: negative length: "#
                                       c
                                       n)
                                    (GHC.Show.$fShowInt_$cshow wild)) } }))
                      (\ as :: Data.Vector.Unboxed.Base.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (Data.Vector.Unboxed.Base.MVector
                              (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                         @ (Data.Vector.Unboxed.Base.MVector
                              (Control.Monad.Primitive.PrimState m)
                              (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8))
                         (GHC.Base.liftM
                            @ (Data.Vector.Primitive.Mutable.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                            @ (Data.Vector.Unboxed.Base.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                            @ m
                            (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                            (\ tpl :: Data.Vector.Primitive.Mutable.MVector
                                        (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                             tpl)
                              `cast`
                            (<Data.Vector.Primitive.Mutable.MVector
                                (Control.Monad.Primitive.PrimState m) GHC.Types.Int>_R
                             ->_R Trans
                                      (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                                <Control.Monad.Primitive.PrimState m>_N))
                                      (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                     <Control.Monad.Primitive.PrimState m>_N))))
                            (let {
                               size :: GHC.Types.Int
                               = Data.Vector.Primitive.$fVectorVectora_$ssizeOf
                                   (GHC.Err.undefined @ GHC.Types.Int)
                             } in
                             case eta of wild { GHC.Types.I# x ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.<# x 0) of wild1 {
                               GHC.Types.False
                               -> case GHC.Real.$fIntegralInt_$cdiv
                                         GHC.Base.maxInt
                                         size of wild2 { GHC.Types.I# y ->
                                  case GHC.Prim.tagToEnum#
                                         @ GHC.Types.Bool
                                         (GHC.Prim.># x y) of wild3 {
                                    GHC.Types.False
                                    -> GHC.Base.liftM
                                         @ (Data.Primitive.ByteArray.MutableByteArray
                                              (Control.Monad.Primitive.PrimState m))
                                         @ (Data.Vector.Primitive.Mutable.MVector
                                              (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                                         @ m
                                         (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                                         (Data.Vector.Primitive.Mutable.$WMVector
                                            @ (Control.Monad.Primitive.PrimState m)
                                            @ GHC.Types.Int
                                            (GHC.Types.I# 0)
                                            wild)
                                         (case GHC.Num.$fNumInt_$c*
                                                 wild
                                                 size of wild4 { GHC.Types.I# n# ->
                                          Control.Monad.Primitive.primitive
                                            @ m
                                            $dPrimMonad
                                            @ (Data.Primitive.ByteArray.MutableByteArray
                                                 (Control.Monad.Primitive.PrimState m))
                                            (\ s# :: GHC.Prim.State#
                                                       (Control.Monad.Primitive.PrimState
                                                          m)[OneShot] ->
                                             case GHC.Prim.newByteArray#
                                                    @ (Control.Monad.Primitive.PrimState m)
                                                    n#
                                                    s# of ds1 { (#,#) ipv ipv1 ->
                                             (# ipv,
                                                Data.Primitive.ByteArray.MutableByteArray
                                                  @ (Control.Monad.Primitive.PrimState m)
                                                  ipv1 #) }) })
                                    GHC.Types.True
                                    -> GHC.Base.$
                                         @ [GHC.Types.Char]
                                         @ (m (Data.Vector.Primitive.Mutable.MVector
                                                 (Control.Monad.Primitive.PrimState m)
                                                 GHC.Types.Int))
                                         (GHC.Err.error
                                            @ (m (Data.Vector.Primitive.Mutable.MVector
                                                    (Control.Monad.Primitive.PrimState m)
                                                    GHC.Types.Int)))
                                         (GHC.Base.augment
                                            @ GHC.Types.Char
                                            (\ @ b
                                               c :: GHC.Types.Char -> b -> b[OneShot]
                                               n :: b[OneShot] ->
                                             GHC.CString.unpackFoldrCString#
                                               @ b
                                               "Primitive.basicUnsafeNew: length to large: "#
                                               c
                                               n)
                                            (GHC.Show.$fShowInt_$cshow wild)) } }
                               GHC.Types.True
                               -> GHC.Base.$
                                    @ [GHC.Types.Char]
                                    @ (m (Data.Vector.Primitive.Mutable.MVector
                                            (Control.Monad.Primitive.PrimState m) GHC.Types.Int))
                                    (GHC.Err.error
                                       @ (m (Data.Vector.Primitive.Mutable.MVector
                                               (Control.Monad.Primitive.PrimState m)
                                               GHC.Types.Int)))
                                    (GHC.Base.augment
                                       @ GHC.Types.Char
                                       (\ @ b
                                          c :: GHC.Types.Char -> b -> b[OneShot]
                                          n :: b[OneShot] ->
                                        GHC.CString.unpackFoldrCString#
                                          @ b
                                          "Primitive.basicUnsafeNew: negative length: "#
                                          c
                                          n)
                                       (GHC.Show.$fShowInt_$cshow wild)) } }))
                         (\ bs :: Data.Vector.Unboxed.Base.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                          GHC.Base.>>=
                            @ m
                            $dMonad
                            @ (Data.Vector.Unboxed.Base.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                            @ (Data.Vector.Unboxed.Base.MVector
                                 (Control.Monad.Primitive.PrimState m)
                                 (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8))
                            (GHC.Base.liftM
                               @ (Data.Vector.Primitive.Mutable.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                               @ (Data.Vector.Unboxed.Base.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                               @ m
                               (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                               (\ tpl :: Data.Vector.Primitive.Mutable.MVector
                                           (Control.Monad.Primitive.PrimState m) GHC.Word.Word8 ->
                                tpl)
                                 `cast`
                               (<Data.Vector.Primitive.Mutable.MVector
                                   (Control.Monad.Primitive.PrimState m) GHC.Word.Word8>_R
                                ->_R Trans
                                         (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                                   <Control.Monad.Primitive.PrimState m>_N))
                                         (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                                        <Control.Monad.Primitive.PrimState m>_N))))
                               (let {
                                  size :: GHC.Types.Int
                                  = Data.Vector.Unboxed.Base.$fMVectorMVectorBool_$ssizeOf
                                      (GHC.Err.undefined @ GHC.Word.Word8)
                                } in
                                case eta of wild { GHC.Types.I# x ->
                                case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.<# x 0) of wild1 {
                                  GHC.Types.False
                                  -> case GHC.Real.$fIntegralInt_$cdiv
                                            GHC.Base.maxInt
                                            size of wild2 { GHC.Types.I# y ->
                                     case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.># x y) of wild3 {
                                       GHC.Types.False
                                       -> GHC.Base.liftM
                                            @ (Data.Primitive.ByteArray.MutableByteArray
                                                 (Control.Monad.Primitive.PrimState m))
                                            @ (Data.Vector.Primitive.Mutable.MVector
                                                 (Control.Monad.Primitive.PrimState m)
                                                 GHC.Word.Word8)
                                            @ m
                                            (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                                            (Data.Vector.Primitive.Mutable.$WMVector
                                               @ (Control.Monad.Primitive.PrimState m)
                                               @ GHC.Word.Word8
                                               (GHC.Types.I# 0)
                                               wild)
                                            (case GHC.Num.$fNumInt_$c*
                                                    wild
                                                    size of wild4 { GHC.Types.I# n# ->
                                             Control.Monad.Primitive.primitive
                                               @ m
                                               $dPrimMonad
                                               @ (Data.Primitive.ByteArray.MutableByteArray
                                                    (Control.Monad.Primitive.PrimState m))
                                               (\ s# :: GHC.Prim.State#
                                                          (Control.Monad.Primitive.PrimState
                                                             m)[OneShot] ->
                                                case GHC.Prim.newByteArray#
                                                       @ (Control.Monad.Primitive.PrimState m)
                                                       n#
                                                       s# of ds1 { (#,#) ipv ipv1 ->
                                                (# ipv,
                                                   Data.Primitive.ByteArray.MutableByteArray
                                                     @ (Control.Monad.Primitive.PrimState m)
                                                     ipv1 #) }) })
                                       GHC.Types.True
                                       -> GHC.Base.$
                                            @ [GHC.Types.Char]
                                            @ (m (Data.Vector.Primitive.Mutable.MVector
                                                    (Control.Monad.Primitive.PrimState m)
                                                    GHC.Word.Word8))
                                            (GHC.Err.error
                                               @ (m (Data.Vector.Primitive.Mutable.MVector
                                                       (Control.Monad.Primitive.PrimState m)
                                                       GHC.Word.Word8)))
                                            (GHC.Base.augment
                                               @ GHC.Types.Char
                                               (\ @ b
                                                  c :: GHC.Types.Char -> b -> b[OneShot]
                                                  n :: b[OneShot] ->
                                                GHC.CString.unpackFoldrCString#
                                                  @ b
                                                  "Primitive.basicUnsafeNew: length to large: "#
                                                  c
                                                  n)
                                               (GHC.Show.$fShowInt_$cshow wild)) } }
                                  GHC.Types.True
                                  -> GHC.Base.$
                                       @ [GHC.Types.Char]
                                       @ (m (Data.Vector.Primitive.Mutable.MVector
                                               (Control.Monad.Primitive.PrimState m)
                                               GHC.Word.Word8))
                                       (GHC.Err.error
                                          @ (m (Data.Vector.Primitive.Mutable.MVector
                                                  (Control.Monad.Primitive.PrimState m)
                                                  GHC.Word.Word8)))
                                       (GHC.Base.augment
                                          @ GHC.Types.Char
                                          (\ @ b
                                             c :: GHC.Types.Char -> b -> b[OneShot]
                                             n :: b[OneShot] ->
                                           GHC.CString.unpackFoldrCString#
                                             @ b
                                             "Primitive.basicUnsafeNew: negative length: "#
                                             c
                                             n)
                                          (GHC.Show.$fShowInt_$cshow wild)) } }))
                            (\ cs :: Data.Vector.Unboxed.Base.MVector
                                       (Control.Monad.Primitive.PrimState m) GHC.Word.Word8 ->
                             GHC.Base.$
                               @ (Data.Vector.Unboxed.Base.MVector
                                    (Control.Monad.Primitive.PrimState m)
                                    (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8))
                               @ (m (Data.Vector.Unboxed.Base.MVector
                                       (Control.Monad.Primitive.PrimState m)
                                       (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8)))
                               (GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (Data.Vector.Unboxed.Base.MVector
                                       (Control.Monad.Primitive.PrimState m)
                                       (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8)))
                               (Data.Vector.Unboxed.Base.$WMV_3
                                  @ (Control.Monad.Primitive.PrimState m)
                                  @ GHC.Types.Int
                                  @ GHC.Types.Int
                                  @ GHC.Word.Word8
                                  eta
                                  as
                                  bs
                                  cs)))))) -}
7974ea60cb767d2cccb374fcf473a0ab
  $fMVectorMVectorPromotion_$cbasicUnsafeRead ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Unboxed.Base.MVector
      (Control.Monad.Primitive.PrimState m) MoveTypes.Promotion
    -> GHC.Types.Int -> m MoveTypes.Promotion
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(SL),U(U,C(U))><L,1*U(A,U(U,A,U),U(U,A,U),U(U,A,U))><L,U(U)>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   eta :: Data.Vector.Unboxed.Base.MVector
                            (Control.Monad.Primitive.PrimState m) MoveTypes.Promotion
                   eta1 :: GHC.Types.Int ->
                 GHC.Base.liftM
                   @ (Index.Index, Index.Index, GHC.Word.Word8)
                   @ MoveTypes.Promotion
                   @ m
                   (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                   (\ ds :: (Index.Index, Index.Index, GHC.Word.Word8) ->
                    case ds of wild { (,,) f t w ->
                    case f of dt { GHC.Types.I# dt1 ->
                    case t of dt2 { GHC.Types.I# dt3 ->
                    case w of dt4 { GHC.Word.W8# dt5 ->
                    MoveTypes.Promotion dt1 dt3 dt5 } } } })
                   (let {
                      $dMonad :: GHC.Base.Monad m
                      = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                    } in
                    case eta
                           `cast`
                         (Trans
                              (Sub (MoveTypes.TFCo:R:MVectorsPromotion[0]
                                        <Control.Monad.Primitive.PrimState m>_N))
                              (Trans
                                   (MoveTypes.NTCo:R:MVectorsPromotion[0]
                                        <Control.Monad.Primitive.PrimState m>_N)
                                   (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,,)[0]
                                             <Control.Monad.Primitive.PrimState m>_N
                                             <GHC.Types.Int>_N
                                             <GHC.Types.Int>_N
                                             <GHC.Word.Word8>_N)))) of wild { Data.Vector.Unboxed.Base.MV_3 dt as bs cs ->
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ GHC.Types.Int
                      @ (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8)
                      (case as
                              `cast`
                            (Trans
                                 (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                           <Control.Monad.Primitive.PrimState m>_N))
                                 (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                      <Control.Monad.Primitive.PrimState
                                         m>_N)) of wild1 { Data.Vector.Primitive.Mutable.MVector dt1 dt2 dt3 ->
                       case GHC.Num.$fNumInt_$c+
                              (GHC.Types.I# dt1)
                              eta1 of wild2 { GHC.Types.I# i# ->
                       Control.Monad.Primitive.primitive
                         @ m
                         $dPrimMonad
                         @ GHC.Types.Int
                         (Data.Primitive.Types.$fPrimInt_$creadByteArray#
                            @ (Control.Monad.Primitive.PrimState m)
                            dt3
                            i#) } })
                      (\ a21 :: GHC.Types.Int ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ GHC.Types.Int
                         @ (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8)
                         (case bs
                                 `cast`
                               (Trans
                                    (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                              <Control.Monad.Primitive.PrimState m>_N))
                                    (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                         <Control.Monad.Primitive.PrimState
                                            m>_N)) of wild1 { Data.Vector.Primitive.Mutable.MVector dt1 dt2 dt3 ->
                          case GHC.Num.$fNumInt_$c+
                                 (GHC.Types.I# dt1)
                                 eta1 of wild2 { GHC.Types.I# i# ->
                          Control.Monad.Primitive.primitive
                            @ m
                            $dPrimMonad
                            @ GHC.Types.Int
                            (Data.Primitive.Types.$fPrimInt_$creadByteArray#
                               @ (Control.Monad.Primitive.PrimState m)
                               dt3
                               i#) } })
                         (\ b1 :: GHC.Types.Int ->
                          GHC.Base.>>=
                            @ m
                            $dMonad
                            @ GHC.Word.Word8
                            @ (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8)
                            (case cs
                                    `cast`
                                  (Trans
                                       (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                                 <Control.Monad.Primitive.PrimState m>_N))
                                       (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                            <Control.Monad.Primitive.PrimState
                                               m>_N)) of wild1 { Data.Vector.Primitive.Mutable.MVector dt1 dt2 dt3 ->
                             case GHC.Num.$fNumInt_$c+
                                    (GHC.Types.I# dt1)
                                    eta1 of wild2 { GHC.Types.I# i# ->
                             Control.Monad.Primitive.primitive
                               @ m
                               $dPrimMonad
                               @ GHC.Word.Word8
                               (Data.Primitive.Types.$fPrimWord8_$creadByteArray#
                                  @ (Control.Monad.Primitive.PrimState m)
                                  dt3
                                  i#) } })
                            (\ c1 :: GHC.Word.Word8 ->
                             GHC.Base.return
                               @ m
                               $dMonad
                               @ (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8)
                               (a21, b1, c1)))) })) -}
7974ea60cb767d2cccb374fcf473a0ab
  $fMVectorMVectorPromotion_$cbasicUnsafeReplicate ::
    Control.Monad.Primitive.PrimMonad m =>
    GHC.Types.Int
    -> MoveTypes.Promotion
    -> m (Data.Vector.Unboxed.Base.MVector
            (Control.Monad.Primitive.PrimState m) MoveTypes.Promotion)
  {- Arity: 3, Strictness: <S(SL),U(U,C(U))><L,U(U)><L,1*U(U,U,U)>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   eta :: GHC.Types.Int
                   eta1 :: MoveTypes.Promotion ->
                 GHC.Base.liftM
                   @ (Data.Vector.Unboxed.Base.MVector
                        (Control.Monad.Primitive.PrimState m)
                        (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8))
                   @ (Data.Vector.Unboxed.Base.MVector
                        (Control.Monad.Primitive.PrimState m) MoveTypes.Promotion)
                   @ m
                   (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                   (\ tpl :: Data.Vector.Unboxed.Base.MVector
                               (Control.Monad.Primitive.PrimState m)
                               (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8) ->
                    tpl)
                     `cast`
                   (<Data.Vector.Unboxed.Base.MVector
                       (Control.Monad.Primitive.PrimState m)
                       (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8)>_R
                    ->_R Trans
                             (Sym (MoveTypes.NTCo:R:MVectorsPromotion[0]
                                       <Control.Monad.Primitive.PrimState m>_N))
                             (Sub (Sym (MoveTypes.TFCo:R:MVectorsPromotion[0]
                                            <Control.Monad.Primitive.PrimState m>_N))))
                   (let {
                      $dMonad :: GHC.Base.Monad m
                      = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                    } in
                    case eta1 of wild { MoveTypes.Promotion dt dt1 dt2 ->
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                      @ (Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m)
                           (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8))
                      (GHC.Base.liftM
                         @ (Data.Vector.Primitive.Mutable.MVector
                              (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                         @ (Data.Vector.Unboxed.Base.MVector
                              (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                         @ m
                         (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                         (\ tpl :: Data.Vector.Primitive.Mutable.MVector
                                     (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                          tpl)
                           `cast`
                         (<Data.Vector.Primitive.Mutable.MVector
                             (Control.Monad.Primitive.PrimState m) GHC.Types.Int>_R
                          ->_R Trans
                                   (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                             <Control.Monad.Primitive.PrimState m>_N))
                                   (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                  <Control.Monad.Primitive.PrimState m>_N))))
                         (let {
                            $dMonad1 :: GHC.Base.Monad m
                            = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                          } in
                          GHC.Base.>>=
                            @ m
                            $dMonad1
                            @ (Data.Vector.Primitive.Mutable.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                            @ (Data.Vector.Primitive.Mutable.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                            (let {
                               size :: GHC.Types.Int
                               = Data.Vector.Primitive.$fVectorVectora_$ssizeOf
                                   (GHC.Err.undefined @ GHC.Types.Int)
                             } in
                             case eta of wild1 { GHC.Types.I# x ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.<# x 0) of wild2 {
                               GHC.Types.False
                               -> case GHC.Real.$fIntegralInt_$cdiv
                                         GHC.Base.maxInt
                                         size of wild3 { GHC.Types.I# y ->
                                  case GHC.Prim.tagToEnum#
                                         @ GHC.Types.Bool
                                         (GHC.Prim.># x y) of wild4 {
                                    GHC.Types.False
                                    -> GHC.Base.liftM
                                         @ (Data.Primitive.ByteArray.MutableByteArray
                                              (Control.Monad.Primitive.PrimState m))
                                         @ (Data.Vector.Primitive.Mutable.MVector
                                              (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                                         @ m
                                         (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                                         (Data.Vector.Primitive.Mutable.$WMVector
                                            @ (Control.Monad.Primitive.PrimState m)
                                            @ GHC.Types.Int
                                            (GHC.Types.I# 0)
                                            wild1)
                                         (case GHC.Num.$fNumInt_$c*
                                                 wild1
                                                 size of wild5 { GHC.Types.I# n# ->
                                          Control.Monad.Primitive.primitive
                                            @ m
                                            $dPrimMonad
                                            @ (Data.Primitive.ByteArray.MutableByteArray
                                                 (Control.Monad.Primitive.PrimState m))
                                            (\ s# :: GHC.Prim.State#
                                                       (Control.Monad.Primitive.PrimState
                                                          m)[OneShot] ->
                                             case GHC.Prim.newByteArray#
                                                    @ (Control.Monad.Primitive.PrimState m)
                                                    n#
                                                    s# of ds1 { (#,#) ipv ipv1 ->
                                             (# ipv,
                                                Data.Primitive.ByteArray.MutableByteArray
                                                  @ (Control.Monad.Primitive.PrimState m)
                                                  ipv1 #) }) })
                                    GHC.Types.True
                                    -> GHC.Base.$
                                         @ [GHC.Types.Char]
                                         @ (m (Data.Vector.Primitive.Mutable.MVector
                                                 (Control.Monad.Primitive.PrimState m)
                                                 GHC.Types.Int))
                                         (GHC.Err.error
                                            @ (m (Data.Vector.Primitive.Mutable.MVector
                                                    (Control.Monad.Primitive.PrimState m)
                                                    GHC.Types.Int)))
                                         (GHC.Base.augment
                                            @ GHC.Types.Char
                                            (\ @ b
                                               c :: GHC.Types.Char -> b -> b[OneShot]
                                               n :: b[OneShot] ->
                                             GHC.CString.unpackFoldrCString#
                                               @ b
                                               "Primitive.basicUnsafeNew: length to large: "#
                                               c
                                               n)
                                            (GHC.Show.$fShowInt_$cshow wild1)) } }
                               GHC.Types.True
                               -> GHC.Base.$
                                    @ [GHC.Types.Char]
                                    @ (m (Data.Vector.Primitive.Mutable.MVector
                                            (Control.Monad.Primitive.PrimState m) GHC.Types.Int))
                                    (GHC.Err.error
                                       @ (m (Data.Vector.Primitive.Mutable.MVector
                                               (Control.Monad.Primitive.PrimState m)
                                               GHC.Types.Int)))
                                    (GHC.Base.augment
                                       @ GHC.Types.Char
                                       (\ @ b
                                          c :: GHC.Types.Char -> b -> b[OneShot]
                                          n :: b[OneShot] ->
                                        GHC.CString.unpackFoldrCString#
                                          @ b
                                          "Primitive.basicUnsafeNew: negative length: "#
                                          c
                                          n)
                                       (GHC.Show.$fShowInt_$cshow wild1)) } })
                            (\ v1 :: Data.Vector.Primitive.Mutable.MVector
                                       (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                             GHC.Base.>>
                               @ m
                               $dMonad1
                               @ ()
                               @ (Data.Vector.Primitive.Mutable.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                               (case v1 of wild1 { Data.Vector.Primitive.Mutable.MVector dt3 dt4 dt5 ->
                                Control.Monad.Primitive.primitive
                                  @ m
                                  $dPrimMonad
                                  @ ()
                                  (\ s# :: GHC.Prim.State#
                                             (Control.Monad.Primitive.PrimState m)[OneShot] ->
                                   case GHC.Base.id
                                          @ GHC.Types.Int
                                          (GHC.Types.I# dt3) of wild2 { GHC.Types.I# x#1 ->
                                   case ((Data.Primitive.Internal.Operations.setIntArray#
                                            @ (Control.Monad.Primitive.PrimState m)
                                            dt5
                                            (GHC.Int.I64# x#1)
                                              `cast`
                                            (Sym (Foreign.C.Types.NTCo:CPtrdiff[0]))
                                            (GHC.Word.W64# (GHC.Prim.int2Word# dt4))
                                              `cast`
                                            (Sym (Foreign.C.Types.NTCo:CSize[0]))
                                            dt)
                                           `cast`
                                         (Trans
                                              (GHC.Types.NTCo:IO[0] <()>_R)
                                              ((GHC.Prim.State#
                                                  (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R
                                               ->_R ((# (GHC.Prim.State#
                                                           (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R,
                                                        <()>_R #))_R))
                                           s#
                                             `cast`
                                           (GHC.Prim.State#
                                              (Trans
                                                   (UnivCo mkUnsafeCo nominal (Control.Monad.Primitive.PrimState
                                                                                 m) GHC.Prim.RealWorld)
                                                   (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0]))))_R)
                                          `cast`
                                        ((# (GHC.Prim.State#
                                               (Trans
                                                    (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])
                                                    (UnivCo mkUnsafeCo nominal GHC.Prim.RealWorld (Control.Monad.Primitive.PrimState
                                                                                                     m))))_R,
                                            UnivCo mkUnsafeCo representational () GHC.Prim.Any #))_R of ds1 { (#,#) ipv ipv1 ->
                                   (# ipv, GHC.Tuple.() #) } }) })
                               (GHC.Base.return
                                  @ m
                                  $dMonad1
                                  @ (Data.Vector.Primitive.Mutable.MVector
                                       (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                                  v1))))
                      (\ as :: Data.Vector.Unboxed.Base.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (Data.Vector.Unboxed.Base.MVector
                              (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                         @ (Data.Vector.Unboxed.Base.MVector
                              (Control.Monad.Primitive.PrimState m)
                              (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8))
                         (GHC.Base.liftM
                            @ (Data.Vector.Primitive.Mutable.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                            @ (Data.Vector.Unboxed.Base.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                            @ m
                            (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                            (\ tpl :: Data.Vector.Primitive.Mutable.MVector
                                        (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                             tpl)
                              `cast`
                            (<Data.Vector.Primitive.Mutable.MVector
                                (Control.Monad.Primitive.PrimState m) GHC.Types.Int>_R
                             ->_R Trans
                                      (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                                <Control.Monad.Primitive.PrimState m>_N))
                                      (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                     <Control.Monad.Primitive.PrimState m>_N))))
                            (let {
                               $dMonad1 :: GHC.Base.Monad m
                               = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                             } in
                             GHC.Base.>>=
                               @ m
                               $dMonad1
                               @ (Data.Vector.Primitive.Mutable.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                               @ (Data.Vector.Primitive.Mutable.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                               (let {
                                  size :: GHC.Types.Int
                                  = Data.Vector.Primitive.$fVectorVectora_$ssizeOf
                                      (GHC.Err.undefined @ GHC.Types.Int)
                                } in
                                case eta of wild1 { GHC.Types.I# x ->
                                case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.<# x 0) of wild2 {
                                  GHC.Types.False
                                  -> case GHC.Real.$fIntegralInt_$cdiv
                                            GHC.Base.maxInt
                                            size of wild3 { GHC.Types.I# y ->
                                     case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.># x y) of wild4 {
                                       GHC.Types.False
                                       -> GHC.Base.liftM
                                            @ (Data.Primitive.ByteArray.MutableByteArray
                                                 (Control.Monad.Primitive.PrimState m))
                                            @ (Data.Vector.Primitive.Mutable.MVector
                                                 (Control.Monad.Primitive.PrimState m)
                                                 GHC.Types.Int)
                                            @ m
                                            (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                                            (Data.Vector.Primitive.Mutable.$WMVector
                                               @ (Control.Monad.Primitive.PrimState m)
                                               @ GHC.Types.Int
                                               (GHC.Types.I# 0)
                                               wild1)
                                            (case GHC.Num.$fNumInt_$c*
                                                    wild1
                                                    size of wild5 { GHC.Types.I# n# ->
                                             Control.Monad.Primitive.primitive
                                               @ m
                                               $dPrimMonad
                                               @ (Data.Primitive.ByteArray.MutableByteArray
                                                    (Control.Monad.Primitive.PrimState m))
                                               (\ s# :: GHC.Prim.State#
                                                          (Control.Monad.Primitive.PrimState
                                                             m)[OneShot] ->
                                                case GHC.Prim.newByteArray#
                                                       @ (Control.Monad.Primitive.PrimState m)
                                                       n#
                                                       s# of ds1 { (#,#) ipv ipv1 ->
                                                (# ipv,
                                                   Data.Primitive.ByteArray.MutableByteArray
                                                     @ (Control.Monad.Primitive.PrimState m)
                                                     ipv1 #) }) })
                                       GHC.Types.True
                                       -> GHC.Base.$
                                            @ [GHC.Types.Char]
                                            @ (m (Data.Vector.Primitive.Mutable.MVector
                                                    (Control.Monad.Primitive.PrimState m)
                                                    GHC.Types.Int))
                                            (GHC.Err.error
                                               @ (m (Data.Vector.Primitive.Mutable.MVector
                                                       (Control.Monad.Primitive.PrimState m)
                                                       GHC.Types.Int)))
                                            (GHC.Base.augment
                                               @ GHC.Types.Char
                                               (\ @ b
                                                  c :: GHC.Types.Char -> b -> b[OneShot]
                                                  n :: b[OneShot] ->
                                                GHC.CString.unpackFoldrCString#
                                                  @ b
                                                  "Primitive.basicUnsafeNew: length to large: "#
                                                  c
                                                  n)
                                               (GHC.Show.$fShowInt_$cshow wild1)) } }
                                  GHC.Types.True
                                  -> GHC.Base.$
                                       @ [GHC.Types.Char]
                                       @ (m (Data.Vector.Primitive.Mutable.MVector
                                               (Control.Monad.Primitive.PrimState m) GHC.Types.Int))
                                       (GHC.Err.error
                                          @ (m (Data.Vector.Primitive.Mutable.MVector
                                                  (Control.Monad.Primitive.PrimState m)
                                                  GHC.Types.Int)))
                                       (GHC.Base.augment
                                          @ GHC.Types.Char
                                          (\ @ b
                                             c :: GHC.Types.Char -> b -> b[OneShot]
                                             n :: b[OneShot] ->
                                           GHC.CString.unpackFoldrCString#
                                             @ b
                                             "Primitive.basicUnsafeNew: negative length: "#
                                             c
                                             n)
                                          (GHC.Show.$fShowInt_$cshow wild1)) } })
                               (\ v1 :: Data.Vector.Primitive.Mutable.MVector
                                          (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                                GHC.Base.>>
                                  @ m
                                  $dMonad1
                                  @ ()
                                  @ (Data.Vector.Primitive.Mutable.MVector
                                       (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                                  (case v1 of wild1 { Data.Vector.Primitive.Mutable.MVector dt3 dt4 dt5 ->
                                   Control.Monad.Primitive.primitive
                                     @ m
                                     $dPrimMonad
                                     @ ()
                                     (\ s# :: GHC.Prim.State#
                                                (Control.Monad.Primitive.PrimState m)[OneShot] ->
                                      case GHC.Base.id
                                             @ GHC.Types.Int
                                             (GHC.Types.I# dt3) of wild2 { GHC.Types.I# x#1 ->
                                      case ((Data.Primitive.Internal.Operations.setIntArray#
                                               @ (Control.Monad.Primitive.PrimState m)
                                               dt5
                                               (GHC.Int.I64# x#1)
                                                 `cast`
                                               (Sym (Foreign.C.Types.NTCo:CPtrdiff[0]))
                                               (GHC.Word.W64# (GHC.Prim.int2Word# dt4))
                                                 `cast`
                                               (Sym (Foreign.C.Types.NTCo:CSize[0]))
                                               dt1)
                                              `cast`
                                            (Trans
                                                 (GHC.Types.NTCo:IO[0] <()>_R)
                                                 ((GHC.Prim.State#
                                                     (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R
                                                  ->_R ((# (GHC.Prim.State#
                                                              (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R,
                                                           <()>_R #))_R))
                                              s#
                                                `cast`
                                              (GHC.Prim.State#
                                                 (Trans
                                                      (UnivCo mkUnsafeCo nominal (Control.Monad.Primitive.PrimState
                                                                                    m) GHC.Prim.RealWorld)
                                                      (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0]))))_R)
                                             `cast`
                                           ((# (GHC.Prim.State#
                                                  (Trans
                                                       (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])
                                                       (UnivCo mkUnsafeCo nominal GHC.Prim.RealWorld (Control.Monad.Primitive.PrimState
                                                                                                        m))))_R,
                                               UnivCo mkUnsafeCo representational () GHC.Prim.Any #))_R of ds1 { (#,#) ipv ipv1 ->
                                      (# ipv, GHC.Tuple.() #) } }) })
                                  (GHC.Base.return
                                     @ m
                                     $dMonad1
                                     @ (Data.Vector.Primitive.Mutable.MVector
                                          (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                                     v1))))
                         (\ bs :: Data.Vector.Unboxed.Base.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                          GHC.Base.>>=
                            @ m
                            $dMonad
                            @ (Data.Vector.Unboxed.Base.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                            @ (Data.Vector.Unboxed.Base.MVector
                                 (Control.Monad.Primitive.PrimState m)
                                 (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8))
                            (GHC.Base.liftM
                               @ (Data.Vector.Primitive.Mutable.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                               @ (Data.Vector.Unboxed.Base.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                               @ m
                               (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                               (\ tpl :: Data.Vector.Primitive.Mutable.MVector
                                           (Control.Monad.Primitive.PrimState m) GHC.Word.Word8 ->
                                tpl)
                                 `cast`
                               (<Data.Vector.Primitive.Mutable.MVector
                                   (Control.Monad.Primitive.PrimState m) GHC.Word.Word8>_R
                                ->_R Trans
                                         (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                                   <Control.Monad.Primitive.PrimState m>_N))
                                         (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                                        <Control.Monad.Primitive.PrimState m>_N))))
                               (let {
                                  $dMonad1 :: GHC.Base.Monad m
                                  = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                                } in
                                GHC.Base.>>=
                                  @ m
                                  $dMonad1
                                  @ (Data.Vector.Primitive.Mutable.MVector
                                       (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                                  @ (Data.Vector.Primitive.Mutable.MVector
                                       (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                                  (let {
                                     size :: GHC.Types.Int
                                     = Data.Vector.Unboxed.Base.$fMVectorMVectorBool_$ssizeOf
                                         (GHC.Err.undefined @ GHC.Word.Word8)
                                   } in
                                   case eta of wild1 { GHC.Types.I# x ->
                                   case GHC.Prim.tagToEnum#
                                          @ GHC.Types.Bool
                                          (GHC.Prim.<# x 0) of wild2 {
                                     GHC.Types.False
                                     -> case GHC.Real.$fIntegralInt_$cdiv
                                               GHC.Base.maxInt
                                               size of wild3 { GHC.Types.I# y ->
                                        case GHC.Prim.tagToEnum#
                                               @ GHC.Types.Bool
                                               (GHC.Prim.># x y) of wild4 {
                                          GHC.Types.False
                                          -> GHC.Base.liftM
                                               @ (Data.Primitive.ByteArray.MutableByteArray
                                                    (Control.Monad.Primitive.PrimState m))
                                               @ (Data.Vector.Primitive.Mutable.MVector
                                                    (Control.Monad.Primitive.PrimState m)
                                                    GHC.Word.Word8)
                                               @ m
                                               (Control.Monad.Primitive.$p1PrimMonad
                                                  @ m
                                                  $dPrimMonad)
                                               (Data.Vector.Primitive.Mutable.$WMVector
                                                  @ (Control.Monad.Primitive.PrimState m)
                                                  @ GHC.Word.Word8
                                                  (GHC.Types.I# 0)
                                                  wild1)
                                               (case GHC.Num.$fNumInt_$c*
                                                       wild1
                                                       size of wild5 { GHC.Types.I# n# ->
                                                Control.Monad.Primitive.primitive
                                                  @ m
                                                  $dPrimMonad
                                                  @ (Data.Primitive.ByteArray.MutableByteArray
                                                       (Control.Monad.Primitive.PrimState m))
                                                  (\ s# :: GHC.Prim.State#
                                                             (Control.Monad.Primitive.PrimState
                                                                m)[OneShot] ->
                                                   case GHC.Prim.newByteArray#
                                                          @ (Control.Monad.Primitive.PrimState m)
                                                          n#
                                                          s# of ds1 { (#,#) ipv ipv1 ->
                                                   (# ipv,
                                                      Data.Primitive.ByteArray.MutableByteArray
                                                        @ (Control.Monad.Primitive.PrimState m)
                                                        ipv1 #) }) })
                                          GHC.Types.True
                                          -> GHC.Base.$
                                               @ [GHC.Types.Char]
                                               @ (m (Data.Vector.Primitive.Mutable.MVector
                                                       (Control.Monad.Primitive.PrimState m)
                                                       GHC.Word.Word8))
                                               (GHC.Err.error
                                                  @ (m (Data.Vector.Primitive.Mutable.MVector
                                                          (Control.Monad.Primitive.PrimState m)
                                                          GHC.Word.Word8)))
                                               (GHC.Base.augment
                                                  @ GHC.Types.Char
                                                  (\ @ b
                                                     c :: GHC.Types.Char -> b -> b[OneShot]
                                                     n :: b[OneShot] ->
                                                   GHC.CString.unpackFoldrCString#
                                                     @ b
                                                     "Primitive.basicUnsafeNew: length to large: "#
                                                     c
                                                     n)
                                                  (GHC.Show.$fShowInt_$cshow wild1)) } }
                                     GHC.Types.True
                                     -> GHC.Base.$
                                          @ [GHC.Types.Char]
                                          @ (m (Data.Vector.Primitive.Mutable.MVector
                                                  (Control.Monad.Primitive.PrimState m)
                                                  GHC.Word.Word8))
                                          (GHC.Err.error
                                             @ (m (Data.Vector.Primitive.Mutable.MVector
                                                     (Control.Monad.Primitive.PrimState m)
                                                     GHC.Word.Word8)))
                                          (GHC.Base.augment
                                             @ GHC.Types.Char
                                             (\ @ b
                                                c :: GHC.Types.Char -> b -> b[OneShot]
                                                n :: b[OneShot] ->
                                              GHC.CString.unpackFoldrCString#
                                                @ b
                                                "Primitive.basicUnsafeNew: negative length: "#
                                                c
                                                n)
                                             (GHC.Show.$fShowInt_$cshow wild1)) } })
                                  (\ v1 :: Data.Vector.Primitive.Mutable.MVector
                                             (Control.Monad.Primitive.PrimState m) GHC.Word.Word8 ->
                                   GHC.Base.>>
                                     @ m
                                     $dMonad1
                                     @ ()
                                     @ (Data.Vector.Primitive.Mutable.MVector
                                          (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                                     (case v1 of wild1 { Data.Vector.Primitive.Mutable.MVector dt3 dt4 dt5 ->
                                      Control.Monad.Primitive.primitive
                                        @ m
                                        $dPrimMonad
                                        @ ()
                                        (\ s# :: GHC.Prim.State#
                                                   (Control.Monad.Primitive.PrimState m)[OneShot] ->
                                         case GHC.Base.id
                                                @ GHC.Types.Int
                                                (GHC.Types.I# dt3) of wild2 { GHC.Types.I# x#1 ->
                                         case ((Data.Primitive.Internal.Operations.setWord8Array#
                                                  @ (Control.Monad.Primitive.PrimState m)
                                                  dt5
                                                  (GHC.Int.I64# x#1)
                                                    `cast`
                                                  (Sym (Foreign.C.Types.NTCo:CPtrdiff[0]))
                                                  (GHC.Word.W64# (GHC.Prim.int2Word# dt4))
                                                    `cast`
                                                  (Sym (Foreign.C.Types.NTCo:CSize[0]))
                                                  dt2)
                                                 `cast`
                                               (Trans
                                                    (GHC.Types.NTCo:IO[0] <()>_R)
                                                    ((GHC.Prim.State#
                                                        (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R
                                                     ->_R ((# (GHC.Prim.State#
                                                                 (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R,
                                                              <()>_R #))_R))
                                                 s#
                                                   `cast`
                                                 (GHC.Prim.State#
                                                    (Trans
                                                         (UnivCo mkUnsafeCo nominal (Control.Monad.Primitive.PrimState
                                                                                       m) GHC.Prim.RealWorld)
                                                         (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0]))))_R)
                                                `cast`
                                              ((# (GHC.Prim.State#
                                                     (Trans
                                                          (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])
                                                          (UnivCo mkUnsafeCo nominal GHC.Prim.RealWorld (Control.Monad.Primitive.PrimState
                                                                                                           m))))_R,
                                                  UnivCo mkUnsafeCo representational () GHC.Prim.Any #))_R of ds1 { (#,#) ipv ipv1 ->
                                         (# ipv, GHC.Tuple.() #) } }) })
                                     (GHC.Base.return
                                        @ m
                                        $dMonad1
                                        @ (Data.Vector.Primitive.Mutable.MVector
                                             (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                                        v1))))
                            (\ cs :: Data.Vector.Unboxed.Base.MVector
                                       (Control.Monad.Primitive.PrimState m) GHC.Word.Word8 ->
                             GHC.Base.$
                               @ (Data.Vector.Unboxed.Base.MVector
                                    (Control.Monad.Primitive.PrimState m)
                                    (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8))
                               @ (m (Data.Vector.Unboxed.Base.MVector
                                       (Control.Monad.Primitive.PrimState m)
                                       (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8)))
                               (GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (Data.Vector.Unboxed.Base.MVector
                                       (Control.Monad.Primitive.PrimState m)
                                       (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8)))
                               (Data.Vector.Unboxed.Base.$WMV_3
                                  @ (Control.Monad.Primitive.PrimState m)
                                  @ GHC.Types.Int
                                  @ GHC.Types.Int
                                  @ GHC.Word.Word8
                                  eta
                                  as
                                  bs
                                  cs)))) })) -}
7974ea60cb767d2cccb374fcf473a0ab
  $fMVectorMVectorPromotion_$cbasicUnsafeSlice ::
    GHC.Types.Int
    -> GHC.Types.Int
    -> Data.Vector.Unboxed.Base.MVector s MoveTypes.Promotion
    -> Data.Vector.Unboxed.Base.MVector s MoveTypes.Promotion
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,1*U(U)><S,1*U(U)><S(LSSS),1*U(A,U(U,A,U),U(U,A,U),U(U,A,U))>m,
     Inline: INLINE (sat-args=3),
     Unfolding: InlineRule (3, False, False)
                (\ @ s
                   idx :: GHC.Types.Int
                   len :: GHC.Types.Int
                   ds :: Data.Vector.Unboxed.Base.MVector s MoveTypes.Promotion ->
                 case ds
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:MVectorsPromotion[0] <s>_N))
                           (Trans
                                (MoveTypes.NTCo:R:MVectorsPromotion[0] <s>_N)
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,,)[0]
                                          <s>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Word.Word8>_N)))) of wild { Data.Vector.Unboxed.Base.MV_3 dt as bs cs ->
                 case len of dt1 { GHC.Types.I# dt2 ->
                 case (GHC.Base.$
                         @ (Data.Vector.Primitive.Mutable.MVector s GHC.Types.Int)
                         @ (Data.Vector.Unboxed.Base.MVector s GHC.Types.Int)
                         (\ tpl :: Data.Vector.Primitive.Mutable.MVector s GHC.Types.Int ->
                          tpl)
                           `cast`
                         (<Data.Vector.Primitive.Mutable.MVector s GHC.Types.Int>_R
                          ->_R Trans
                                   (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0] <s>_N))
                                   (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                  <s>_N))))
                         (Data.Vector.Primitive.$fVectorVectora1
                            @ s
                            idx
                            dt1
                            as
                              `cast`
                            (Trans
                                 (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0] <s>_N))
                                 (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0] <s>_N))))
                        `cast`
                      (Trans
                           (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0] <s>_N))
                           (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                <s>_N)) of nt { Data.Vector.Primitive.Mutable.MVector ipv ipv1 ipv2 ->
                 case (GHC.Base.$
                         @ (Data.Vector.Primitive.Mutable.MVector s GHC.Types.Int)
                         @ (Data.Vector.Unboxed.Base.MVector s GHC.Types.Int)
                         (\ tpl :: Data.Vector.Primitive.Mutable.MVector s GHC.Types.Int ->
                          tpl)
                           `cast`
                         (<Data.Vector.Primitive.Mutable.MVector s GHC.Types.Int>_R
                          ->_R Trans
                                   (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0] <s>_N))
                                   (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                  <s>_N))))
                         (Data.Vector.Primitive.$fVectorVectora1
                            @ s
                            idx
                            dt1
                            bs
                              `cast`
                            (Trans
                                 (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0] <s>_N))
                                 (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0] <s>_N))))
                        `cast`
                      (Trans
                           (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0] <s>_N))
                           (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                <s>_N)) of nt1 { Data.Vector.Primitive.Mutable.MVector ipv3 ipv4 ipv5 ->
                 case (GHC.Base.$
                         @ (Data.Vector.Primitive.Mutable.MVector s GHC.Word.Word8)
                         @ (Data.Vector.Unboxed.Base.MVector s GHC.Word.Word8)
                         (\ tpl :: Data.Vector.Primitive.Mutable.MVector s GHC.Word.Word8 ->
                          tpl)
                           `cast`
                         (<Data.Vector.Primitive.Mutable.MVector s GHC.Word.Word8>_R
                          ->_R Trans
                                   (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0] <s>_N))
                                   (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                                  <s>_N))))
                         (Data.Vector.Unboxed.Base.$fMVectorMVectorBool1
                            @ s
                            idx
                            dt1
                            cs
                              `cast`
                            (Trans
                                 (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0] <s>_N))
                                 (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0] <s>_N))))
                        `cast`
                      (Trans
                           (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0] <s>_N))
                           (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                <s>_N)) of nt2 { Data.Vector.Primitive.Mutable.MVector ipv6 ipv7 ipv8 ->
                 (Data.Vector.Unboxed.Base.MV_3
                    @ s
                    @ GHC.Types.Int
                    @ GHC.Types.Int
                    @ GHC.Word.Word8
                    dt2
                    nt
                      `cast`
                    (Trans
                         (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0] <s>_N))
                         (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0] <s>_N))))
                    nt1
                      `cast`
                    (Trans
                         (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0] <s>_N))
                         (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0] <s>_N))))
                    nt2
                      `cast`
                    (Trans
                         (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0] <s>_N))
                         (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                        <s>_N)))))
                   `cast`
                 (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,,)[0]
                                <s>_N
                                <GHC.Types.Int>_N
                                <GHC.Types.Int>_N
                                <GHC.Word.Word8>_N))) } } } } })
                  `cast`
                (forall s.
                 <GHC.Types.Int>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R <Data.Vector.Unboxed.Base.MVector s MoveTypes.Promotion>_R
                 ->_R Trans
                          (Sym (MoveTypes.NTCo:R:MVectorsPromotion[0] <s>_N))
                          (Sub (Sym (MoveTypes.TFCo:R:MVectorsPromotion[0] <s>_N)))) -}
7974ea60cb767d2cccb374fcf473a0ab
  $fMVectorMVectorPromotion_$cbasicUnsafeWrite ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Unboxed.Base.MVector
      (Control.Monad.Primitive.PrimState m) MoveTypes.Promotion
    -> GHC.Types.Int -> MoveTypes.Promotion -> m ()
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(SL),U(1*U,C(U))><S(LSSS),1*U(A,U(U,A,U),U(U,A,U),U(U,A,U))><L,U(U)><S,1*U(U,U,U)>,
     Inline: INLINE (sat-args=3),
     Unfolding: InlineRule (3, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   ds :: Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m) MoveTypes.Promotion
                   idx :: GHC.Types.Int
                   val :: MoveTypes.Promotion ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                 } in
                 case ds
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:MVectorsPromotion[0]
                                     <Control.Monad.Primitive.PrimState m>_N))
                           (Trans
                                (MoveTypes.NTCo:R:MVectorsPromotion[0]
                                     <Control.Monad.Primitive.PrimState m>_N)
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,,)[0]
                                          <Control.Monad.Primitive.PrimState m>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Word.Word8>_N)))) of wild { Data.Vector.Unboxed.Base.MV_3 dt as bs cs ->
                 case val of wild1 { MoveTypes.Promotion dt1 dt2 dt3 ->
                 GHC.Base.>>
                   @ m
                   $dMonad
                   @ ()
                   @ ()
                   (case as
                           `cast`
                         (Trans
                              (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                        <Control.Monad.Primitive.PrimState m>_N))
                              (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                   <Control.Monad.Primitive.PrimState
                                      m>_N)) of wild2 { Data.Vector.Primitive.Mutable.MVector dt4 dt5 dt6 ->
                    case GHC.Num.$fNumInt_$c+
                           (GHC.Types.I# dt4)
                           idx of wild3 { GHC.Types.I# i# ->
                    Control.Monad.Primitive.primitive
                      @ m
                      $dPrimMonad
                      @ ()
                      (\ s# :: GHC.Prim.State#
                                 (Control.Monad.Primitive.PrimState m)[OneShot] ->
                       case GHC.Prim.writeIntArray#
                              @ (Control.Monad.Primitive.PrimState m)
                              dt6
                              i#
                              dt1
                              s# of s'# { DEFAULT ->
                       (# s'#, GHC.Tuple.() #) }) } })
                   (GHC.Base.>>
                      @ m
                      $dMonad
                      @ ()
                      @ ()
                      (case bs
                              `cast`
                            (Trans
                                 (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                           <Control.Monad.Primitive.PrimState m>_N))
                                 (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                      <Control.Monad.Primitive.PrimState
                                         m>_N)) of wild2 { Data.Vector.Primitive.Mutable.MVector dt4 dt5 dt6 ->
                       case GHC.Num.$fNumInt_$c+
                              (GHC.Types.I# dt4)
                              idx of wild3 { GHC.Types.I# i# ->
                       Control.Monad.Primitive.primitive
                         @ m
                         $dPrimMonad
                         @ ()
                         (\ s# :: GHC.Prim.State#
                                    (Control.Monad.Primitive.PrimState m)[OneShot] ->
                          case GHC.Prim.writeIntArray#
                                 @ (Control.Monad.Primitive.PrimState m)
                                 dt6
                                 i#
                                 dt2
                                 s# of s'# { DEFAULT ->
                          (# s'#, GHC.Tuple.() #) }) } })
                      (case cs
                              `cast`
                            (Trans
                                 (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                           <Control.Monad.Primitive.PrimState m>_N))
                                 (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                      <Control.Monad.Primitive.PrimState
                                         m>_N)) of wild2 { Data.Vector.Primitive.Mutable.MVector dt4 dt5 dt6 ->
                       case GHC.Num.$fNumInt_$c+
                              (GHC.Types.I# dt4)
                              idx of wild3 { GHC.Types.I# i# ->
                       Control.Monad.Primitive.primitive
                         @ m
                         $dPrimMonad
                         @ ()
                         (\ s# :: GHC.Prim.State#
                                    (Control.Monad.Primitive.PrimState m)[OneShot] ->
                          case GHC.Prim.writeWord8Array#
                                 @ (Control.Monad.Primitive.PrimState m)
                                 dt6
                                 i#
                                 dt3
                                 s# of s'# { DEFAULT ->
                          (# s'#, GHC.Tuple.() #) }) } })) } }) -}
f87b40583b48531412a65b59dc7a4f4f
  $fShowMove :: GHC.Show.Show MoveTypes.Move
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ MoveTypes.Move
                  MoveTypes.$fShowMove_$s$dmshowsPrec
                  MoveTypes.$fShowMove_$cshow
                  MoveTypes.$fShowMove_$cshowList -}
f87b40583b48531412a65b59dc7a4f4f
  $fShowMove1 ::
    MoveTypes.Move -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2,
     Unfolding: (\ x :: MoveTypes.Move s :: GHC.Base.String[OneShot] ->
                 GHC.Base.++ @ GHC.Types.Char (MoveTypes.$fShowMove_$cshow x) s) -}
f87b40583b48531412a65b59dc7a4f4f
  $fShowMove_$cshow :: MoveTypes.Move -> GHC.Base.String
  {- Arity: 1, Strictness: <L,1*U(U,U)>,
     Unfolding: (\ x :: MoveTypes.Move ->
                 Text.PrettyPrint.ANSI.Leijen.displayS
                   (Text.PrettyPrint.ANSI.Leijen.renderFits
                      Text.PrettyPrint.ANSI.Leijen.fits1
                      Text.PrettyPrint.ANSI.Leijen.$fShowDoc3
                      Text.PrettyPrint.ANSI.Leijen.$fShowDoc2
                      (MoveTypes.moveToDoc x))
                   (GHC.Types.[] @ GHC.Types.Char)) -}
f87b40583b48531412a65b59dc7a4f4f
  $fShowMove_$cshowList :: [MoveTypes.Move] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: (\ ls :: [MoveTypes.Move] s :: GHC.Base.String ->
                 GHC.Show.showList__ @ MoveTypes.Move MoveTypes.$fShowMove1 ls s) -}
f87b40583b48531412a65b59dc7a4f4f
  $fShowMove_$s$dmshowsPrec ::
    GHC.Types.Int -> MoveTypes.Move -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><L,1*U(U,U)><L,1*U>,
     Unfolding: InlineRule (-1, True, False)
                (\ ds :: GHC.Types.Int x :: MoveTypes.Move s :: GHC.Base.String ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (MoveTypes.$fShowMove_$cshow x))
                   s) -}
bce809b1cf44ac24e1da2727bceb75dc
  $fShowMoves :: GHC.Show.Show MoveTypes.Moves
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ MoveTypes.Moves
                  MoveTypes.$fShowMoves_$cshowsPrec
                  MoveTypes.$fShowMoves_$cshow
                  MoveTypes.$fShowMoves_$cshowList -}
bce809b1cf44ac24e1da2727bceb75dc
  $fShowMoves1 :: MoveTypes.Moves -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ w :: MoveTypes.Moves ->
                 case w of ww { MoveTypes.Moves ww1 ww2 ->
                 MoveTypes.$w$cshowsPrec 0 ww1 ww2 }) -}
511a105283deff43efcd177ac92c805f
  $fShowMoves2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "}"#) -}
6d42cabdccf4110cf08f11dcfa6739c8
  $fShowMoves3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "promotions = "#) -}
825ffecbd4981bbe97170dde92818670
  $fShowMoves4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ", "#) -}
d736106e6b2ec96f7f4636d74f815f41
  $fShowMoves5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "moves = "#) -}
2dd7c905c4385a7514e7fccef41d594f
  $fShowMoves6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Moves {"#) -}
bce809b1cf44ac24e1da2727bceb75dc
  $fShowMoves_$cshow :: MoveTypes.Moves -> GHC.Base.String
  {- Arity: 1, Strictness: <S(SS),1*U(U,U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: MoveTypes.Moves ->
                 MoveTypes.$fShowMoves_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
bce809b1cf44ac24e1da2727bceb75dc
  $fShowMoves_$cshowList :: [MoveTypes.Moves] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ MoveTypes.Moves
                   MoveTypes.$fShowMoves1) -}
bce809b1cf44ac24e1da2727bceb75dc
  $fShowMoves_$cshowsPrec ::
    GHC.Types.Int -> MoveTypes.Moves -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(U)><S(SS),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: MoveTypes.Moves ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { MoveTypes.Moves ww3 ww4 ->
                 MoveTypes.$w$cshowsPrec ww1 ww3 ww4 } }) -}
7974ea60cb767d2cccb374fcf473a0ab
  $fShowPromotion :: GHC.Show.Show MoveTypes.Promotion
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ MoveTypes.Promotion
                  MoveTypes.$fShowPromotion_$s$dmshowsPrec
                  MoveTypes.$fShowPromotion_$cshow
                  MoveTypes.$fShowPromotion_$cshowList -}
7974ea60cb767d2cccb374fcf473a0ab
  $fShowPromotion1 ::
    MoveTypes.Promotion -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2,
     Unfolding: (\ x :: MoveTypes.Promotion
                   s :: GHC.Base.String[OneShot] ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (MoveTypes.$fShowPromotion_$cshow x)
                   s) -}
7974ea60cb767d2cccb374fcf473a0ab
  $fShowPromotion_$cshow :: MoveTypes.Promotion -> GHC.Base.String
  {- Arity: 1, Strictness: <L,1*U(U,U,1*U)>,
     Unfolding: (\ x :: MoveTypes.Promotion ->
                 Text.PrettyPrint.ANSI.Leijen.displayS
                   (Text.PrettyPrint.ANSI.Leijen.renderFits
                      Text.PrettyPrint.ANSI.Leijen.fits1
                      Text.PrettyPrint.ANSI.Leijen.$fShowDoc3
                      Text.PrettyPrint.ANSI.Leijen.$fShowDoc2
                      (MoveTypes.promotionToDoc x))
                   (GHC.Types.[] @ GHC.Types.Char)) -}
7974ea60cb767d2cccb374fcf473a0ab
  $fShowPromotion_$cshowList ::
    [MoveTypes.Promotion] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: (\ ls :: [MoveTypes.Promotion] s :: GHC.Base.String ->
                 GHC.Show.showList__
                   @ MoveTypes.Promotion
                   MoveTypes.$fShowPromotion1
                   ls
                   s) -}
7974ea60cb767d2cccb374fcf473a0ab
  $fShowPromotion_$s$dmshowsPrec ::
    GHC.Types.Int -> MoveTypes.Promotion -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><L,1*U(U,U,1*U)><L,1*U>,
     Unfolding: InlineRule (-1, True, False)
                (\ ds :: GHC.Types.Int
                   x :: MoveTypes.Promotion
                   s :: GHC.Base.String ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (MoveTypes.$fShowPromotion_$cshow x))
                   s) -}
f87b40583b48531412a65b59dc7a4f4f
  $fUnboxMove :: Data.Vector.Unboxed.Base.Unbox MoveTypes.Move
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ MoveTypes.Move
                  MoveTypes.$fVectorVectorMove
                  MoveTypes.$fMVectorMVectorMove -}
7974ea60cb767d2cccb374fcf473a0ab
  $fUnboxPromotion ::
    Data.Vector.Unboxed.Base.Unbox MoveTypes.Promotion
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ MoveTypes.Promotion
                  MoveTypes.$fVectorVectorPromotion
                  MoveTypes.$fMVectorMVectorPromotion -}
f87b40583b48531412a65b59dc7a4f4f
  $fVectorVectorMove ::
    Data.Vector.Generic.Base.Vector
      Data.Vector.Unboxed.Base.Vector MoveTypes.Move
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Vector.Unboxed.Base.Vector
                  @ MoveTypes.Move
                  MoveTypes.$fMVectorMVectorMove
                    `cast`
                  (Data.Vector.Generic.Mutable.Base.MVector
                     (Sym (Data.Vector.Unboxed.Base.TFCo:R:MutableVector[0]))
                     <MoveTypes.Move>_N)_R
                  MoveTypes.$fVectorVectorMove_$cbasicUnsafeFreeze
                  MoveTypes.$fVectorVectorMove_$cbasicUnsafeThaw
                  MoveTypes.$fVectorVectorMove_$cbasicLength
                  MoveTypes.$fVectorVectorMove_$cbasicUnsafeSlice
                  MoveTypes.$fVectorVectorMove_$cbasicUnsafeIndexM
                  MoveTypes.$fVectorVectorMove_$cbasicUnsafeCopy
                  MoveTypes.$fVectorVectorMove_$celemseq -}
f87b40583b48531412a65b59dc7a4f4f
  $fVectorVectorMove_$cbasicLength ::
    Data.Vector.Unboxed.Base.Vector MoveTypes.Move -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSS),1*U(U,1*H,1*H)>m,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ ds :: Data.Vector.Unboxed.Base.Vector MoveTypes.Move ->
                 case ds
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:VectorMove[0]))
                           (Trans
                                (MoveTypes.NTCo:R:VectorMove[0])
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:Vector(,)[0]
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N)))) of wild { Data.Vector.Unboxed.Base.V_2 dt ds1 ds2 ->
                 GHC.Types.I# dt }) -}
f87b40583b48531412a65b59dc7a4f4f
  $fVectorVectorMove_$cbasicUnsafeCopy ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Generic.Base.Mutable
      Data.Vector.Unboxed.Base.Vector
      (Control.Monad.Primitive.PrimState m)
      MoveTypes.Move
    -> Data.Vector.Unboxed.Base.Vector MoveTypes.Move -> m ()
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(LLC(C(S))LL)L),U(1*U(A,A,1*C1(C1(U)),A,A),C(U))><S(LSS),1*U(A,U(U,U,U),U(U,U,U))><S(LSS),1*U(A,U(U,A,U),U(U,A,U))>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   ds :: Data.Vector.Generic.Base.Mutable
                           Data.Vector.Unboxed.Base.Vector
                           (Control.Monad.Primitive.PrimState m)
                           MoveTypes.Move
                   ds1 :: Data.Vector.Unboxed.Base.Vector MoveTypes.Move ->
                 case ds
                        `cast`
                      (Trans
                           (Sub (Data.Vector.Unboxed.Base.TFCo:R:MutableVector[0]) <Control.Monad.Primitive.PrimState
                                                                                      m>_N <MoveTypes.Move>_N)
                           (Trans
                                (Sub (MoveTypes.TFCo:R:MVectorsMove[0]
                                          <Control.Monad.Primitive.PrimState m>_N))
                                (Trans
                                     (MoveTypes.NTCo:R:MVectorsMove[0]
                                          <Control.Monad.Primitive.PrimState m>_N)
                                     (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,)[0]
                                               <Control.Monad.Primitive.PrimState m>_N
                                               <GHC.Types.Int>_N
                                               <GHC.Types.Int>_N))))) of wild { Data.Vector.Unboxed.Base.MV_2 dt as1 bs1 ->
                 case ds1
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:VectorMove[0]))
                           (Trans
                                (MoveTypes.NTCo:R:VectorMove[0])
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:Vector(,)[0]
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N)))) of wild1 { Data.Vector.Unboxed.Base.V_2 dt1 as2 bs2 ->
                 GHC.Base.>>
                   @ m
                   (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                   @ ()
                   @ ()
                   (Data.Vector.Unboxed.Base.$fVectorVectorInt_$cbasicUnsafeCopy
                      @ m
                      $dPrimMonad
                      as1
                        `cast`
                      (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MutableVector[0])) <Control.Monad.Primitive.PrimState
                                                                                       m>_N <GHC.Types.Int>_N)
                      as2)
                   (Data.Vector.Unboxed.Base.$fVectorVectorInt_$cbasicUnsafeCopy
                      @ m
                      $dPrimMonad
                      bs1
                        `cast`
                      (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MutableVector[0])) <Control.Monad.Primitive.PrimState
                                                                                       m>_N <GHC.Types.Int>_N)
                      bs2) } }) -}
f87b40583b48531412a65b59dc7a4f4f
  $fVectorVectorMove_$cbasicUnsafeFreeze ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Generic.Base.Mutable
      Data.Vector.Unboxed.Base.Vector
      (Control.Monad.Primitive.PrimState m)
      MoveTypes.Move
    -> m (Data.Vector.Unboxed.Base.Vector MoveTypes.Move)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),U(U,C(U))><L,1*U(U,U(U,U,U),U(U,U,U))>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   eta :: Data.Vector.Generic.Base.Mutable
                            Data.Vector.Unboxed.Base.Vector
                            (Control.Monad.Primitive.PrimState m)
                            MoveTypes.Move ->
                 GHC.Base.liftM
                   @ (Data.Vector.Unboxed.Base.Vector (GHC.Types.Int, GHC.Types.Int))
                   @ (Data.Vector.Unboxed.Base.Vector MoveTypes.Move)
                   @ m
                   (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                   (\ tpl :: Data.Vector.Unboxed.Base.Vector
                               (GHC.Types.Int, GHC.Types.Int) ->
                    tpl)
                     `cast`
                   (<Data.Vector.Unboxed.Base.Vector (GHC.Types.Int, GHC.Types.Int)>_R
                    ->_R Trans
                             (Sym (MoveTypes.NTCo:R:VectorMove[0]))
                             (Sub (Sym (MoveTypes.TFCo:R:VectorMove[0]))))
                   (let {
                      $dMonad :: GHC.Base.Monad m
                      = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                    } in
                    case eta
                           `cast`
                         (Trans
                              (Sub (Data.Vector.Unboxed.Base.TFCo:R:MutableVector[0]) <Control.Monad.Primitive.PrimState
                                                                                         m>_N <MoveTypes.Move>_N)
                              (Trans
                                   (Sub (MoveTypes.TFCo:R:MVectorsMove[0]
                                             <Control.Monad.Primitive.PrimState m>_N))
                                   (Trans
                                        (MoveTypes.NTCo:R:MVectorsMove[0]
                                             <Control.Monad.Primitive.PrimState m>_N)
                                        (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,)[0]
                                                  <Control.Monad.Primitive.PrimState m>_N
                                                  <GHC.Types.Int>_N
                                                  <GHC.Types.Int>_N))))) of wild { Data.Vector.Unboxed.Base.MV_2 dt as bs ->
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (Data.Vector.Unboxed.Base.Vector GHC.Types.Int)
                      @ (Data.Vector.Unboxed.Base.Vector (GHC.Types.Int, GHC.Types.Int))
                      (GHC.Base.liftM
                         @ (Data.Vector.Primitive.Vector GHC.Types.Int)
                         @ (Data.Vector.Unboxed.Base.Vector GHC.Types.Int)
                         @ m
                         (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                         (\ tpl :: Data.Vector.Primitive.Vector GHC.Types.Int -> tpl)
                           `cast`
                         (<Data.Vector.Primitive.Vector GHC.Types.Int>_R
                          ->_R Trans
                                   (Sym (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0]))
                                   (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))))
                         (case as
                                 `cast`
                               (Trans
                                    (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                              <Control.Monad.Primitive.PrimState m>_N))
                                    (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                         <Control.Monad.Primitive.PrimState
                                            m>_N)) of wild1 { Data.Vector.Primitive.Mutable.MVector dt1 dt2 dt3 ->
                          GHC.Base.liftM
                            @ Data.Primitive.ByteArray.ByteArray
                            @ (Data.Vector.Primitive.Vector GHC.Types.Int)
                            @ m
                            (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                            (Data.Vector.Primitive.$WVector
                               @ GHC.Types.Int
                               (GHC.Types.I# dt1)
                               (GHC.Types.I# dt2))
                            (Control.Monad.Primitive.primitive
                               @ m
                               $dPrimMonad
                               @ Data.Primitive.ByteArray.ByteArray
                               (\ s# :: GHC.Prim.State#
                                          (Control.Monad.Primitive.PrimState m)[OneShot] ->
                                case GHC.Prim.unsafeFreezeByteArray#
                                       @ (Control.Monad.Primitive.PrimState m)
                                       dt3
                                       s# of ds1 { (#,#) ipv ipv1 ->
                                (# ipv, Data.Primitive.ByteArray.ByteArray ipv1 #) })) }))
                      (\ as' :: Data.Vector.Unboxed.Base.Vector GHC.Types.Int ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (Data.Vector.Unboxed.Base.Vector GHC.Types.Int)
                         @ (Data.Vector.Unboxed.Base.Vector (GHC.Types.Int, GHC.Types.Int))
                         (GHC.Base.liftM
                            @ (Data.Vector.Primitive.Vector GHC.Types.Int)
                            @ (Data.Vector.Unboxed.Base.Vector GHC.Types.Int)
                            @ m
                            (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                            (\ tpl :: Data.Vector.Primitive.Vector GHC.Types.Int -> tpl)
                              `cast`
                            (<Data.Vector.Primitive.Vector GHC.Types.Int>_R
                             ->_R Trans
                                      (Sym (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0]))
                                      (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))))
                            (case bs
                                    `cast`
                                  (Trans
                                       (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                 <Control.Monad.Primitive.PrimState m>_N))
                                       (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                            <Control.Monad.Primitive.PrimState
                                               m>_N)) of wild1 { Data.Vector.Primitive.Mutable.MVector dt1 dt2 dt3 ->
                             GHC.Base.liftM
                               @ Data.Primitive.ByteArray.ByteArray
                               @ (Data.Vector.Primitive.Vector GHC.Types.Int)
                               @ m
                               (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                               (Data.Vector.Primitive.$WVector
                                  @ GHC.Types.Int
                                  (GHC.Types.I# dt1)
                                  (GHC.Types.I# dt2))
                               (Control.Monad.Primitive.primitive
                                  @ m
                                  $dPrimMonad
                                  @ Data.Primitive.ByteArray.ByteArray
                                  (\ s# :: GHC.Prim.State#
                                             (Control.Monad.Primitive.PrimState m)[OneShot] ->
                                   case GHC.Prim.unsafeFreezeByteArray#
                                          @ (Control.Monad.Primitive.PrimState m)
                                          dt3
                                          s# of ds1 { (#,#) ipv ipv1 ->
                                   (# ipv, Data.Primitive.ByteArray.ByteArray ipv1 #) })) }))
                         (\ bs' :: Data.Vector.Unboxed.Base.Vector GHC.Types.Int ->
                          GHC.Base.$
                            @ (Data.Vector.Unboxed.Base.Vector (GHC.Types.Int, GHC.Types.Int))
                            @ (m (Data.Vector.Unboxed.Base.Vector
                                    (GHC.Types.Int, GHC.Types.Int)))
                            (GHC.Base.return
                               @ m
                               $dMonad
                               @ (Data.Vector.Unboxed.Base.Vector (GHC.Types.Int, GHC.Types.Int)))
                            (case as'
                                    `cast`
                                  (Trans
                                       (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))
                                       (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0])) of nt { Data.Vector.Primitive.Vector ipv ipv1 ipv2 ->
                             case bs'
                                    `cast`
                                  (Trans
                                       (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))
                                       (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0])) of nt1 { Data.Vector.Primitive.Vector ipv3 ipv4 ipv5 ->
                             (Data.Vector.Unboxed.Base.V_2
                                @ GHC.Types.Int
                                @ GHC.Types.Int
                                dt
                                nt
                                  `cast`
                                (Trans
                                     (Sym (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0]))
                                     (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))))
                                nt1
                                  `cast`
                                (Trans
                                     (Sym (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0]))
                                     (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0])))))
                               `cast`
                             (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:Vector(,)[0]
                                            <GHC.Types.Int>_N <GHC.Types.Int>_N))) } }))) })) -}
f87b40583b48531412a65b59dc7a4f4f
  $fVectorVectorMove_$cbasicUnsafeIndexM ::
    GHC.Base.Monad m =>
    Data.Vector.Unboxed.Base.Vector MoveTypes.Move
    -> GHC.Types.Int -> m MoveTypes.Move
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*U(A,U(U,A,U),U(U,A,U))><L,U(U)>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ (m :: * -> *)
                   $dMonad :: GHC.Base.Monad m
                   ds :: Data.Vector.Unboxed.Base.Vector MoveTypes.Move
                   idx :: GHC.Types.Int ->
                 GHC.Base.liftM
                   @ (Index.Index, Index.Index)
                   @ MoveTypes.Move
                   @ m
                   $dMonad
                   (Data.Tuple.uncurry
                      @ Index.Index
                      @ Index.Index
                      @ MoveTypes.Move
                      MoveTypes.$WMove)
                   (case ds
                           `cast`
                         (Trans
                              (Sub (MoveTypes.TFCo:R:VectorMove[0]))
                              (Trans
                                   (MoveTypes.NTCo:R:VectorMove[0])
                                   (Sub (Data.Vector.Unboxed.Base.TFCo:R:Vector(,)[0]
                                             <GHC.Types.Int>_N
                                             <GHC.Types.Int>_N)))) of wild { Data.Vector.Unboxed.Base.V_2 dt as bs ->
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ GHC.Types.Int
                      @ (GHC.Types.Int, GHC.Types.Int)
                      (case as
                              `cast`
                            (Trans
                                 (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))
                                 (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0])) of wild1 { Data.Vector.Primitive.Vector dt1 dt2 dt3 ->
                       case GHC.Num.$fNumInt_$c+
                              (GHC.Types.I# dt1)
                              idx of wild2 { GHC.Types.I# i# ->
                       case GHC.Prim.indexIntArray# dt3 i# of wild3 { DEFAULT ->
                       GHC.Base.$!
                         @ GHC.Types.Int
                         @ (m GHC.Types.Int)
                         (GHC.Base.return @ m $dMonad @ GHC.Types.Int)
                         (GHC.Types.I# wild3) } } })
                      (\ a21 :: GHC.Types.Int ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ GHC.Types.Int
                         @ (GHC.Types.Int, GHC.Types.Int)
                         (case bs
                                 `cast`
                               (Trans
                                    (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))
                                    (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0])) of wild1 { Data.Vector.Primitive.Vector dt1 dt2 dt3 ->
                          case GHC.Num.$fNumInt_$c+
                                 (GHC.Types.I# dt1)
                                 idx of wild2 { GHC.Types.I# i# ->
                          case GHC.Prim.indexIntArray# dt3 i# of wild3 { DEFAULT ->
                          GHC.Base.$!
                            @ GHC.Types.Int
                            @ (m GHC.Types.Int)
                            (GHC.Base.return @ m $dMonad @ GHC.Types.Int)
                            (GHC.Types.I# wild3) } } })
                         (\ b1 :: GHC.Types.Int ->
                          GHC.Base.return
                            @ m
                            $dMonad
                            @ (GHC.Types.Int, GHC.Types.Int)
                            (a21, b1))) })) -}
f87b40583b48531412a65b59dc7a4f4f
  $fVectorVectorMove_$cbasicUnsafeSlice ::
    GHC.Types.Int
    -> GHC.Types.Int
    -> Data.Vector.Unboxed.Base.Vector MoveTypes.Move
    -> Data.Vector.Unboxed.Base.Vector MoveTypes.Move
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,1*U(U)><S,1*U(U)><S(LSS),1*U(A,U(U,A,U),U(U,A,U))>m,
     Inline: INLINE (sat-args=3),
     Unfolding: InlineRule (3, False, False)
                (\ idx :: GHC.Types.Int
                   len :: GHC.Types.Int
                   ds :: Data.Vector.Unboxed.Base.Vector MoveTypes.Move ->
                 case ds
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:VectorMove[0]))
                           (Trans
                                (MoveTypes.NTCo:R:VectorMove[0])
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:Vector(,)[0]
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N)))) of wild { Data.Vector.Unboxed.Base.V_2 dt as bs ->
                 case len of dt1 { GHC.Types.I# dt2 ->
                 case (GHC.Base.$
                         @ (Data.Vector.Primitive.Vector GHC.Types.Int)
                         @ (Data.Vector.Unboxed.Base.Vector GHC.Types.Int)
                         (\ tpl :: Data.Vector.Primitive.Vector GHC.Types.Int -> tpl)
                           `cast`
                         (<Data.Vector.Primitive.Vector GHC.Types.Int>_R
                          ->_R Trans
                                   (Sym (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0]))
                                   (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))))
                         (case as
                                 `cast`
                               (Trans
                                    (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))
                                    (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0])) of wild1 { Data.Vector.Primitive.Vector dt4 dt5 dt6 ->
                          case GHC.Num.$fNumInt_$c+
                                 (GHC.Types.I# dt4)
                                 idx of dt3 { GHC.Types.I# dt7 ->
                          Data.Vector.Primitive.Vector @ GHC.Types.Int dt7 dt2 dt6 } }))
                        `cast`
                      (Trans
                           (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))
                           (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0])) of nt { Data.Vector.Primitive.Vector ipv ipv1 ipv2 ->
                 case (GHC.Base.$
                         @ (Data.Vector.Primitive.Vector GHC.Types.Int)
                         @ (Data.Vector.Unboxed.Base.Vector GHC.Types.Int)
                         (\ tpl :: Data.Vector.Primitive.Vector GHC.Types.Int -> tpl)
                           `cast`
                         (<Data.Vector.Primitive.Vector GHC.Types.Int>_R
                          ->_R Trans
                                   (Sym (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0]))
                                   (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))))
                         (case bs
                                 `cast`
                               (Trans
                                    (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))
                                    (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0])) of wild1 { Data.Vector.Primitive.Vector dt4 dt5 dt6 ->
                          case GHC.Num.$fNumInt_$c+
                                 (GHC.Types.I# dt4)
                                 idx of dt3 { GHC.Types.I# dt7 ->
                          Data.Vector.Primitive.Vector @ GHC.Types.Int dt7 dt2 dt6 } }))
                        `cast`
                      (Trans
                           (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))
                           (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0])) of nt1 { Data.Vector.Primitive.Vector ipv3 ipv4 ipv5 ->
                 (Data.Vector.Unboxed.Base.V_2
                    @ GHC.Types.Int
                    @ GHC.Types.Int
                    dt2
                    nt
                      `cast`
                    (Trans
                         (Sym (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0]))
                         (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))))
                    nt1
                      `cast`
                    (Trans
                         (Sym (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0]))
                         (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0])))))
                   `cast`
                 (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:Vector(,)[0]
                                <GHC.Types.Int>_N <GHC.Types.Int>_N))) } } } })
                  `cast`
                (<GHC.Types.Int>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R <Data.Vector.Unboxed.Base.Vector MoveTypes.Move>_R
                 ->_R Trans
                          (Sym (MoveTypes.NTCo:R:VectorMove[0]))
                          (Sub (Sym (MoveTypes.TFCo:R:VectorMove[0])))) -}
f87b40583b48531412a65b59dc7a4f4f
  $fVectorVectorMove_$cbasicUnsafeThaw ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Unboxed.Base.Vector MoveTypes.Move
    -> m (Data.Vector.Generic.Base.Mutable
            Data.Vector.Unboxed.Base.Vector
            (Control.Monad.Primitive.PrimState m)
            MoveTypes.Move)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),U(U,C(U))><L,1*U(U,U(U,U,U),U(U,U,U))>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   eta :: Data.Vector.Unboxed.Base.Vector MoveTypes.Move ->
                 GHC.Base.liftM
                   @ (Data.Vector.Unboxed.Base.MVector
                        (Control.Monad.Primitive.PrimState m)
                        (GHC.Types.Int, GHC.Types.Int))
                   @ (Data.Vector.Unboxed.Base.MVector
                        (Control.Monad.Primitive.PrimState m) MoveTypes.Move)
                   @ m
                   (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                   (\ tpl :: Data.Vector.Unboxed.Base.MVector
                               (Control.Monad.Primitive.PrimState m)
                               (GHC.Types.Int, GHC.Types.Int) ->
                    tpl)
                     `cast`
                   (<Data.Vector.Unboxed.Base.MVector
                       (Control.Monad.Primitive.PrimState m)
                       (GHC.Types.Int, GHC.Types.Int)>_R
                    ->_R Trans
                             (Sym (MoveTypes.NTCo:R:MVectorsMove[0]
                                       <Control.Monad.Primitive.PrimState m>_N))
                             (Sub (Sym (MoveTypes.TFCo:R:MVectorsMove[0]
                                            <Control.Monad.Primitive.PrimState m>_N))))
                   (let {
                      $dMonad :: GHC.Base.Monad m
                      = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                    } in
                    case eta
                           `cast`
                         (Trans
                              (Sub (MoveTypes.TFCo:R:VectorMove[0]))
                              (Trans
                                   (MoveTypes.NTCo:R:VectorMove[0])
                                   (Sub (Data.Vector.Unboxed.Base.TFCo:R:Vector(,)[0]
                                             <GHC.Types.Int>_N
                                             <GHC.Types.Int>_N)))) of wild { Data.Vector.Unboxed.Base.V_2 dt as bs ->
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                      @ (Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m)
                           (GHC.Types.Int, GHC.Types.Int))
                      (GHC.Base.liftM
                         @ (Data.Vector.Primitive.Mutable.MVector
                              (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                         @ (Data.Vector.Unboxed.Base.MVector
                              (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                         @ m
                         (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                         (\ tpl :: Data.Vector.Primitive.Mutable.MVector
                                     (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                          tpl)
                           `cast`
                         (<Data.Vector.Primitive.Mutable.MVector
                             (Control.Monad.Primitive.PrimState m) GHC.Types.Int>_R
                          ->_R Trans
                                   (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                             <Control.Monad.Primitive.PrimState m>_N))
                                   (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                  <Control.Monad.Primitive.PrimState m>_N))))
                         (case as
                                 `cast`
                               (Trans
                                    (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))
                                    (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0])) of wild1 { Data.Vector.Primitive.Vector dt1 dt2 dt3 ->
                          GHC.Base.liftM
                            @ (Data.Primitive.ByteArray.MutableByteArray
                                 (Control.Monad.Primitive.PrimState m))
                            @ (Data.Vector.Primitive.Mutable.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                            @ m
                            (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                            (Data.Vector.Primitive.Mutable.$WMVector
                               @ (Control.Monad.Primitive.PrimState m)
                               @ GHC.Types.Int
                               (GHC.Types.I# dt1)
                               (GHC.Types.I# dt2))
                            (Control.Monad.Primitive.primitive
                               @ m
                               $dPrimMonad
                               @ (Data.Primitive.ByteArray.MutableByteArray
                                    (Control.Monad.Primitive.PrimState m))
                               (\ s# :: GHC.Prim.State#
                                          (Control.Monad.Primitive.PrimState m)[OneShot] ->
                                (# s#,
                                   Data.Primitive.ByteArray.MutableByteArray
                                     @ (Control.Monad.Primitive.PrimState m)
                                     dt3
                                       `cast`
                                     (UnivCo mkUnsafeCo representational GHC.Prim.ByteArray# (GHC.Prim.MutableByteArray#
                                                                                                (Control.Monad.Primitive.PrimState
                                                                                                   m))) #))) }))
                      (\ as' :: Data.Vector.Unboxed.Base.MVector
                                  (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (Data.Vector.Unboxed.Base.MVector
                              (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                         @ (Data.Vector.Unboxed.Base.MVector
                              (Control.Monad.Primitive.PrimState m)
                              (GHC.Types.Int, GHC.Types.Int))
                         (GHC.Base.liftM
                            @ (Data.Vector.Primitive.Mutable.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                            @ (Data.Vector.Unboxed.Base.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                            @ m
                            (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                            (\ tpl :: Data.Vector.Primitive.Mutable.MVector
                                        (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                             tpl)
                              `cast`
                            (<Data.Vector.Primitive.Mutable.MVector
                                (Control.Monad.Primitive.PrimState m) GHC.Types.Int>_R
                             ->_R Trans
                                      (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                                <Control.Monad.Primitive.PrimState m>_N))
                                      (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                     <Control.Monad.Primitive.PrimState m>_N))))
                            (case bs
                                    `cast`
                                  (Trans
                                       (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))
                                       (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0])) of wild1 { Data.Vector.Primitive.Vector dt1 dt2 dt3 ->
                             GHC.Base.liftM
                               @ (Data.Primitive.ByteArray.MutableByteArray
                                    (Control.Monad.Primitive.PrimState m))
                               @ (Data.Vector.Primitive.Mutable.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                               @ m
                               (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                               (Data.Vector.Primitive.Mutable.$WMVector
                                  @ (Control.Monad.Primitive.PrimState m)
                                  @ GHC.Types.Int
                                  (GHC.Types.I# dt1)
                                  (GHC.Types.I# dt2))
                               (Control.Monad.Primitive.primitive
                                  @ m
                                  $dPrimMonad
                                  @ (Data.Primitive.ByteArray.MutableByteArray
                                       (Control.Monad.Primitive.PrimState m))
                                  (\ s# :: GHC.Prim.State#
                                             (Control.Monad.Primitive.PrimState m)[OneShot] ->
                                   (# s#,
                                      Data.Primitive.ByteArray.MutableByteArray
                                        @ (Control.Monad.Primitive.PrimState m)
                                        dt3
                                          `cast`
                                        (UnivCo mkUnsafeCo representational GHC.Prim.ByteArray# (GHC.Prim.MutableByteArray#
                                                                                                   (Control.Monad.Primitive.PrimState
                                                                                                      m))) #))) }))
                         (\ bs' :: Data.Vector.Unboxed.Base.MVector
                                     (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                          GHC.Base.$
                            @ (Data.Vector.Unboxed.Base.MVector
                                 (Control.Monad.Primitive.PrimState m)
                                 (GHC.Types.Int, GHC.Types.Int))
                            @ (m (Data.Vector.Unboxed.Base.MVector
                                    (Control.Monad.Primitive.PrimState m)
                                    (GHC.Types.Int, GHC.Types.Int)))
                            (GHC.Base.return
                               @ m
                               $dMonad
                               @ (Data.Vector.Unboxed.Base.MVector
                                    (Control.Monad.Primitive.PrimState m)
                                    (GHC.Types.Int, GHC.Types.Int)))
                            (case as'
                                    `cast`
                                  (Trans
                                       (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                 <Control.Monad.Primitive.PrimState m>_N))
                                       (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                            <Control.Monad.Primitive.PrimState
                                               m>_N)) of nt { Data.Vector.Primitive.Mutable.MVector ipv ipv1 ipv2 ->
                             case bs'
                                    `cast`
                                  (Trans
                                       (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                 <Control.Monad.Primitive.PrimState m>_N))
                                       (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                            <Control.Monad.Primitive.PrimState
                                               m>_N)) of nt1 { Data.Vector.Primitive.Mutable.MVector ipv3 ipv4 ipv5 ->
                             (Data.Vector.Unboxed.Base.MV_2
                                @ (Control.Monad.Primitive.PrimState m)
                                @ GHC.Types.Int
                                @ GHC.Types.Int
                                dt
                                nt
                                  `cast`
                                (Trans
                                     (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                               <Control.Monad.Primitive.PrimState m>_N))
                                     (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                    <Control.Monad.Primitive.PrimState m>_N))))
                                nt1
                                  `cast`
                                (Trans
                                     (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                               <Control.Monad.Primitive.PrimState m>_N))
                                     (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                    <Control.Monad.Primitive.PrimState m>_N)))))
                               `cast`
                             (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,)[0]
                                            <Control.Monad.Primitive.PrimState m>_N
                                            <GHC.Types.Int>_N
                                            <GHC.Types.Int>_N))) } }))) }))
                  `cast`
                (forall (m :: * -> *).
                 <Control.Monad.Primitive.PrimMonad m>_R
                 ->_R <Data.Vector.Unboxed.Base.Vector MoveTypes.Move>_R
                 ->_R <m>_R (Sym (Data.Vector.Unboxed.Base.TFCo:R:MutableVector[0]) <Control.Monad.Primitive.PrimState
                                                                                       m>_N <MoveTypes.Move>_N)) -}
f87b40583b48531412a65b59dc7a4f4f
  $fVectorVectorMove_$celemseq ::
    Data.Vector.Unboxed.Base.Vector MoveTypes.Move
    -> MoveTypes.Move -> b -> b
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><S,1*H><S,1*U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ b
                   ds :: Data.Vector.Unboxed.Base.Vector MoveTypes.Move
                   val :: MoveTypes.Move ->
                 case val of wild { MoveTypes.Move dt dt1 ->
                 let {
                   f :: b -> b = GHC.Prim.seq @ GHC.Types.Int @ b (GHC.Types.I# dt)
                 } in
                 let {
                   g :: b -> b = GHC.Prim.seq @ GHC.Types.Int @ b (GHC.Types.I# dt1)
                 } in
                 \ x :: b -> f (g x) }) -}
7974ea60cb767d2cccb374fcf473a0ab
  $fVectorVectorPromotion ::
    Data.Vector.Generic.Base.Vector
      Data.Vector.Unboxed.Base.Vector MoveTypes.Promotion
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Vector.Unboxed.Base.Vector
                  @ MoveTypes.Promotion
                  MoveTypes.$fMVectorMVectorPromotion
                    `cast`
                  (Data.Vector.Generic.Mutable.Base.MVector
                     (Sym (Data.Vector.Unboxed.Base.TFCo:R:MutableVector[0]))
                     <MoveTypes.Promotion>_N)_R
                  MoveTypes.$fVectorVectorPromotion_$cbasicUnsafeFreeze
                  MoveTypes.$fVectorVectorPromotion_$cbasicUnsafeThaw
                  MoveTypes.$fVectorVectorPromotion_$cbasicLength
                  MoveTypes.$fVectorVectorPromotion_$cbasicUnsafeSlice
                  MoveTypes.$fVectorVectorPromotion_$cbasicUnsafeIndexM
                  MoveTypes.$fVectorVectorPromotion_$cbasicUnsafeCopy
                  MoveTypes.$fVectorVectorPromotion_$celemseq -}
7974ea60cb767d2cccb374fcf473a0ab
  $fVectorVectorPromotion_$cbasicLength ::
    Data.Vector.Unboxed.Base.Vector MoveTypes.Promotion
    -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LSSS),1*U(U,1*H,1*H,1*H)>m,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ ds :: Data.Vector.Unboxed.Base.Vector MoveTypes.Promotion ->
                 case ds
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:VectorPromotion[0]))
                           (Trans
                                (MoveTypes.NTCo:R:VectorPromotion[0])
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:Vector(,,)[0]
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Word.Word8>_N)))) of wild { Data.Vector.Unboxed.Base.V_3 dt ds1 ds2 ds3 ->
                 GHC.Types.I# dt }) -}
7974ea60cb767d2cccb374fcf473a0ab
  $fVectorVectorPromotion_$cbasicUnsafeCopy ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Generic.Base.Mutable
      Data.Vector.Unboxed.Base.Vector
      (Control.Monad.Primitive.PrimState m)
      MoveTypes.Promotion
    -> Data.Vector.Unboxed.Base.Vector MoveTypes.Promotion -> m ()
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(SL),U(1*U,C(U))><S(LSSS),1*U(A,U(U,U,U),U(U,U,U),U(U,U,U))><S(LSSS),1*U(A,U(U,A,U),U(U,A,U),U(U,A,U))>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   ds :: Data.Vector.Generic.Base.Mutable
                           Data.Vector.Unboxed.Base.Vector
                           (Control.Monad.Primitive.PrimState m)
                           MoveTypes.Promotion
                   ds1 :: Data.Vector.Unboxed.Base.Vector MoveTypes.Promotion ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                 } in
                 case ds
                        `cast`
                      (Trans
                           (Sub (Data.Vector.Unboxed.Base.TFCo:R:MutableVector[0]) <Control.Monad.Primitive.PrimState
                                                                                      m>_N <MoveTypes.Promotion>_N)
                           (Trans
                                (Sub (MoveTypes.TFCo:R:MVectorsPromotion[0]
                                          <Control.Monad.Primitive.PrimState m>_N))
                                (Trans
                                     (MoveTypes.NTCo:R:MVectorsPromotion[0]
                                          <Control.Monad.Primitive.PrimState m>_N)
                                     (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,,)[0]
                                               <Control.Monad.Primitive.PrimState m>_N
                                               <GHC.Types.Int>_N
                                               <GHC.Types.Int>_N
                                               <GHC.Word.Word8>_N))))) of wild { Data.Vector.Unboxed.Base.MV_3 dt as1 bs1 cs1 ->
                 case ds1
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:VectorPromotion[0]))
                           (Trans
                                (MoveTypes.NTCo:R:VectorPromotion[0])
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:Vector(,,)[0]
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Word.Word8>_N)))) of wild1 { Data.Vector.Unboxed.Base.V_3 dt1 as2 bs2 cs2 ->
                 GHC.Base.>>
                   @ m
                   $dMonad
                   @ ()
                   @ ()
                   (Data.Vector.Unboxed.Base.$fVectorVectorInt_$cbasicUnsafeCopy
                      @ m
                      $dPrimMonad
                      as1
                        `cast`
                      (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MutableVector[0])) <Control.Monad.Primitive.PrimState
                                                                                       m>_N <GHC.Types.Int>_N)
                      as2)
                   (GHC.Base.>>
                      @ m
                      $dMonad
                      @ ()
                      @ ()
                      (Data.Vector.Unboxed.Base.$fVectorVectorInt_$cbasicUnsafeCopy
                         @ m
                         $dPrimMonad
                         bs1
                           `cast`
                         (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MutableVector[0])) <Control.Monad.Primitive.PrimState
                                                                                          m>_N <GHC.Types.Int>_N)
                         bs2)
                      (Data.Vector.Unboxed.Base.$fVectorVectorWord8_$cbasicUnsafeCopy
                         @ m
                         $dPrimMonad
                         cs1
                           `cast`
                         (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MutableVector[0])) <Control.Monad.Primitive.PrimState
                                                                                          m>_N <GHC.Word.Word8>_N)
                         cs2)) } }) -}
7974ea60cb767d2cccb374fcf473a0ab
  $fVectorVectorPromotion_$cbasicUnsafeFreeze ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Generic.Base.Mutable
      Data.Vector.Unboxed.Base.Vector
      (Control.Monad.Primitive.PrimState m)
      MoveTypes.Promotion
    -> m (Data.Vector.Unboxed.Base.Vector MoveTypes.Promotion)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),U(U,C(U))><L,1*U(U,U(U,U,U),U(U,U,U),U(U,U,U))>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   eta :: Data.Vector.Generic.Base.Mutable
                            Data.Vector.Unboxed.Base.Vector
                            (Control.Monad.Primitive.PrimState m)
                            MoveTypes.Promotion ->
                 GHC.Base.liftM
                   @ (Data.Vector.Unboxed.Base.Vector
                        (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8))
                   @ (Data.Vector.Unboxed.Base.Vector MoveTypes.Promotion)
                   @ m
                   (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                   (\ tpl :: Data.Vector.Unboxed.Base.Vector
                               (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8) ->
                    tpl)
                     `cast`
                   (<Data.Vector.Unboxed.Base.Vector
                       (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8)>_R
                    ->_R Trans
                             (Sym (MoveTypes.NTCo:R:VectorPromotion[0]))
                             (Sub (Sym (MoveTypes.TFCo:R:VectorPromotion[0]))))
                   (let {
                      $dMonad :: GHC.Base.Monad m
                      = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                    } in
                    case eta
                           `cast`
                         (Trans
                              (Sub (Data.Vector.Unboxed.Base.TFCo:R:MutableVector[0]) <Control.Monad.Primitive.PrimState
                                                                                         m>_N <MoveTypes.Promotion>_N)
                              (Trans
                                   (Sub (MoveTypes.TFCo:R:MVectorsPromotion[0]
                                             <Control.Monad.Primitive.PrimState m>_N))
                                   (Trans
                                        (MoveTypes.NTCo:R:MVectorsPromotion[0]
                                             <Control.Monad.Primitive.PrimState m>_N)
                                        (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,,)[0]
                                                  <Control.Monad.Primitive.PrimState m>_N
                                                  <GHC.Types.Int>_N
                                                  <GHC.Types.Int>_N
                                                  <GHC.Word.Word8>_N))))) of wild { Data.Vector.Unboxed.Base.MV_3 dt as bs cs ->
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (Data.Vector.Unboxed.Base.Vector GHC.Types.Int)
                      @ (Data.Vector.Unboxed.Base.Vector
                           (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8))
                      (GHC.Base.liftM
                         @ (Data.Vector.Primitive.Vector GHC.Types.Int)
                         @ (Data.Vector.Unboxed.Base.Vector GHC.Types.Int)
                         @ m
                         (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                         (\ tpl :: Data.Vector.Primitive.Vector GHC.Types.Int -> tpl)
                           `cast`
                         (<Data.Vector.Primitive.Vector GHC.Types.Int>_R
                          ->_R Trans
                                   (Sym (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0]))
                                   (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))))
                         (case as
                                 `cast`
                               (Trans
                                    (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                              <Control.Monad.Primitive.PrimState m>_N))
                                    (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                         <Control.Monad.Primitive.PrimState
                                            m>_N)) of wild1 { Data.Vector.Primitive.Mutable.MVector dt1 dt2 dt3 ->
                          GHC.Base.liftM
                            @ Data.Primitive.ByteArray.ByteArray
                            @ (Data.Vector.Primitive.Vector GHC.Types.Int)
                            @ m
                            (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                            (Data.Vector.Primitive.$WVector
                               @ GHC.Types.Int
                               (GHC.Types.I# dt1)
                               (GHC.Types.I# dt2))
                            (Control.Monad.Primitive.primitive
                               @ m
                               $dPrimMonad
                               @ Data.Primitive.ByteArray.ByteArray
                               (\ s# :: GHC.Prim.State#
                                          (Control.Monad.Primitive.PrimState m)[OneShot] ->
                                case GHC.Prim.unsafeFreezeByteArray#
                                       @ (Control.Monad.Primitive.PrimState m)
                                       dt3
                                       s# of ds1 { (#,#) ipv ipv1 ->
                                (# ipv, Data.Primitive.ByteArray.ByteArray ipv1 #) })) }))
                      (\ as' :: Data.Vector.Unboxed.Base.Vector GHC.Types.Int ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (Data.Vector.Unboxed.Base.Vector GHC.Types.Int)
                         @ (Data.Vector.Unboxed.Base.Vector
                              (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8))
                         (GHC.Base.liftM
                            @ (Data.Vector.Primitive.Vector GHC.Types.Int)
                            @ (Data.Vector.Unboxed.Base.Vector GHC.Types.Int)
                            @ m
                            (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                            (\ tpl :: Data.Vector.Primitive.Vector GHC.Types.Int -> tpl)
                              `cast`
                            (<Data.Vector.Primitive.Vector GHC.Types.Int>_R
                             ->_R Trans
                                      (Sym (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0]))
                                      (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))))
                            (case bs
                                    `cast`
                                  (Trans
                                       (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                 <Control.Monad.Primitive.PrimState m>_N))
                                       (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                            <Control.Monad.Primitive.PrimState
                                               m>_N)) of wild1 { Data.Vector.Primitive.Mutable.MVector dt1 dt2 dt3 ->
                             GHC.Base.liftM
                               @ Data.Primitive.ByteArray.ByteArray
                               @ (Data.Vector.Primitive.Vector GHC.Types.Int)
                               @ m
                               (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                               (Data.Vector.Primitive.$WVector
                                  @ GHC.Types.Int
                                  (GHC.Types.I# dt1)
                                  (GHC.Types.I# dt2))
                               (Control.Monad.Primitive.primitive
                                  @ m
                                  $dPrimMonad
                                  @ Data.Primitive.ByteArray.ByteArray
                                  (\ s# :: GHC.Prim.State#
                                             (Control.Monad.Primitive.PrimState m)[OneShot] ->
                                   case GHC.Prim.unsafeFreezeByteArray#
                                          @ (Control.Monad.Primitive.PrimState m)
                                          dt3
                                          s# of ds1 { (#,#) ipv ipv1 ->
                                   (# ipv, Data.Primitive.ByteArray.ByteArray ipv1 #) })) }))
                         (\ bs' :: Data.Vector.Unboxed.Base.Vector GHC.Types.Int ->
                          GHC.Base.>>=
                            @ m
                            $dMonad
                            @ (Data.Vector.Unboxed.Base.Vector GHC.Word.Word8)
                            @ (Data.Vector.Unboxed.Base.Vector
                                 (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8))
                            (GHC.Base.liftM
                               @ (Data.Vector.Primitive.Vector GHC.Word.Word8)
                               @ (Data.Vector.Unboxed.Base.Vector GHC.Word.Word8)
                               @ m
                               (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                               (\ tpl :: Data.Vector.Primitive.Vector GHC.Word.Word8 -> tpl)
                                 `cast`
                               (<Data.Vector.Primitive.Vector GHC.Word.Word8>_R
                                ->_R Trans
                                         (Sym (Data.Vector.Unboxed.Base.NTCo:R:VectorWord8[0]))
                                         (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:VectorWord8[0]))))
                               (case cs
                                       `cast`
                                     (Trans
                                          (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                                    <Control.Monad.Primitive.PrimState m>_N))
                                          (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                               <Control.Monad.Primitive.PrimState
                                                  m>_N)) of wild1 { Data.Vector.Primitive.Mutable.MVector dt1 dt2 dt3 ->
                                GHC.Base.liftM
                                  @ Data.Primitive.ByteArray.ByteArray
                                  @ (Data.Vector.Primitive.Vector GHC.Word.Word8)
                                  @ m
                                  (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                                  (Data.Vector.Primitive.$WVector
                                     @ GHC.Word.Word8
                                     (GHC.Types.I# dt1)
                                     (GHC.Types.I# dt2))
                                  (Control.Monad.Primitive.primitive
                                     @ m
                                     $dPrimMonad
                                     @ Data.Primitive.ByteArray.ByteArray
                                     (\ s# :: GHC.Prim.State#
                                                (Control.Monad.Primitive.PrimState m)[OneShot] ->
                                      case GHC.Prim.unsafeFreezeByteArray#
                                             @ (Control.Monad.Primitive.PrimState m)
                                             dt3
                                             s# of ds1 { (#,#) ipv ipv1 ->
                                      (# ipv, Data.Primitive.ByteArray.ByteArray ipv1 #) })) }))
                            (\ cs' :: Data.Vector.Unboxed.Base.Vector GHC.Word.Word8 ->
                             GHC.Base.$
                               @ (Data.Vector.Unboxed.Base.Vector
                                    (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8))
                               @ (m (Data.Vector.Unboxed.Base.Vector
                                       (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8)))
                               (GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (Data.Vector.Unboxed.Base.Vector
                                       (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8)))
                               (case as'
                                       `cast`
                                     (Trans
                                          (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))
                                          (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0])) of nt { Data.Vector.Primitive.Vector ipv ipv1 ipv2 ->
                                case bs'
                                       `cast`
                                     (Trans
                                          (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))
                                          (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0])) of nt1 { Data.Vector.Primitive.Vector ipv3 ipv4 ipv5 ->
                                case cs'
                                       `cast`
                                     (Trans
                                          (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorWord8[0]))
                                          (Data.Vector.Unboxed.Base.NTCo:R:VectorWord8[0])) of nt2 { Data.Vector.Primitive.Vector ipv6 ipv7 ipv8 ->
                                (Data.Vector.Unboxed.Base.V_3
                                   @ GHC.Types.Int
                                   @ GHC.Types.Int
                                   @ GHC.Word.Word8
                                   dt
                                   nt
                                     `cast`
                                   (Trans
                                        (Sym (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0]))
                                        (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))))
                                   nt1
                                     `cast`
                                   (Trans
                                        (Sym (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0]))
                                        (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))))
                                   nt2
                                     `cast`
                                   (Trans
                                        (Sym (Data.Vector.Unboxed.Base.NTCo:R:VectorWord8[0]))
                                        (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:VectorWord8[0])))))
                                  `cast`
                                (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:Vector(,,)[0]
                                               <GHC.Types.Int>_N
                                               <GHC.Types.Int>_N
                                               <GHC.Word.Word8>_N))) } } })))) })) -}
7974ea60cb767d2cccb374fcf473a0ab
  $fVectorVectorPromotion_$cbasicUnsafeIndexM ::
    GHC.Base.Monad m =>
    Data.Vector.Unboxed.Base.Vector MoveTypes.Promotion
    -> GHC.Types.Int -> m MoveTypes.Promotion
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*U(A,U(U,A,U),U(U,A,U),U(U,A,U))><L,U(U)>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ (m :: * -> *)
                   $dMonad :: GHC.Base.Monad m
                   ds :: Data.Vector.Unboxed.Base.Vector MoveTypes.Promotion
                   idx :: GHC.Types.Int ->
                 GHC.Base.liftM
                   @ (Index.Index, Index.Index, GHC.Word.Word8)
                   @ MoveTypes.Promotion
                   @ m
                   $dMonad
                   (\ ds1 :: (Index.Index, Index.Index, GHC.Word.Word8) ->
                    case ds1 of wild { (,,) f t w ->
                    case f of dt { GHC.Types.I# dt1 ->
                    case t of dt2 { GHC.Types.I# dt3 ->
                    case w of dt4 { GHC.Word.W8# dt5 ->
                    MoveTypes.Promotion dt1 dt3 dt5 } } } })
                   (case ds
                           `cast`
                         (Trans
                              (Sub (MoveTypes.TFCo:R:VectorPromotion[0]))
                              (Trans
                                   (MoveTypes.NTCo:R:VectorPromotion[0])
                                   (Sub (Data.Vector.Unboxed.Base.TFCo:R:Vector(,,)[0]
                                             <GHC.Types.Int>_N
                                             <GHC.Types.Int>_N
                                             <GHC.Word.Word8>_N)))) of wild { Data.Vector.Unboxed.Base.V_3 dt as bs cs ->
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ GHC.Types.Int
                      @ (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8)
                      (case as
                              `cast`
                            (Trans
                                 (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))
                                 (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0])) of wild1 { Data.Vector.Primitive.Vector dt1 dt2 dt3 ->
                       case GHC.Num.$fNumInt_$c+
                              (GHC.Types.I# dt1)
                              idx of wild2 { GHC.Types.I# i# ->
                       case GHC.Prim.indexIntArray# dt3 i# of wild3 { DEFAULT ->
                       GHC.Base.$!
                         @ GHC.Types.Int
                         @ (m GHC.Types.Int)
                         (GHC.Base.return @ m $dMonad @ GHC.Types.Int)
                         (GHC.Types.I# wild3) } } })
                      (\ a21 :: GHC.Types.Int ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ GHC.Types.Int
                         @ (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8)
                         (case bs
                                 `cast`
                               (Trans
                                    (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))
                                    (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0])) of wild1 { Data.Vector.Primitive.Vector dt1 dt2 dt3 ->
                          case GHC.Num.$fNumInt_$c+
                                 (GHC.Types.I# dt1)
                                 idx of wild2 { GHC.Types.I# i# ->
                          case GHC.Prim.indexIntArray# dt3 i# of wild3 { DEFAULT ->
                          GHC.Base.$!
                            @ GHC.Types.Int
                            @ (m GHC.Types.Int)
                            (GHC.Base.return @ m $dMonad @ GHC.Types.Int)
                            (GHC.Types.I# wild3) } } })
                         (\ b1 :: GHC.Types.Int ->
                          GHC.Base.>>=
                            @ m
                            $dMonad
                            @ GHC.Word.Word8
                            @ (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8)
                            (case cs
                                    `cast`
                                  (Trans
                                       (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorWord8[0]))
                                       (Data.Vector.Unboxed.Base.NTCo:R:VectorWord8[0])) of wild1 { Data.Vector.Primitive.Vector dt1 dt2 dt3 ->
                             case GHC.Num.$fNumInt_$c+
                                    (GHC.Types.I# dt1)
                                    idx of wild2 { GHC.Types.I# i# ->
                             case GHC.Prim.indexWord8Array# dt3 i# of wild3 { DEFAULT ->
                             GHC.Base.$!
                               @ GHC.Word.Word8
                               @ (m GHC.Word.Word8)
                               (GHC.Base.return @ m $dMonad @ GHC.Word.Word8)
                               (GHC.Word.W8# wild3) } } })
                            (\ c1 :: GHC.Word.Word8 ->
                             GHC.Base.return
                               @ m
                               $dMonad
                               @ (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8)
                               (a21, b1, c1)))) })) -}
7974ea60cb767d2cccb374fcf473a0ab
  $fVectorVectorPromotion_$cbasicUnsafeSlice ::
    GHC.Types.Int
    -> GHC.Types.Int
    -> Data.Vector.Unboxed.Base.Vector MoveTypes.Promotion
    -> Data.Vector.Unboxed.Base.Vector MoveTypes.Promotion
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,1*U(U)><S,1*U(U)><S(LSSS),1*U(A,U(U,A,U),U(U,A,U),U(U,A,U))>m,
     Inline: INLINE (sat-args=3),
     Unfolding: InlineRule (3, False, False)
                (\ idx :: GHC.Types.Int
                   len :: GHC.Types.Int
                   ds :: Data.Vector.Unboxed.Base.Vector MoveTypes.Promotion ->
                 case ds
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:VectorPromotion[0]))
                           (Trans
                                (MoveTypes.NTCo:R:VectorPromotion[0])
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:Vector(,,)[0]
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Word.Word8>_N)))) of wild { Data.Vector.Unboxed.Base.V_3 dt as bs cs ->
                 case len of dt1 { GHC.Types.I# dt2 ->
                 case (GHC.Base.$
                         @ (Data.Vector.Primitive.Vector GHC.Types.Int)
                         @ (Data.Vector.Unboxed.Base.Vector GHC.Types.Int)
                         (\ tpl :: Data.Vector.Primitive.Vector GHC.Types.Int -> tpl)
                           `cast`
                         (<Data.Vector.Primitive.Vector GHC.Types.Int>_R
                          ->_R Trans
                                   (Sym (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0]))
                                   (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))))
                         (case as
                                 `cast`
                               (Trans
                                    (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))
                                    (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0])) of wild1 { Data.Vector.Primitive.Vector dt4 dt5 dt6 ->
                          case GHC.Num.$fNumInt_$c+
                                 (GHC.Types.I# dt4)
                                 idx of dt3 { GHC.Types.I# dt7 ->
                          Data.Vector.Primitive.Vector @ GHC.Types.Int dt7 dt2 dt6 } }))
                        `cast`
                      (Trans
                           (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))
                           (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0])) of nt { Data.Vector.Primitive.Vector ipv ipv1 ipv2 ->
                 case (GHC.Base.$
                         @ (Data.Vector.Primitive.Vector GHC.Types.Int)
                         @ (Data.Vector.Unboxed.Base.Vector GHC.Types.Int)
                         (\ tpl :: Data.Vector.Primitive.Vector GHC.Types.Int -> tpl)
                           `cast`
                         (<Data.Vector.Primitive.Vector GHC.Types.Int>_R
                          ->_R Trans
                                   (Sym (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0]))
                                   (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))))
                         (case bs
                                 `cast`
                               (Trans
                                    (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))
                                    (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0])) of wild1 { Data.Vector.Primitive.Vector dt4 dt5 dt6 ->
                          case GHC.Num.$fNumInt_$c+
                                 (GHC.Types.I# dt4)
                                 idx of dt3 { GHC.Types.I# dt7 ->
                          Data.Vector.Primitive.Vector @ GHC.Types.Int dt7 dt2 dt6 } }))
                        `cast`
                      (Trans
                           (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))
                           (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0])) of nt1 { Data.Vector.Primitive.Vector ipv3 ipv4 ipv5 ->
                 case (GHC.Base.$
                         @ (Data.Vector.Primitive.Vector GHC.Word.Word8)
                         @ (Data.Vector.Unboxed.Base.Vector GHC.Word.Word8)
                         (\ tpl :: Data.Vector.Primitive.Vector GHC.Word.Word8 -> tpl)
                           `cast`
                         (<Data.Vector.Primitive.Vector GHC.Word.Word8>_R
                          ->_R Trans
                                   (Sym (Data.Vector.Unboxed.Base.NTCo:R:VectorWord8[0]))
                                   (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:VectorWord8[0]))))
                         (case cs
                                 `cast`
                               (Trans
                                    (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorWord8[0]))
                                    (Data.Vector.Unboxed.Base.NTCo:R:VectorWord8[0])) of wild1 { Data.Vector.Primitive.Vector dt4 dt5 dt6 ->
                          case GHC.Num.$fNumInt_$c+
                                 (GHC.Types.I# dt4)
                                 idx of dt3 { GHC.Types.I# dt7 ->
                          Data.Vector.Primitive.Vector @ GHC.Word.Word8 dt7 dt2 dt6 } }))
                        `cast`
                      (Trans
                           (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorWord8[0]))
                           (Data.Vector.Unboxed.Base.NTCo:R:VectorWord8[0])) of nt2 { Data.Vector.Primitive.Vector ipv6 ipv7 ipv8 ->
                 (Data.Vector.Unboxed.Base.V_3
                    @ GHC.Types.Int
                    @ GHC.Types.Int
                    @ GHC.Word.Word8
                    dt2
                    nt
                      `cast`
                    (Trans
                         (Sym (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0]))
                         (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))))
                    nt1
                      `cast`
                    (Trans
                         (Sym (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0]))
                         (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))))
                    nt2
                      `cast`
                    (Trans
                         (Sym (Data.Vector.Unboxed.Base.NTCo:R:VectorWord8[0]))
                         (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:VectorWord8[0])))))
                   `cast`
                 (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:Vector(,,)[0]
                                <GHC.Types.Int>_N
                                <GHC.Types.Int>_N
                                <GHC.Word.Word8>_N))) } } } } })
                  `cast`
                (<GHC.Types.Int>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R <Data.Vector.Unboxed.Base.Vector MoveTypes.Promotion>_R
                 ->_R Trans
                          (Sym (MoveTypes.NTCo:R:VectorPromotion[0]))
                          (Sub (Sym (MoveTypes.TFCo:R:VectorPromotion[0])))) -}
7974ea60cb767d2cccb374fcf473a0ab
  $fVectorVectorPromotion_$cbasicUnsafeThaw ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Unboxed.Base.Vector MoveTypes.Promotion
    -> m (Data.Vector.Generic.Base.Mutable
            Data.Vector.Unboxed.Base.Vector
            (Control.Monad.Primitive.PrimState m)
            MoveTypes.Promotion)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),U(U,C(U))><L,1*U(U,U(U,U,U),U(U,U,U),U(U,U,U))>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   eta :: Data.Vector.Unboxed.Base.Vector MoveTypes.Promotion ->
                 GHC.Base.liftM
                   @ (Data.Vector.Unboxed.Base.MVector
                        (Control.Monad.Primitive.PrimState m)
                        (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8))
                   @ (Data.Vector.Unboxed.Base.MVector
                        (Control.Monad.Primitive.PrimState m) MoveTypes.Promotion)
                   @ m
                   (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                   (\ tpl :: Data.Vector.Unboxed.Base.MVector
                               (Control.Monad.Primitive.PrimState m)
                               (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8) ->
                    tpl)
                     `cast`
                   (<Data.Vector.Unboxed.Base.MVector
                       (Control.Monad.Primitive.PrimState m)
                       (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8)>_R
                    ->_R Trans
                             (Sym (MoveTypes.NTCo:R:MVectorsPromotion[0]
                                       <Control.Monad.Primitive.PrimState m>_N))
                             (Sub (Sym (MoveTypes.TFCo:R:MVectorsPromotion[0]
                                            <Control.Monad.Primitive.PrimState m>_N))))
                   (let {
                      $dMonad :: GHC.Base.Monad m
                      = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                    } in
                    case eta
                           `cast`
                         (Trans
                              (Sub (MoveTypes.TFCo:R:VectorPromotion[0]))
                              (Trans
                                   (MoveTypes.NTCo:R:VectorPromotion[0])
                                   (Sub (Data.Vector.Unboxed.Base.TFCo:R:Vector(,,)[0]
                                             <GHC.Types.Int>_N
                                             <GHC.Types.Int>_N
                                             <GHC.Word.Word8>_N)))) of wild { Data.Vector.Unboxed.Base.V_3 dt as bs cs ->
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                      @ (Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m)
                           (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8))
                      (GHC.Base.liftM
                         @ (Data.Vector.Primitive.Mutable.MVector
                              (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                         @ (Data.Vector.Unboxed.Base.MVector
                              (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                         @ m
                         (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                         (\ tpl :: Data.Vector.Primitive.Mutable.MVector
                                     (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                          tpl)
                           `cast`
                         (<Data.Vector.Primitive.Mutable.MVector
                             (Control.Monad.Primitive.PrimState m) GHC.Types.Int>_R
                          ->_R Trans
                                   (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                             <Control.Monad.Primitive.PrimState m>_N))
                                   (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                  <Control.Monad.Primitive.PrimState m>_N))))
                         (case as
                                 `cast`
                               (Trans
                                    (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))
                                    (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0])) of wild1 { Data.Vector.Primitive.Vector dt1 dt2 dt3 ->
                          GHC.Base.liftM
                            @ (Data.Primitive.ByteArray.MutableByteArray
                                 (Control.Monad.Primitive.PrimState m))
                            @ (Data.Vector.Primitive.Mutable.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                            @ m
                            (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                            (Data.Vector.Primitive.Mutable.$WMVector
                               @ (Control.Monad.Primitive.PrimState m)
                               @ GHC.Types.Int
                               (GHC.Types.I# dt1)
                               (GHC.Types.I# dt2))
                            (Control.Monad.Primitive.primitive
                               @ m
                               $dPrimMonad
                               @ (Data.Primitive.ByteArray.MutableByteArray
                                    (Control.Monad.Primitive.PrimState m))
                               (\ s# :: GHC.Prim.State#
                                          (Control.Monad.Primitive.PrimState m)[OneShot] ->
                                (# s#,
                                   Data.Primitive.ByteArray.MutableByteArray
                                     @ (Control.Monad.Primitive.PrimState m)
                                     dt3
                                       `cast`
                                     (UnivCo mkUnsafeCo representational GHC.Prim.ByteArray# (GHC.Prim.MutableByteArray#
                                                                                                (Control.Monad.Primitive.PrimState
                                                                                                   m))) #))) }))
                      (\ as' :: Data.Vector.Unboxed.Base.MVector
                                  (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (Data.Vector.Unboxed.Base.MVector
                              (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                         @ (Data.Vector.Unboxed.Base.MVector
                              (Control.Monad.Primitive.PrimState m)
                              (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8))
                         (GHC.Base.liftM
                            @ (Data.Vector.Primitive.Mutable.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                            @ (Data.Vector.Unboxed.Base.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                            @ m
                            (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                            (\ tpl :: Data.Vector.Primitive.Mutable.MVector
                                        (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                             tpl)
                              `cast`
                            (<Data.Vector.Primitive.Mutable.MVector
                                (Control.Monad.Primitive.PrimState m) GHC.Types.Int>_R
                             ->_R Trans
                                      (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                                <Control.Monad.Primitive.PrimState m>_N))
                                      (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                     <Control.Monad.Primitive.PrimState m>_N))))
                            (case bs
                                    `cast`
                                  (Trans
                                       (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))
                                       (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0])) of wild1 { Data.Vector.Primitive.Vector dt1 dt2 dt3 ->
                             GHC.Base.liftM
                               @ (Data.Primitive.ByteArray.MutableByteArray
                                    (Control.Monad.Primitive.PrimState m))
                               @ (Data.Vector.Primitive.Mutable.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                               @ m
                               (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                               (Data.Vector.Primitive.Mutable.$WMVector
                                  @ (Control.Monad.Primitive.PrimState m)
                                  @ GHC.Types.Int
                                  (GHC.Types.I# dt1)
                                  (GHC.Types.I# dt2))
                               (Control.Monad.Primitive.primitive
                                  @ m
                                  $dPrimMonad
                                  @ (Data.Primitive.ByteArray.MutableByteArray
                                       (Control.Monad.Primitive.PrimState m))
                                  (\ s# :: GHC.Prim.State#
                                             (Control.Monad.Primitive.PrimState m)[OneShot] ->
                                   (# s#,
                                      Data.Primitive.ByteArray.MutableByteArray
                                        @ (Control.Monad.Primitive.PrimState m)
                                        dt3
                                          `cast`
                                        (UnivCo mkUnsafeCo representational GHC.Prim.ByteArray# (GHC.Prim.MutableByteArray#
                                                                                                   (Control.Monad.Primitive.PrimState
                                                                                                      m))) #))) }))
                         (\ bs' :: Data.Vector.Unboxed.Base.MVector
                                     (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                          GHC.Base.>>=
                            @ m
                            $dMonad
                            @ (Data.Vector.Unboxed.Base.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                            @ (Data.Vector.Unboxed.Base.MVector
                                 (Control.Monad.Primitive.PrimState m)
                                 (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8))
                            (GHC.Base.liftM
                               @ (Data.Vector.Primitive.Mutable.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                               @ (Data.Vector.Unboxed.Base.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                               @ m
                               (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                               (\ tpl :: Data.Vector.Primitive.Mutable.MVector
                                           (Control.Monad.Primitive.PrimState m) GHC.Word.Word8 ->
                                tpl)
                                 `cast`
                               (<Data.Vector.Primitive.Mutable.MVector
                                   (Control.Monad.Primitive.PrimState m) GHC.Word.Word8>_R
                                ->_R Trans
                                         (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                                   <Control.Monad.Primitive.PrimState m>_N))
                                         (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                                        <Control.Monad.Primitive.PrimState m>_N))))
                               (case cs
                                       `cast`
                                     (Trans
                                          (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorWord8[0]))
                                          (Data.Vector.Unboxed.Base.NTCo:R:VectorWord8[0])) of wild1 { Data.Vector.Primitive.Vector dt1 dt2 dt3 ->
                                GHC.Base.liftM
                                  @ (Data.Primitive.ByteArray.MutableByteArray
                                       (Control.Monad.Primitive.PrimState m))
                                  @ (Data.Vector.Primitive.Mutable.MVector
                                       (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                                  @ m
                                  (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                                  (Data.Vector.Primitive.Mutable.$WMVector
                                     @ (Control.Monad.Primitive.PrimState m)
                                     @ GHC.Word.Word8
                                     (GHC.Types.I# dt1)
                                     (GHC.Types.I# dt2))
                                  (Control.Monad.Primitive.primitive
                                     @ m
                                     $dPrimMonad
                                     @ (Data.Primitive.ByteArray.MutableByteArray
                                          (Control.Monad.Primitive.PrimState m))
                                     (\ s# :: GHC.Prim.State#
                                                (Control.Monad.Primitive.PrimState m)[OneShot] ->
                                      (# s#,
                                         Data.Primitive.ByteArray.MutableByteArray
                                           @ (Control.Monad.Primitive.PrimState m)
                                           dt3
                                             `cast`
                                           (UnivCo mkUnsafeCo representational GHC.Prim.ByteArray# (GHC.Prim.MutableByteArray#
                                                                                                      (Control.Monad.Primitive.PrimState
                                                                                                         m))) #))) }))
                            (\ cs' :: Data.Vector.Unboxed.Base.MVector
                                        (Control.Monad.Primitive.PrimState m) GHC.Word.Word8 ->
                             GHC.Base.$
                               @ (Data.Vector.Unboxed.Base.MVector
                                    (Control.Monad.Primitive.PrimState m)
                                    (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8))
                               @ (m (Data.Vector.Unboxed.Base.MVector
                                       (Control.Monad.Primitive.PrimState m)
                                       (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8)))
                               (GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (Data.Vector.Unboxed.Base.MVector
                                       (Control.Monad.Primitive.PrimState m)
                                       (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8)))
                               (case as'
                                       `cast`
                                     (Trans
                                          (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                    <Control.Monad.Primitive.PrimState m>_N))
                                          (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                               <Control.Monad.Primitive.PrimState
                                                  m>_N)) of nt { Data.Vector.Primitive.Mutable.MVector ipv ipv1 ipv2 ->
                                case bs'
                                       `cast`
                                     (Trans
                                          (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                    <Control.Monad.Primitive.PrimState m>_N))
                                          (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                               <Control.Monad.Primitive.PrimState
                                                  m>_N)) of nt1 { Data.Vector.Primitive.Mutable.MVector ipv3 ipv4 ipv5 ->
                                case cs'
                                       `cast`
                                     (Trans
                                          (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                                    <Control.Monad.Primitive.PrimState m>_N))
                                          (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                               <Control.Monad.Primitive.PrimState
                                                  m>_N)) of nt2 { Data.Vector.Primitive.Mutable.MVector ipv6 ipv7 ipv8 ->
                                (Data.Vector.Unboxed.Base.MV_3
                                   @ (Control.Monad.Primitive.PrimState m)
                                   @ GHC.Types.Int
                                   @ GHC.Types.Int
                                   @ GHC.Word.Word8
                                   dt
                                   nt
                                     `cast`
                                   (Trans
                                        (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                                  <Control.Monad.Primitive.PrimState m>_N))
                                        (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                       <Control.Monad.Primitive.PrimState m>_N))))
                                   nt1
                                     `cast`
                                   (Trans
                                        (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                                  <Control.Monad.Primitive.PrimState m>_N))
                                        (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                       <Control.Monad.Primitive.PrimState m>_N))))
                                   nt2
                                     `cast`
                                   (Trans
                                        (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                                  <Control.Monad.Primitive.PrimState m>_N))
                                        (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                                       <Control.Monad.Primitive.PrimState m>_N)))))
                                  `cast`
                                (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,,)[0]
                                               <Control.Monad.Primitive.PrimState m>_N
                                               <GHC.Types.Int>_N
                                               <GHC.Types.Int>_N
                                               <GHC.Word.Word8>_N))) } } })))) }))
                  `cast`
                (forall (m :: * -> *).
                 <Control.Monad.Primitive.PrimMonad m>_R
                 ->_R <Data.Vector.Unboxed.Base.Vector MoveTypes.Promotion>_R
                 ->_R <m>_R (Sym (Data.Vector.Unboxed.Base.TFCo:R:MutableVector[0]) <Control.Monad.Primitive.PrimState
                                                                                       m>_N <MoveTypes.Promotion>_N)) -}
7974ea60cb767d2cccb374fcf473a0ab
  $fVectorVectorPromotion_$celemseq ::
    Data.Vector.Unboxed.Base.Vector MoveTypes.Promotion
    -> MoveTypes.Promotion -> b -> b
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><S,1*H><S,1*U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ b
                   ds :: Data.Vector.Unboxed.Base.Vector MoveTypes.Promotion
                   val :: MoveTypes.Promotion ->
                 case val of wild { MoveTypes.Promotion dt dt1 dt2 ->
                 let {
                   f :: b -> b = GHC.Prim.seq @ GHC.Types.Int @ b (GHC.Types.I# dt)
                 } in
                 let {
                   f1 :: b -> b = GHC.Prim.seq @ GHC.Types.Int @ b (GHC.Types.I# dt1)
                 } in
                 let {
                   g :: b -> b = GHC.Prim.seq @ GHC.Word.Word8 @ b (GHC.Word.W8# dt2)
                 } in
                 \ x :: b -> f (f1 (g x)) }) -}
cf33293733b9576eb85fde9fa8bb1758
  $mBishop ::
    MoveTypes.PromotionType
    -> (GHC.Prim.Void# -> r) -> (GHC.Prim.Void# -> r) -> r
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><L,1*C1(U)><L,1*C1(U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (r :: OpenKind)
                   scrut :: MoveTypes.PromotionType
                   cont :: GHC.Prim.Void# -> r
                   fail :: GHC.Prim.Void# -> r ->
                 case scrut
                        `cast`
                      (MoveTypes.NTCo:PromotionType[0]) of wild { GHC.Word.W8# a8 ->
                 case a8 of wild1 {
                   DEFAULT -> fail GHC.Prim.void#
                   __word 1 -> cont GHC.Prim.void# } }) -}
4d1ababd97085f53c4009280223352be
  $mKnight ::
    MoveTypes.PromotionType
    -> (GHC.Prim.Void# -> r) -> (GHC.Prim.Void# -> r) -> r
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><L,1*C1(U)><L,1*C1(U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (r :: OpenKind)
                   scrut :: MoveTypes.PromotionType
                   cont :: GHC.Prim.Void# -> r
                   fail :: GHC.Prim.Void# -> r ->
                 case scrut
                        `cast`
                      (MoveTypes.NTCo:PromotionType[0]) of wild { GHC.Word.W8# a8 ->
                 case a8 of wild1 {
                   DEFAULT -> fail GHC.Prim.void#
                   __word 0 -> cont GHC.Prim.void# } }) -}
1c4463ed393165ef1fbf128b34f5ca7a
  $mQueen ::
    MoveTypes.PromotionType
    -> (GHC.Prim.Void# -> r) -> (GHC.Prim.Void# -> r) -> r
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><L,1*C1(U)><L,1*C1(U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (r :: OpenKind)
                   scrut :: MoveTypes.PromotionType
                   cont :: GHC.Prim.Void# -> r
                   fail :: GHC.Prim.Void# -> r ->
                 case scrut
                        `cast`
                      (MoveTypes.NTCo:PromotionType[0]) of wild { GHC.Word.W8# a8 ->
                 case a8 of wild1 {
                   DEFAULT -> fail GHC.Prim.void#
                   __word 3 -> cont GHC.Prim.void# } }) -}
08777a13c2ddec54390d3100eacc3286
  $mRook ::
    MoveTypes.PromotionType
    -> (GHC.Prim.Void# -> r) -> (GHC.Prim.Void# -> r) -> r
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><L,1*C1(U)><L,1*C1(U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (r :: OpenKind)
                   scrut :: MoveTypes.PromotionType
                   cont :: GHC.Prim.Void# -> r
                   fail :: GHC.Prim.Void# -> r ->
                 case scrut
                        `cast`
                      (MoveTypes.NTCo:PromotionType[0]) of wild { GHC.Word.W8# a8 ->
                 case a8 of wild1 {
                   DEFAULT -> fail GHC.Prim.void#
                   __word 2 -> cont GHC.Prim.void# } }) -}
30e7c03109defc0776c310b6db8df831
  $w$cshowsPrec ::
    GHC.Prim.Int#
    -> Data.Vector.Unboxed.Base.Vector MoveTypes.Move
    -> Data.Vector.Unboxed.Base.Vector MoveTypes.Promotion
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U><S,U><S,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: Data.Vector.Unboxed.Base.Vector MoveTypes.Move
                   ww2 :: Data.Vector.Unboxed.Base.Vector MoveTypes.Promotion ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = Data.Vector.Unboxed.$w$cshowsPrec
                       @ MoveTypes.Move
                       MoveTypes.$fShowMove
                       MoveTypes.$fUnboxMove
                       ww1
                 } in
                 let {
                   f1 :: GHC.Base.String -> GHC.Base.String
                   = Data.Vector.Unboxed.$w$cshowsPrec
                       @ MoveTypes.Promotion
                       MoveTypes.$fShowPromotion
                       MoveTypes.$fUnboxPromotion
                       ww2
                 } in
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ x :: GHC.Base.String ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       MoveTypes.$fShowMoves6
                       (GHC.Base.++
                          @ GHC.Types.Char
                          MoveTypes.$fShowMoves5
                          (f (GHC.Base.++
                                @ GHC.Types.Char
                                MoveTypes.$fShowMoves4
                                (GHC.Base.++
                                   @ GHC.Types.Char
                                   MoveTypes.$fShowMoves3
                                   (f1 (GHC.Base.++ @ GHC.Types.Char MoveTypes.$fShowMoves2 x))))))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False -> p
                   GHC.Types.True
                   -> \ x :: GHC.Base.String ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x)) }) -}
f3dbebe0d325257369de8f68b627ee61
  $wpromotionToDoc ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Word#
    -> (# Text.PrettyPrint.ANSI.Leijen.Doc,
          Text.PrettyPrint.ANSI.Leijen.Doc #)
  {- Arity: 3, Strictness: <L,U><L,U><L,1*U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: GHC.Prim.Int#
                   ww2 :: GHC.Prim.Word# ->
                 (# Text.PrettyPrint.ANSI.Leijen.Cat
                      (case Index.$windexToDoc
                              (GHC.Types.I# ww) of ww3 { (#,#) ww4 ww5 ->
                       Text.PrettyPrint.ANSI.Leijen.Cat ww4 ww5 })
                      (case Index.$windexToDoc
                              (GHC.Types.I# ww1) of ww3 { (#,#) ww4 ww5 ->
                       Text.PrettyPrint.ANSI.Leijen.Cat ww4 ww5 }),
                    Text.PrettyPrint.ANSI.Leijen.Cat
                      MoveTypes.promotionToDoc6
                      (case ww2 of wild {
                         DEFAULT -> MoveTypes.promotionToDoc5
                         __word 0 -> MoveTypes.promotionToDoc4
                         __word 1 -> MoveTypes.promotionToDoc3
                         __word 2 -> MoveTypes.promotionToDoc2
                         __word 3 -> MoveTypes.promotionToDoc1 }) #)) -}
8a6002c8698e00152aa7c46e4c13773e
  pattern Bishop :: MoveTypes.PromotionType
a0d7ff475f502dfb256c6cd7a627a1fb
  pattern Knight :: MoveTypes.PromotionType
f87b40583b48531412a65b59dc7a4f4f
  data Move
    = Move {from :: {-# UNPACK #-}Index.Index,
            to :: {-# UNPACK #-}Index.Index}
bce809b1cf44ac24e1da2727bceb75dc
  data Moves
    = Moves {moves :: !Data.Vector.Unboxed.Base.Vector MoveTypes.Move,
             promotions :: !Data.Vector.Unboxed.Base.Vector MoveTypes.Promotion}
7974ea60cb767d2cccb374fcf473a0ab
  data Promotion
    = Promotion {move :: {-# UNPACK #-}MoveTypes.Move,
                 pType :: ! {-# UNPACK #-}(MoveTypes.NTCo:PromotionType[0])MoveTypes.PromotionType}
3fd8a083bfe8cc687899d3bb5113c5ce
  newtype PromotionType = PromotionType GHC.Word.Word8
750b41bca7a5b7d89b7e2e8ac7ed0294
  pattern Queen :: MoveTypes.PromotionType
f87b40583b48531412a65b59dc7a4f4f
  newtype instance Data.Vector.Unboxed.Base.MVector s0 MoveTypes.Move
    = MV_Move (Data.Vector.Unboxed.Base.MVector
                 s0 (GHC.Types.Int, GHC.Types.Int))
    RecFlag: Recursive
7974ea60cb767d2cccb374fcf473a0ab
  newtype instance Data.Vector.Unboxed.Base.MVector
                     s0 MoveTypes.Promotion
    = MV_Promotion (Data.Vector.Unboxed.Base.MVector
                      s0 (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8))
    RecFlag: Recursive
f87b40583b48531412a65b59dc7a4f4f
  newtype instance Data.Vector.Unboxed.Base.Vector MoveTypes.Move
    = V_Move (Data.Vector.Unboxed.Base.Vector
                (GHC.Types.Int, GHC.Types.Int))
    RecFlag: Recursive
7974ea60cb767d2cccb374fcf473a0ab
  newtype instance Data.Vector.Unboxed.Base.Vector
                     MoveTypes.Promotion
    = V_Promotion (Data.Vector.Unboxed.Base.Vector
                     (GHC.Types.Int, GHC.Types.Int, GHC.Word.Word8))
    RecFlag: Recursive
8f93959a239d06ed8d2a12a3f048135a
  pattern Rook :: MoveTypes.PromotionType
f87b40583b48531412a65b59dc7a4f4f
  axiom TFCo:R:MVectorsMove::
      Data.Vector.Unboxed.Base.MVector s0 MoveTypes.Move
        = MoveTypes.R:MVectorsMove s0
7974ea60cb767d2cccb374fcf473a0ab
  axiom TFCo:R:MVectorsPromotion::
      Data.Vector.Unboxed.Base.MVector s0 MoveTypes.Promotion
        = MoveTypes.R:MVectorsPromotion s0
f87b40583b48531412a65b59dc7a4f4f
  axiom TFCo:R:VectorMove::
      Data.Vector.Unboxed.Base.Vector MoveTypes.Move
        = MoveTypes.R:VectorMove
7974ea60cb767d2cccb374fcf473a0ab
  axiom TFCo:R:VectorPromotion::
      Data.Vector.Unboxed.Base.Vector MoveTypes.Promotion
        = MoveTypes.R:VectorPromotion
84064996d2c8ffd1cedf96c0b9861922
  from :: MoveTypes.Move -> Index.Index
  RecSel MoveTypes.Move
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: MoveTypes.Move ->
                 case ds of wild { MoveTypes.Move dt dt1 -> GHC.Types.I# dt }) -}
ff012166ffc0faccc10d7eac4b2ec244
  move :: MoveTypes.Promotion -> MoveTypes.Move
  RecSel MoveTypes.Promotion
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,U,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: MoveTypes.Promotion ->
                 case ds of wild { MoveTypes.Promotion dt dt1 dt2 ->
                 MoveTypes.Move dt dt1 }) -}
f87b40583b48531412a65b59dc7a4f4f
  moveToDoc :: MoveTypes.Move -> Text.PrettyPrint.ANSI.Leijen.Doc
  {- Arity: 1, Strictness: <S,1*U(U,U)>m7, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: MoveTypes.Move ->
                 case w of ww { MoveTypes.Move ww1 ww2 ->
                 Text.PrettyPrint.ANSI.Leijen.Cat
                   (case Index.$windexToDoc
                           (GHC.Types.I# ww1) of ww3 { (#,#) ww4 ww5 ->
                    Text.PrettyPrint.ANSI.Leijen.Cat ww4 ww5 })
                   (case Index.$windexToDoc
                           (GHC.Types.I# ww2) of ww3 { (#,#) ww4 ww5 ->
                    Text.PrettyPrint.ANSI.Leijen.Cat ww4 ww5 }) }) -}
b0d84a4d1e0bc8cb222f37e6c6295c2a
  moves ::
    MoveTypes.Moves -> Data.Vector.Unboxed.Base.Vector MoveTypes.Move
  RecSel MoveTypes.Moves
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SS),1*U(U(U,U,U),1*H)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: MoveTypes.Moves ->
                 case ds of wild { MoveTypes.Moves ds1 ds2 -> ds1 }) -}
e5424517983fa3099f5afbf70da5374c
  pType :: MoveTypes.Promotion -> MoveTypes.PromotionType
  RecSel MoveTypes.Promotion
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(A,A,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: MoveTypes.Promotion ->
                 case ds of wild { MoveTypes.Promotion dt dt1 dt2 ->
                 (GHC.Word.W8# dt2)
                   `cast`
                 (Sym (MoveTypes.NTCo:PromotionType[0])) }) -}
7974ea60cb767d2cccb374fcf473a0ab
  promotionToDoc ::
    MoveTypes.Promotion -> Text.PrettyPrint.ANSI.Leijen.Doc
  {- Arity: 1, Strictness: <S,1*U(U,U,1*U)>m7, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: MoveTypes.Promotion ->
                 case w of ww { MoveTypes.Promotion ww1 ww2 ww3 ->
                 case MoveTypes.$wpromotionToDoc
                        ww1
                        ww2
                        ww3 of ww4 { (#,#) ww5 ww6 ->
                 Text.PrettyPrint.ANSI.Leijen.Cat ww5 ww6 } }) -}
5ae9cff0bcec0cc22cee71d8b8e5eb2b
  promotionToDoc1 :: Text.PrettyPrint.ANSI.Leijen.Doc
  {- Unfolding: (case GHC.List.$wlenAcc
                        @ GHC.Types.Char
                        MoveTypes.promotionToDoc_wild
                        0 of ww2 { DEFAULT ->
                 Text.PrettyPrint.ANSI.Leijen.Text
                   ww2
                   MoveTypes.promotionToDoc_wild }) -}
417f19bf460f15aa6e42b7e7c421c934
  promotionToDoc2 :: Text.PrettyPrint.ANSI.Leijen.Doc
  {- Unfolding: (case GHC.List.$wlenAcc
                        @ GHC.Types.Char
                        MoveTypes.promotionToDoc_wild1
                        0 of ww2 { DEFAULT ->
                 Text.PrettyPrint.ANSI.Leijen.Text
                   ww2
                   MoveTypes.promotionToDoc_wild1 }) -}
35ab37946efd98b7cacc211ee62e4d90
  promotionToDoc3 :: Text.PrettyPrint.ANSI.Leijen.Doc
  {- Unfolding: (case GHC.List.$wlenAcc
                        @ GHC.Types.Char
                        MoveTypes.promotionToDoc_wild2
                        0 of ww2 { DEFAULT ->
                 Text.PrettyPrint.ANSI.Leijen.Text
                   ww2
                   MoveTypes.promotionToDoc_wild2 }) -}
c351bcd4cffe91dd0aa6cbb155daac07
  promotionToDoc4 :: Text.PrettyPrint.ANSI.Leijen.Doc
  {- Unfolding: (case GHC.List.$wlenAcc
                        @ GHC.Types.Char
                        MoveTypes.promotionToDoc_wild3
                        0 of ww2 { DEFAULT ->
                 Text.PrettyPrint.ANSI.Leijen.Text
                   ww2
                   MoveTypes.promotionToDoc_wild3 }) -}
c9d577480edec217ae11ed27ed869fff
  promotionToDoc5 :: Text.PrettyPrint.ANSI.Leijen.Doc
  {- Strictness: b -}
8dbf86bf647e7ebc70bc86fac8d69f06
  promotionToDoc6 :: Text.PrettyPrint.ANSI.Leijen.Doc
  {- Unfolding: (case GHC.List.$wlenAcc
                        @ GHC.Types.Char
                        MoveTypes.promotionToDoc_wild4
                        0 of ww2 { DEFAULT ->
                 Text.PrettyPrint.ANSI.Leijen.Text
                   ww2
                   MoveTypes.promotionToDoc_wild4 }) -}
5b51b071c46947bf93e09a732eae28ac
  promotionToDoc_ipv :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# 'Q') -}
5fed658c9d3b95408c4ea90066826eb3
  promotionToDoc_ipv1 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# 'R') -}
b79b90662c452e992bf9544b6ac3c568
  promotionToDoc_ipv2 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# 'B') -}
93463166952a36e87320a43d0898d42c
  promotionToDoc_ipv3 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# 'K') -}
0271d2122a15d4df22ef1435ad0172d1
  promotionToDoc_ipv4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "="#) -}
c92a6618be1d747ce060b90d0da86107
  promotionToDoc_ipv5 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# 'p') -}
832b944e93b1bbc37ee22bd2383db7fb
  promotionToDoc_wild :: [GHC.Types.Char]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   MoveTypes.promotionToDoc_ipv
                   (GHC.Types.[] @ GHC.Types.Char)) -}
9ef625ae5cd120e93a721906f8e4160d
  promotionToDoc_wild1 :: [GHC.Types.Char]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   MoveTypes.promotionToDoc_ipv1
                   (GHC.Types.[] @ GHC.Types.Char)) -}
326c29ebe9d967d8224bf33638561683
  promotionToDoc_wild2 :: [GHC.Types.Char]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   MoveTypes.promotionToDoc_ipv2
                   (GHC.Types.[] @ GHC.Types.Char)) -}
b3cd9fa8549237e06dcc624de8038bee
  promotionToDoc_wild3 :: [GHC.Types.Char]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   MoveTypes.promotionToDoc_ipv3
                   (GHC.Types.[] @ GHC.Types.Char)) -}
23d850b624a7912838ae878413a125f7
  promotionToDoc_wild4 :: [GHC.Types.Char]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   MoveTypes.promotionToDoc_ipv5
                   MoveTypes.promotionToDoc_ipv4) -}
a266237272cd5f8d2a0322728fde9939
  promotionTypeToDoc ::
    MoveTypes.PromotionType -> Text.PrettyPrint.ANSI.Leijen.Doc
  {- Arity: 1, Strictness: <S(S),1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: MoveTypes.PromotionType ->
                 case ds
                        `cast`
                      (MoveTypes.NTCo:PromotionType[0]) of wild { GHC.Word.W8# a8 ->
                 case a8 of wild1 {
                   DEFAULT -> MoveTypes.promotionToDoc5
                   __word 0 -> MoveTypes.promotionToDoc4
                   __word 1 -> MoveTypes.promotionToDoc3
                   __word 2 -> MoveTypes.promotionToDoc2
                   __word 3 -> MoveTypes.promotionToDoc1 } }) -}
a526b82b2e903eabe05ad702676179e0
  promotions ::
    MoveTypes.Moves
    -> Data.Vector.Unboxed.Base.Vector MoveTypes.Promotion
  RecSel MoveTypes.Moves
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SS),1*U(1*H,U(U,U,U,U))>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: MoveTypes.Moves ->
                 case ds of wild { MoveTypes.Moves ds1 ds2 -> ds2 }) -}
67ff61a9cae45ac8a97158efa9efcdde
  to :: MoveTypes.Move -> Index.Index
  RecSel MoveTypes.Move
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(A,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: MoveTypes.Move ->
                 case ds of wild { MoveTypes.Move dt dt1 -> GHC.Types.I# dt1 }) -}
instance Data.Vector.Generic.Mutable.Base.MVector [Data.Vector.Unboxed.Base.MVector,
                                                   MoveTypes.Move]
  = MoveTypes.$fMVectorMVectorMove
instance Data.Vector.Generic.Mutable.Base.MVector [Data.Vector.Unboxed.Base.MVector,
                                                   MoveTypes.Promotion]
  = MoveTypes.$fMVectorMVectorPromotion
instance GHC.Show.Show [MoveTypes.Move] = MoveTypes.$fShowMove
instance GHC.Show.Show [MoveTypes.Moves] = MoveTypes.$fShowMoves
instance GHC.Show.Show [MoveTypes.Promotion]
  = MoveTypes.$fShowPromotion
instance Data.Vector.Unboxed.Base.Unbox [MoveTypes.Move]
  = MoveTypes.$fUnboxMove
instance Data.Vector.Unboxed.Base.Unbox [MoveTypes.Promotion]
  = MoveTypes.$fUnboxPromotion
instance Data.Vector.Generic.Base.Vector [Data.Vector.Unboxed.Base.Vector,
                                          MoveTypes.Move]
  = MoveTypes.$fVectorVectorMove
instance Data.Vector.Generic.Base.Vector [Data.Vector.Unboxed.Base.Vector,
                                          MoveTypes.Promotion]
  = MoveTypes.$fVectorVectorPromotion
family instance Data.Vector.Unboxed.Base.MVector [.],
                                                 [MoveTypes.Promotion]
  = MoveTypes.TFCo:R:MVectorsPromotion
family instance Data.Vector.Unboxed.Base.MVector [.],
                                                 [MoveTypes.Move]
  = MoveTypes.TFCo:R:MVectorsMove
family instance Data.Vector.Unboxed.Base.Vector [MoveTypes.Promotion]
  = MoveTypes.TFCo:R:VectorPromotion
family instance Data.Vector.Unboxed.Base.Vector [MoveTypes.Move]
  = MoveTypes.TFCo:R:VectorMove
"SPEC/MoveTypes $dmshowsPrec @ Move" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                                 MoveTypes.Move
  GHC.Show.$dmshowsPrec @ MoveTypes.Move $dShow
  = MoveTypes.$fShowMove_$s$dmshowsPrec
"SPEC/MoveTypes $dmshowsPrec @ Promotion" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                                      MoveTypes.Promotion
  GHC.Show.$dmshowsPrec @ MoveTypes.Promotion $dShow
  = MoveTypes.$fShowPromotion_$s$dmshowsPrec
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

