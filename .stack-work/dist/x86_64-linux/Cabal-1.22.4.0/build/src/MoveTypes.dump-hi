
==================== FINAL INTERFACE ====================
2016-01-06 14:29:10.475478 UTC

interface hches_3PXdSEAhhp2JIrhYvA7RvZ:MoveTypes [family instance module] 7102
  interface hash: f471e46a82f94c6fc9808674e7927e49
  ABI hash: af3194be44047c2d3b912109768e02c7
  export-list hash: 30f47618c7224af3cabbf9f4bcec13bb
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 2c595cb46c98f3b80be1273370ced745
  sig of: Nothing
  used TH splices: True
  where
exports:
  MoveTypes.BishopM
  MoveTypes.BishopP
  MoveTypes.CastleL
  MoveTypes.CastleR
  MoveTypes.DoublePush
  MoveTypes.EnPassantA
  MoveTypes.KingM
  MoveTypes.KnightM
  MoveTypes.KnightP
  MoveTypes.PawnA
  MoveTypes.QueenM
  MoveTypes.QueenP
  MoveTypes.RookM
  MoveTypes.RookP
  MoveTypes.SinglePush
  MoveTypes.moveToDoc
  MoveTypes.Move{MoveTypes.Move MoveTypes.from MoveTypes.metaData MoveTypes.to}
  MoveTypes.MoveData{MoveTypes.MoveData}
  MoveTypes.Moves
  Data.Vector.Unboxed.Base.MVector|{MoveTypes.MV_Move}
  Data.Vector.Unboxed.Base.Vector|{MoveTypes.V_Move}
module dependencies: BitBoard Board FEN Index
package dependencies: ansi-terminal-0.6.2.3@ansit_KW0LUY2zB7JCYzE4ZYrwBg
                      ansi-wl-pprint-0.6.7.3@ansiw_KPlSW7tbqXS51Lj59n3FC4
                      array-0.5.1.0@array_E0sTtauuKsGDLZoT7lTbgZ
                      attoparsec-0.13.0.1@attop_FtJZAZu3GDOJSwmSRnXnPH base-4.8.1.0
                      binary-0.7.5.0@binar_IvYoLp9H6Xy3zEH13MmZwd
                      bool-extras-0.4.0@boole_GdoTyzdjqQqAeS3KnmOc2Q
                      bytestring-0.10.6.0@bytes_6elQVSg5cWdFrvRnfxTUrH
                      containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN
                      deepseq-1.4.1.1@deeps_LbCWUlehDDeLxurARKDH5o ghc-prim-0.4.0.0
                      hashable-1.2.3.3@hasha_2GTZqecVp8NJZrNuKzGxfy integer-gmp-1.0.0.0
                      pretty-1.1.2.0@prett_7UQTOB05U7lIYPkFOVraeR
                      primitive-0.6.1.0@primi_5Jnw7oEuYtM9dmKXelGXVb
                      scientific-0.3.4.4@scien_03wvk1zJytY0wVzR42F1U4
                      template-haskell-2.10.0.0 text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh
                      transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X
                      vector-th-unbox-0.2.1.3@vecto_7UKBkJbwJOEKV3lSwERBE0
                      vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF
orphans: attoparsec-0.13.0.1@attop_FtJZAZu3GDOJSwmSRnXnPH:Data.Attoparsec.ByteString.Char8
         base-4.8.1.0:GHC.Base base-4.8.1.0:GHC.Float
         binary-0.7.5.0@binar_IvYoLp9H6Xy3zEH13MmZwd:Data.Binary.Generic
         bytestring-0.10.6.0@bytes_6elQVSg5cWdFrvRnfxTUrH:Data.ByteString.Builder
         hashable-1.2.3.3@hasha_2GTZqecVp8NJZrNuKzGxfy:Data.Hashable.Generic
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Lazy
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Show
         transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X:Control.Monad.Trans.Error
         vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector.Fusion.Bundle
         vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector.Unboxed
family instance modules: attoparsec-0.13.0.1@attop_FtJZAZu3GDOJSwmSRnXnPH:Data.Attoparsec.Internal.Types
                         base-4.8.1.0:Control.Applicative base-4.8.1.0:Data.Either
                         base-4.8.1.0:Data.Functor.Identity base-4.8.1.0:Data.Monoid
                         base-4.8.1.0:Data.Type.Equality base-4.8.1.0:Data.Void
                         base-4.8.1.0:GHC.Exts base-4.8.1.0:GHC.Generics
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntMap.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntSet.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Map.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Sequence
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Set.Base
                         pretty-1.1.2.0@prett_7UQTOB05U7lIYPkFOVraeR:Text.PrettyPrint.HughesPJ
                         primitive-0.6.1.0@primi_5Jnw7oEuYtM9dmKXelGXVb:Control.Monad.Primitive
                         template-haskell-2.10.0.0:Language.Haskell.TH.Syntax
                         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text
                         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Lazy
                         vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector
                         vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector.Primitive
                         vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector.Unboxed
                         vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector.Unboxed.Base
import  -/  ansi-wl-pprint-0.6.7.3@ansiw_KPlSW7tbqXS51Lj59n3FC4:Text.PrettyPrint.ANSI.Leijen 8c4176551c95005818f5e57d74e5ea69
import  -/  base-4.8.1.0:Data.Bits 5341167fdd5958c2b3f0dac8924f1efd
import  -/  base-4.8.1.0:Data.Coerce 115f9a67dc841840e696ba440ba99295
import  -/  base-4.8.1.0:Data.Word 448c480b98a0c18988a37db5ab829b22
import  -/  base-4.8.1.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.1.0:GHC.Show b8c65ca3124f92a166c9f05120382442
import  -/  base-4.8.1.0:GHC.Word ef6286c279d61931eb675109b4b93579
import  -/  base-4.8.1.0:Prelude 518f762991bc287d78f21a73c974da1f
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  BitBoard 1d34c765e2913aef164a6d247daf4736
  exports: 6eb44feaf65c4fa3bf03a262b000e28d
import  -/  Board 39873f4ed53528af07e0b2ad9994c225
  exports: 4f7b98092ef87ef50bc5f50b83e780d6
import  -/  Index d8cad232a279cafde9ae933a407e67d2
  exports: f2069996af848e99f6e14ee9d6b1f04e
  Index 5c8ceb59f924ec508c7fc4cbb0c05d15
  indexToDoc 9af4c8c26f60e46777a61ec4ba1cd744
import  -/  vector-th-unbox-0.2.1.3@vecto_7UKBkJbwJOEKV3lSwERBE0:Data.Vector.Unboxed.Deriving ca39b75552a17b45193a0bf900b2bb7a
import  -/  vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector.Generic.Base f9e814d2cdc449478d6b1a8e12059519
import  -/  vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector.Generic.Mutable.Base 74328ab2ccb574f6522896e090906e9d
import  -/  vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector.Unboxed 8bd91cd1a3cd2cbd12faec978422ccd8
import  -/  vector-0.11.0.0@vecto_A9qWf1eecPQGJD12EBZIxF:Data.Vector.Unboxed.Base 0761e27d6792efb778c5ac79292248a5
2a60a1ff658b7bdcecc5369e2e95990c
  $bBishopM :: MoveTypes.MoveData
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                MoveTypes.$bBishopM1 `cast` (Sym (MoveTypes.NTCo:MoveData[0])) -}
87be2024d3bbd5e7b1de4f6c351c0dc5
  $bBishopM1 :: GHC.Word.Word8
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Word.W8# __word 5) -}
58af62f845f346808e11924719f18a53
  $bBishopP :: MoveTypes.MoveData
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                MoveTypes.$bBishopP1 `cast` (Sym (MoveTypes.NTCo:MoveData[0])) -}
d011be0947e26a0bd1198b7ccafe470c
  $bBishopP1 :: GHC.Word.Word8
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Word.W8# __word 12) -}
71febe61abf6e685a5e06ad5154ef9f8
  $bCastleL :: MoveTypes.MoveData
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                MoveTypes.$bCastleL1 `cast` (Sym (MoveTypes.NTCo:MoveData[0])) -}
592fd12d22031f15476637c9159aaa9c
  $bCastleL1 :: GHC.Word.Word8
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Word.W8# __word 9) -}
7f0a68492b146b58337e63a29b8b9fe0
  $bCastleR :: MoveTypes.MoveData
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                MoveTypes.$bCastleR1 `cast` (Sym (MoveTypes.NTCo:MoveData[0])) -}
cae4fbc3470f2dd745a7e685e51053e6
  $bCastleR1 :: GHC.Word.Word8
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Word.W8# __word 10) -}
85aaeb23fe5ac1eef2aad731e0cc8f9d
  $bDoublePush :: MoveTypes.MoveData
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                MoveTypes.$bDoublePush1
                  `cast`
                (Sym (MoveTypes.NTCo:MoveData[0])) -}
a98400ecd6c1ba71d4f08d3826ec3382
  $bDoublePush1 :: GHC.Word.Word8
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Word.W8# __word 1) -}
698775546e70c4b3b3d202383ff01424
  $bEnPassantA :: MoveTypes.MoveData
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                MoveTypes.$bEnPassantA1
                  `cast`
                (Sym (MoveTypes.NTCo:MoveData[0])) -}
bb07662052988be9553e0cb496a5b995
  $bEnPassantA1 :: GHC.Word.Word8
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Word.W8# __word 3) -}
d980d25097ce75f4e3e9e1e7bff22076
  $bKingM :: MoveTypes.MoveData
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                MoveTypes.$bKingM1 `cast` (Sym (MoveTypes.NTCo:MoveData[0])) -}
57416b95c9744f5e29bfa37cdd0136f6
  $bKingM1 :: GHC.Word.Word8
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Word.W8# __word 8) -}
1ac19cc92172b5e071f7b10cd8bba8ea
  $bKnightM :: MoveTypes.MoveData
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                MoveTypes.$bKnightM1 `cast` (Sym (MoveTypes.NTCo:MoveData[0])) -}
fd272114669179db6144f43a967f5e06
  $bKnightM1 :: GHC.Word.Word8
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Word.W8# __word 4) -}
afc0e3a29bd21bf2a190ad8dfc319439
  $bKnightP :: MoveTypes.MoveData
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                MoveTypes.$bKnightP1 `cast` (Sym (MoveTypes.NTCo:MoveData[0])) -}
3a13ecde067dce1db442f83a85245732
  $bKnightP1 :: GHC.Word.Word8
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Word.W8# __word 11) -}
227511b8f6aae0dcc63a78ccd5a9e4e7
  $bPawnA :: MoveTypes.MoveData
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                MoveTypes.$bPawnA1 `cast` (Sym (MoveTypes.NTCo:MoveData[0])) -}
bd5fc90613008e7852b3cdc26997887c
  $bPawnA1 :: GHC.Word.Word8
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Word.W8# __word 2) -}
a5ddf8316227a82078c9e19792ec9410
  $bQueenM :: MoveTypes.MoveData
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                MoveTypes.$bQueenM1 `cast` (Sym (MoveTypes.NTCo:MoveData[0])) -}
440a45005fc61f2c290fe917dd86eb7e
  $bQueenM1 :: GHC.Word.Word8
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Word.W8# __word 7) -}
95fa88a999ed501589e8533b01fe5927
  $bQueenP :: MoveTypes.MoveData
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                MoveTypes.$bQueenP1 `cast` (Sym (MoveTypes.NTCo:MoveData[0])) -}
cc352e0679c0008e36414c4293804e03
  $bQueenP1 :: GHC.Word.Word8
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Word.W8# __word 14) -}
e18e35d53a84f55d43f15e3fccd636e7
  $bRookM :: MoveTypes.MoveData
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                MoveTypes.$bRookM1 `cast` (Sym (MoveTypes.NTCo:MoveData[0])) -}
2566b50d4ccea75149676cc180f91771
  $bRookM1 :: GHC.Word.Word8
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Word.W8# __word 6) -}
01fbbffc56f4d6fabb327ca04a6f1743
  $bRookP :: MoveTypes.MoveData
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                MoveTypes.$bRookP1 `cast` (Sym (MoveTypes.NTCo:MoveData[0])) -}
01f0edb4759abdddc508f7986a8b991a
  $bRookP1 :: GHC.Word.Word8
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Word.W8# __word 13) -}
03ee60971a3aa75feae06aaaab6d4fac
  $bSinglePush :: MoveTypes.MoveData
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                MoveTypes.$bSinglePush1
                  `cast`
                (Sym (MoveTypes.NTCo:MoveData[0])) -}
17b8aaef64af29e9e28d9bd3b58bab4b
  $bSinglePush1 :: GHC.Word.Word8
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Word.W8# __word 0) -}
b13936b6226fe6ee038902e83e9bea5b
  $fMVectorMVectorMove ::
    Data.Vector.Generic.Mutable.Base.MVector
      Data.Vector.Unboxed.Base.MVector MoveTypes.Move
  DFunId[0]
  {- Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Vector.Unboxed.Base.MVector
                  @ MoveTypes.Move
                  MoveTypes.$fMVectorMVectorMove_$cbasicLength
                  MoveTypes.$fMVectorMVectorMove_$cbasicUnsafeSlice
                  MoveTypes.$fMVectorMVectorMove_$cbasicOverlaps
                  MoveTypes.$fMVectorMVectorMove_$cbasicUnsafeNew
                  MoveTypes.$fMVectorMVectorMove_$cbasicInitialize
                  MoveTypes.$fMVectorMVectorMove_$cbasicUnsafeReplicate
                  MoveTypes.$fMVectorMVectorMove_$cbasicUnsafeRead
                  MoveTypes.$fMVectorMVectorMove_$cbasicUnsafeWrite
                  MoveTypes.$fMVectorMVectorMove_$cbasicClear
                  MoveTypes.$fMVectorMVectorMove_$cbasicSet
                  MoveTypes.$fMVectorMVectorMove_$cbasicUnsafeCopy
                  MoveTypes.$fMVectorMVectorMove_$cbasicUnsafeMove
                  MoveTypes.$fMVectorMVectorMove_$cbasicUnsafeGrow -}
b13936b6226fe6ee038902e83e9bea5b
  $fMVectorMVectorMove_$cbasicClear ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Unboxed.Base.MVector
      (Control.Monad.Primitive.PrimState m) MoveTypes.Move
    -> m ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),U(U(U,U,U,U,U),A)><S,1*U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   ds :: Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m) MoveTypes.Move ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                 } in
                 GHC.Prim.seq
                   @ (Data.Vector.Unboxed.Base.MVector
                        (Control.Monad.Primitive.PrimState m) MoveTypes.Move)
                   @ (m ())
                   ds
                   (GHC.Base.>>
                      @ m
                      $dMonad
                      @ ()
                      @ ()
                      (GHC.Base.return
                         @ m
                         (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                         @ ()
                         GHC.Tuple.())
                      (GHC.Base.>>
                         @ m
                         $dMonad
                         @ ()
                         @ ()
                         (GHC.Base.return
                            @ m
                            (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                            @ ()
                            GHC.Tuple.())
                         (GHC.Base.return
                            @ m
                            (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                            @ ()
                            GHC.Tuple.())))) -}
b13936b6226fe6ee038902e83e9bea5b
  $fMVectorMVectorMove_$cbasicInitialize ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Unboxed.Base.MVector
      (Control.Monad.Primitive.PrimState m) MoveTypes.Move
    -> m ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),U(1*U,C(U))><S(LSSS),1*U(A,U(U,U,U),U(U,U,U),U(U,U,U))>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   ds :: Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m) MoveTypes.Move ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                 } in
                 case ds
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:MVectorsMove[0]
                                     <Control.Monad.Primitive.PrimState m>_N))
                           (Trans
                                (MoveTypes.NTCo:R:MVectorsMove[0]
                                     <Control.Monad.Primitive.PrimState m>_N)
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,,)[0]
                                          <Control.Monad.Primitive.PrimState m>_N
                                          <GHC.Word.Word8>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N)))) of wild { Data.Vector.Unboxed.Base.MV_3 dt as bs cs ->
                 GHC.Base.>>
                   @ m
                   $dMonad
                   @ ()
                   @ ()
                   (case as
                           `cast`
                         (Trans
                              (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                        <Control.Monad.Primitive.PrimState m>_N))
                              (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                   <Control.Monad.Primitive.PrimState
                                      m>_N)) of wild1 { Data.Vector.Primitive.Mutable.MVector dt1 dt2 dt3 ->
                    let {
                      size :: GHC.Types.Int
                      = Data.Vector.Unboxed.Base.$fMVectorMVectorBool_$ssizeOf
                          (GHC.Err.undefined @ GHC.Word.Word8)
                    } in
                    case GHC.Num.$fNumInt_$c*
                           (GHC.Types.I# dt1)
                           size of wild2 { GHC.Types.I# doff# ->
                    case GHC.Num.$fNumInt_$c*
                           (GHC.Types.I# dt2)
                           size of wild3 { GHC.Types.I# sz# ->
                    Control.Monad.Primitive.primitive
                      @ m
                      $dPrimMonad
                      @ ()
                      (\ s# :: GHC.Prim.State#
                                 (Control.Monad.Primitive.PrimState m)[OneShot] ->
                       case GHC.Word.$cfromInteger
                              __integer 0 of wild4 { GHC.Word.W8# x# ->
                       case GHC.Base.id
                              @ GHC.Types.Int
                              (GHC.Types.I# doff#) of wild5 { GHC.Types.I# x#1 ->
                       case ((Data.Primitive.Internal.Operations.setWord8Array#
                                @ (Control.Monad.Primitive.PrimState m)
                                dt3
                                (GHC.Int.I64# x#1) `cast` (Sym (Foreign.C.Types.NTCo:CPtrdiff[0]))
                                (GHC.Word.W64# (GHC.Prim.int2Word# sz#))
                                  `cast`
                                (Sym (Foreign.C.Types.NTCo:CSize[0]))
                                x#)
                               `cast`
                             (Trans
                                  (GHC.Types.NTCo:IO[0] <()>_R)
                                  ((GHC.Prim.State#
                                      (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R
                                   ->_R ((# (GHC.Prim.State#
                                               (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R,
                                            <()>_R #))_R))
                               s#
                                 `cast`
                               (GHC.Prim.State#
                                  (Trans
                                       (UnivCo mkUnsafeCo nominal (Control.Monad.Primitive.PrimState
                                                                     m) GHC.Prim.RealWorld)
                                       (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0]))))_R)
                              `cast`
                            ((# (GHC.Prim.State#
                                   (Trans
                                        (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])
                                        (UnivCo mkUnsafeCo nominal GHC.Prim.RealWorld (Control.Monad.Primitive.PrimState
                                                                                         m))))_R,
                                UnivCo mkUnsafeCo representational () GHC.Prim.Any #))_R of ds1 { (#,#) ipv ipv1 ->
                       (# ipv, GHC.Tuple.() #) } } }) } } })
                   (GHC.Base.>>
                      @ m
                      $dMonad
                      @ ()
                      @ ()
                      (case bs
                              `cast`
                            (Trans
                                 (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                           <Control.Monad.Primitive.PrimState m>_N))
                                 (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                      <Control.Monad.Primitive.PrimState
                                         m>_N)) of wild1 { Data.Vector.Primitive.Mutable.MVector dt1 dt2 dt3 ->
                       let {
                         size :: GHC.Types.Int
                         = Data.Vector.Primitive.$fVectorVectora_$ssizeOf
                             (GHC.Err.undefined @ GHC.Types.Int)
                       } in
                       case GHC.Num.$fNumInt_$c*
                              (GHC.Types.I# dt1)
                              size of wild2 { GHC.Types.I# doff# ->
                       case GHC.Num.$fNumInt_$c*
                              (GHC.Types.I# dt2)
                              size of wild3 { GHC.Types.I# sz# ->
                       Control.Monad.Primitive.primitive
                         @ m
                         $dPrimMonad
                         @ ()
                         (\ s# :: GHC.Prim.State#
                                    (Control.Monad.Primitive.PrimState m)[OneShot] ->
                          case GHC.Word.$cfromInteger
                                 __integer 0 of wild4 { GHC.Word.W8# x# ->
                          case GHC.Base.id
                                 @ GHC.Types.Int
                                 (GHC.Types.I# doff#) of wild5 { GHC.Types.I# x#1 ->
                          case ((Data.Primitive.Internal.Operations.setWord8Array#
                                   @ (Control.Monad.Primitive.PrimState m)
                                   dt3
                                   (GHC.Int.I64# x#1)
                                     `cast`
                                   (Sym (Foreign.C.Types.NTCo:CPtrdiff[0]))
                                   (GHC.Word.W64# (GHC.Prim.int2Word# sz#))
                                     `cast`
                                   (Sym (Foreign.C.Types.NTCo:CSize[0]))
                                   x#)
                                  `cast`
                                (Trans
                                     (GHC.Types.NTCo:IO[0] <()>_R)
                                     ((GHC.Prim.State#
                                         (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R
                                      ->_R ((# (GHC.Prim.State#
                                                  (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R,
                                               <()>_R #))_R))
                                  s#
                                    `cast`
                                  (GHC.Prim.State#
                                     (Trans
                                          (UnivCo mkUnsafeCo nominal (Control.Monad.Primitive.PrimState
                                                                        m) GHC.Prim.RealWorld)
                                          (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0]))))_R)
                                 `cast`
                               ((# (GHC.Prim.State#
                                      (Trans
                                           (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])
                                           (UnivCo mkUnsafeCo nominal GHC.Prim.RealWorld (Control.Monad.Primitive.PrimState
                                                                                            m))))_R,
                                   UnivCo mkUnsafeCo representational () GHC.Prim.Any #))_R of ds1 { (#,#) ipv ipv1 ->
                          (# ipv, GHC.Tuple.() #) } } }) } } })
                      (case cs
                              `cast`
                            (Trans
                                 (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                           <Control.Monad.Primitive.PrimState m>_N))
                                 (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                      <Control.Monad.Primitive.PrimState
                                         m>_N)) of wild1 { Data.Vector.Primitive.Mutable.MVector dt1 dt2 dt3 ->
                       let {
                         size :: GHC.Types.Int
                         = Data.Vector.Primitive.$fVectorVectora_$ssizeOf
                             (GHC.Err.undefined @ GHC.Types.Int)
                       } in
                       case GHC.Num.$fNumInt_$c*
                              (GHC.Types.I# dt1)
                              size of wild2 { GHC.Types.I# doff# ->
                       case GHC.Num.$fNumInt_$c*
                              (GHC.Types.I# dt2)
                              size of wild3 { GHC.Types.I# sz# ->
                       Control.Monad.Primitive.primitive
                         @ m
                         $dPrimMonad
                         @ ()
                         (\ s# :: GHC.Prim.State#
                                    (Control.Monad.Primitive.PrimState m)[OneShot] ->
                          case GHC.Word.$cfromInteger
                                 __integer 0 of wild4 { GHC.Word.W8# x# ->
                          case GHC.Base.id
                                 @ GHC.Types.Int
                                 (GHC.Types.I# doff#) of wild5 { GHC.Types.I# x#1 ->
                          case ((Data.Primitive.Internal.Operations.setWord8Array#
                                   @ (Control.Monad.Primitive.PrimState m)
                                   dt3
                                   (GHC.Int.I64# x#1)
                                     `cast`
                                   (Sym (Foreign.C.Types.NTCo:CPtrdiff[0]))
                                   (GHC.Word.W64# (GHC.Prim.int2Word# sz#))
                                     `cast`
                                   (Sym (Foreign.C.Types.NTCo:CSize[0]))
                                   x#)
                                  `cast`
                                (Trans
                                     (GHC.Types.NTCo:IO[0] <()>_R)
                                     ((GHC.Prim.State#
                                         (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R
                                      ->_R ((# (GHC.Prim.State#
                                                  (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R,
                                               <()>_R #))_R))
                                  s#
                                    `cast`
                                  (GHC.Prim.State#
                                     (Trans
                                          (UnivCo mkUnsafeCo nominal (Control.Monad.Primitive.PrimState
                                                                        m) GHC.Prim.RealWorld)
                                          (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0]))))_R)
                                 `cast`
                               ((# (GHC.Prim.State#
                                      (Trans
                                           (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])
                                           (UnivCo mkUnsafeCo nominal GHC.Prim.RealWorld (Control.Monad.Primitive.PrimState
                                                                                            m))))_R,
                                   UnivCo mkUnsafeCo representational () GHC.Prim.Any #))_R of ds1 { (#,#) ipv ipv1 ->
                          (# ipv, GHC.Tuple.() #) } } }) } } })) }) -}
b13936b6226fe6ee038902e83e9bea5b
  $fMVectorMVectorMove_$cbasicLength ::
    Data.Vector.Unboxed.Base.MVector s MoveTypes.Move -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LSSS),1*U(U,1*H,1*H,1*H)>m,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ s ds :: Data.Vector.Unboxed.Base.MVector s MoveTypes.Move ->
                 case ds
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:MVectorsMove[0] <s>_N))
                           (Trans
                                (MoveTypes.NTCo:R:MVectorsMove[0] <s>_N)
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,,)[0]
                                          <s>_N
                                          <GHC.Word.Word8>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N)))) of wild { Data.Vector.Unboxed.Base.MV_3 dt ds1 ds2 ds3 ->
                 GHC.Types.I# dt }) -}
b13936b6226fe6ee038902e83e9bea5b
  $fMVectorMVectorMove_$cbasicOverlaps ::
    Data.Vector.Unboxed.Base.MVector s MoveTypes.Move
    -> Data.Vector.Unboxed.Base.MVector s MoveTypes.Move
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LSSS),1*U(A,U(U,U,U),U(U,U,U),U(U,U,U))><S,1*U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   ds :: Data.Vector.Unboxed.Base.MVector s MoveTypes.Move
                   ds1 :: Data.Vector.Unboxed.Base.MVector s MoveTypes.Move ->
                 case ds
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:MVectorsMove[0] <s>_N))
                           (Trans
                                (MoveTypes.NTCo:R:MVectorsMove[0] <s>_N)
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,,)[0]
                                          <s>_N
                                          <GHC.Word.Word8>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N)))) of wild { Data.Vector.Unboxed.Base.MV_3 dt as1 bs1 cs1 ->
                 case ds1
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:MVectorsMove[0] <s>_N))
                           (Trans
                                (MoveTypes.NTCo:R:MVectorsMove[0] <s>_N)
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,,)[0]
                                          <s>_N
                                          <GHC.Word.Word8>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N)))) of wild1 { Data.Vector.Unboxed.Base.MV_3 dt1 as2 bs2 cs2 ->
                 case as1
                        `cast`
                      (Trans
                           (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0] <s>_N))
                           (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                <s>_N)) of wild2 { Data.Vector.Primitive.Mutable.MVector dt2 dt3 dt4 ->
                 let {
                   i :: GHC.Types.Int = GHC.Types.I# dt2
                 } in
                 case as2
                        `cast`
                      (Trans
                           (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0] <s>_N))
                           (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                <s>_N)) of wild3 { Data.Vector.Primitive.Mutable.MVector dt5 dt6 dt7 ->
                 let {
                   j :: GHC.Types.Int = GHC.Types.I# dt5
                 } in
                 let {
                   between :: forall a20.
                              GHC.Classes.Ord a20 =>
                              a20 -> a20 -> a20 -> GHC.Types.Bool
                     {- Arity: 4 -}
                   = \ @ a20
                       $dOrd :: GHC.Classes.Ord a20
                       x :: a20
                       y :: a20
                       z :: a20 ->
                     GHC.Classes.&&
                       (GHC.Classes.>= @ a20 $dOrd x y)
                       (GHC.Classes.< @ a20 $dOrd x z)
                 } in
                 GHC.Classes.||
                   (GHC.Classes.&&
                      (GHC.Prim.tagToEnum#
                         @ GHC.Types.Bool
                         (GHC.Prim.sameMutableByteArray# @ s dt4 dt7))
                      (GHC.Classes.||
                         (between
                            @ GHC.Types.Int
                            GHC.Classes.$fOrdInt
                            i
                            j
                            (GHC.Num.$fNumInt_$c+ j (GHC.Types.I# dt6)))
                         (between
                            @ GHC.Types.Int
                            GHC.Classes.$fOrdInt
                            j
                            i
                            (GHC.Num.$fNumInt_$c+ i (GHC.Types.I# dt3)))))
                   (case bs1
                           `cast`
                         (Trans
                              (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0] <s>_N))
                              (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                   <s>_N)) of wild4 { Data.Vector.Primitive.Mutable.MVector dt8 dt9 dt10 ->
                    let {
                      i1 :: GHC.Types.Int = GHC.Types.I# dt8
                    } in
                    case bs2
                           `cast`
                         (Trans
                              (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0] <s>_N))
                              (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                   <s>_N)) of wild5 { Data.Vector.Primitive.Mutable.MVector dt11 dt12 dt13 ->
                    let {
                      j1 :: GHC.Types.Int = GHC.Types.I# dt11
                    } in
                    let {
                      between1 :: forall a7.
                                  GHC.Classes.Ord a7 =>
                                  a7 -> a7 -> a7 -> GHC.Types.Bool
                        {- Arity: 4 -}
                      = \ @ a7 $dOrd :: GHC.Classes.Ord a7 x :: a7 y :: a7 z :: a7 ->
                        GHC.Classes.&&
                          (GHC.Classes.>= @ a7 $dOrd x y)
                          (GHC.Classes.< @ a7 $dOrd x z)
                    } in
                    GHC.Classes.||
                      (GHC.Classes.&&
                         (GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.sameMutableByteArray# @ s dt10 dt13))
                         (GHC.Classes.||
                            (between1
                               @ GHC.Types.Int
                               GHC.Classes.$fOrdInt
                               i1
                               j1
                               (GHC.Num.$fNumInt_$c+ j1 (GHC.Types.I# dt12)))
                            (between1
                               @ GHC.Types.Int
                               GHC.Classes.$fOrdInt
                               j1
                               i1
                               (GHC.Num.$fNumInt_$c+ i1 (GHC.Types.I# dt9)))))
                      (case cs1
                              `cast`
                            (Trans
                                 (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0] <s>_N))
                                 (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                      <s>_N)) of wild6 { Data.Vector.Primitive.Mutable.MVector dt14 dt15 dt16 ->
                       let {
                         i2 :: GHC.Types.Int = GHC.Types.I# dt14
                       } in
                       case cs2
                              `cast`
                            (Trans
                                 (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0] <s>_N))
                                 (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                      <s>_N)) of wild7 { Data.Vector.Primitive.Mutable.MVector dt17 dt18 dt19 ->
                       let {
                         j2 :: GHC.Types.Int = GHC.Types.I# dt17
                       } in
                       let {
                         between2 :: forall a7.
                                     GHC.Classes.Ord a7 =>
                                     a7 -> a7 -> a7 -> GHC.Types.Bool
                           {- Arity: 4 -}
                         = \ @ a7 $dOrd :: GHC.Classes.Ord a7 x :: a7 y :: a7 z :: a7 ->
                           GHC.Classes.&&
                             (GHC.Classes.>= @ a7 $dOrd x y)
                             (GHC.Classes.< @ a7 $dOrd x z)
                       } in
                       GHC.Classes.&&
                         (GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.sameMutableByteArray# @ s dt16 dt19))
                         (GHC.Classes.||
                            (between2
                               @ GHC.Types.Int
                               GHC.Classes.$fOrdInt
                               i2
                               j2
                               (GHC.Num.$fNumInt_$c+ j2 (GHC.Types.I# dt18)))
                            (between2
                               @ GHC.Types.Int
                               GHC.Classes.$fOrdInt
                               j2
                               i2
                               (GHC.Num.$fNumInt_$c+
                                  i2
                                  (GHC.Types.I# dt15)))) } }) } }) } } } }) -}
b13936b6226fe6ee038902e83e9bea5b
  $fMVectorMVectorMove_$cbasicSet ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Unboxed.Base.MVector
      (Control.Monad.Primitive.PrimState m) MoveTypes.Move
    -> MoveTypes.Move -> m ()
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(SL),U(1*U,C(U))><S(LSSS),1*U(A,U(U,U,U),U(U,U,U),U(U,U,U))><S,1*U(U,U,U)>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   ds :: Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m) MoveTypes.Move
                   val :: MoveTypes.Move ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                 } in
                 case ds
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:MVectorsMove[0]
                                     <Control.Monad.Primitive.PrimState m>_N))
                           (Trans
                                (MoveTypes.NTCo:R:MVectorsMove[0]
                                     <Control.Monad.Primitive.PrimState m>_N)
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,,)[0]
                                          <Control.Monad.Primitive.PrimState m>_N
                                          <GHC.Word.Word8>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N)))) of wild { Data.Vector.Unboxed.Base.MV_3 dt as bs cs ->
                 case val of wild1 { MoveTypes.Move dt1 dt2 dt3 ->
                 GHC.Base.>>
                   @ m
                   $dMonad
                   @ ()
                   @ ()
                   (case as
                           `cast`
                         (Trans
                              (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                        <Control.Monad.Primitive.PrimState m>_N))
                              (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                   <Control.Monad.Primitive.PrimState
                                      m>_N)) of wild2 { Data.Vector.Primitive.Mutable.MVector dt4 dt5 dt6 ->
                    Control.Monad.Primitive.primitive
                      @ m
                      $dPrimMonad
                      @ ()
                      (\ s# :: GHC.Prim.State#
                                 (Control.Monad.Primitive.PrimState m)[OneShot] ->
                       case GHC.Base.id
                              @ GHC.Types.Int
                              (GHC.Types.I# dt4) of wild3 { GHC.Types.I# x#1 ->
                       case ((Data.Primitive.Internal.Operations.setWord8Array#
                                @ (Control.Monad.Primitive.PrimState m)
                                dt6
                                (GHC.Int.I64# x#1) `cast` (Sym (Foreign.C.Types.NTCo:CPtrdiff[0]))
                                (GHC.Word.W64# (GHC.Prim.int2Word# dt5))
                                  `cast`
                                (Sym (Foreign.C.Types.NTCo:CSize[0]))
                                dt1)
                               `cast`
                             (Trans
                                  (GHC.Types.NTCo:IO[0] <()>_R)
                                  ((GHC.Prim.State#
                                      (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R
                                   ->_R ((# (GHC.Prim.State#
                                               (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R,
                                            <()>_R #))_R))
                               s#
                                 `cast`
                               (GHC.Prim.State#
                                  (Trans
                                       (UnivCo mkUnsafeCo nominal (Control.Monad.Primitive.PrimState
                                                                     m) GHC.Prim.RealWorld)
                                       (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0]))))_R)
                              `cast`
                            ((# (GHC.Prim.State#
                                   (Trans
                                        (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])
                                        (UnivCo mkUnsafeCo nominal GHC.Prim.RealWorld (Control.Monad.Primitive.PrimState
                                                                                         m))))_R,
                                UnivCo mkUnsafeCo representational () GHC.Prim.Any #))_R of ds1 { (#,#) ipv ipv1 ->
                       (# ipv, GHC.Tuple.() #) } }) })
                   (GHC.Base.>>
                      @ m
                      $dMonad
                      @ ()
                      @ ()
                      (case bs
                              `cast`
                            (Trans
                                 (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                           <Control.Monad.Primitive.PrimState m>_N))
                                 (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                      <Control.Monad.Primitive.PrimState
                                         m>_N)) of wild2 { Data.Vector.Primitive.Mutable.MVector dt4 dt5 dt6 ->
                       Control.Monad.Primitive.primitive
                         @ m
                         $dPrimMonad
                         @ ()
                         (\ s# :: GHC.Prim.State#
                                    (Control.Monad.Primitive.PrimState m)[OneShot] ->
                          case GHC.Base.id
                                 @ GHC.Types.Int
                                 (GHC.Types.I# dt4) of wild3 { GHC.Types.I# x#1 ->
                          case ((Data.Primitive.Internal.Operations.setIntArray#
                                   @ (Control.Monad.Primitive.PrimState m)
                                   dt6
                                   (GHC.Int.I64# x#1)
                                     `cast`
                                   (Sym (Foreign.C.Types.NTCo:CPtrdiff[0]))
                                   (GHC.Word.W64# (GHC.Prim.int2Word# dt5))
                                     `cast`
                                   (Sym (Foreign.C.Types.NTCo:CSize[0]))
                                   dt2)
                                  `cast`
                                (Trans
                                     (GHC.Types.NTCo:IO[0] <()>_R)
                                     ((GHC.Prim.State#
                                         (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R
                                      ->_R ((# (GHC.Prim.State#
                                                  (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R,
                                               <()>_R #))_R))
                                  s#
                                    `cast`
                                  (GHC.Prim.State#
                                     (Trans
                                          (UnivCo mkUnsafeCo nominal (Control.Monad.Primitive.PrimState
                                                                        m) GHC.Prim.RealWorld)
                                          (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0]))))_R)
                                 `cast`
                               ((# (GHC.Prim.State#
                                      (Trans
                                           (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])
                                           (UnivCo mkUnsafeCo nominal GHC.Prim.RealWorld (Control.Monad.Primitive.PrimState
                                                                                            m))))_R,
                                   UnivCo mkUnsafeCo representational () GHC.Prim.Any #))_R of ds1 { (#,#) ipv ipv1 ->
                          (# ipv, GHC.Tuple.() #) } }) })
                      (case cs
                              `cast`
                            (Trans
                                 (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                           <Control.Monad.Primitive.PrimState m>_N))
                                 (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                      <Control.Monad.Primitive.PrimState
                                         m>_N)) of wild2 { Data.Vector.Primitive.Mutable.MVector dt4 dt5 dt6 ->
                       Control.Monad.Primitive.primitive
                         @ m
                         $dPrimMonad
                         @ ()
                         (\ s# :: GHC.Prim.State#
                                    (Control.Monad.Primitive.PrimState m)[OneShot] ->
                          case GHC.Base.id
                                 @ GHC.Types.Int
                                 (GHC.Types.I# dt4) of wild3 { GHC.Types.I# x#1 ->
                          case ((Data.Primitive.Internal.Operations.setIntArray#
                                   @ (Control.Monad.Primitive.PrimState m)
                                   dt6
                                   (GHC.Int.I64# x#1)
                                     `cast`
                                   (Sym (Foreign.C.Types.NTCo:CPtrdiff[0]))
                                   (GHC.Word.W64# (GHC.Prim.int2Word# dt5))
                                     `cast`
                                   (Sym (Foreign.C.Types.NTCo:CSize[0]))
                                   dt3)
                                  `cast`
                                (Trans
                                     (GHC.Types.NTCo:IO[0] <()>_R)
                                     ((GHC.Prim.State#
                                         (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R
                                      ->_R ((# (GHC.Prim.State#
                                                  (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R,
                                               <()>_R #))_R))
                                  s#
                                    `cast`
                                  (GHC.Prim.State#
                                     (Trans
                                          (UnivCo mkUnsafeCo nominal (Control.Monad.Primitive.PrimState
                                                                        m) GHC.Prim.RealWorld)
                                          (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0]))))_R)
                                 `cast`
                               ((# (GHC.Prim.State#
                                      (Trans
                                           (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])
                                           (UnivCo mkUnsafeCo nominal GHC.Prim.RealWorld (Control.Monad.Primitive.PrimState
                                                                                            m))))_R,
                                   UnivCo mkUnsafeCo representational () GHC.Prim.Any #))_R of ds1 { (#,#) ipv ipv1 ->
                          (# ipv, GHC.Tuple.() #) } }) })) } }) -}
b13936b6226fe6ee038902e83e9bea5b
  $fMVectorMVectorMove_$cbasicUnsafeCopy ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Unboxed.Base.MVector
      (Control.Monad.Primitive.PrimState m) MoveTypes.Move
    -> Data.Vector.Unboxed.Base.MVector
         (Control.Monad.Primitive.PrimState m) MoveTypes.Move
    -> m ()
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(SL),U(1*U,C(U))><S(LSSS),1*U(A,U(U,U,U),U(U,U,U),U(U,U,U))><S,1*U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   ds :: Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m) MoveTypes.Move
                   ds1 :: Data.Vector.Unboxed.Base.MVector
                            (Control.Monad.Primitive.PrimState m) MoveTypes.Move ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                 } in
                 case ds
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:MVectorsMove[0]
                                     <Control.Monad.Primitive.PrimState m>_N))
                           (Trans
                                (MoveTypes.NTCo:R:MVectorsMove[0]
                                     <Control.Monad.Primitive.PrimState m>_N)
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,,)[0]
                                          <Control.Monad.Primitive.PrimState m>_N
                                          <GHC.Word.Word8>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N)))) of wild { Data.Vector.Unboxed.Base.MV_3 dt as1 bs1 cs1 ->
                 case ds1
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:MVectorsMove[0]
                                     <Control.Monad.Primitive.PrimState m>_N))
                           (Trans
                                (MoveTypes.NTCo:R:MVectorsMove[0]
                                     <Control.Monad.Primitive.PrimState m>_N)
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,,)[0]
                                          <Control.Monad.Primitive.PrimState m>_N
                                          <GHC.Word.Word8>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N)))) of wild1 { Data.Vector.Unboxed.Base.MV_3 dt1 as2 bs2 cs2 ->
                 GHC.Base.>>
                   @ m
                   $dMonad
                   @ ()
                   @ ()
                   (case as1
                           `cast`
                         (Trans
                              (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                        <Control.Monad.Primitive.PrimState m>_N))
                              (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                   <Control.Monad.Primitive.PrimState
                                      m>_N)) of wild2 { Data.Vector.Primitive.Mutable.MVector dt2 dt3 dt4 ->
                    case as2
                           `cast`
                         (Trans
                              (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                        <Control.Monad.Primitive.PrimState m>_N))
                              (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                   <Control.Monad.Primitive.PrimState
                                      m>_N)) of wild3 { Data.Vector.Primitive.Mutable.MVector dt5 dt6 dt7 ->
                    let {
                      sz :: GHC.Types.Int
                      = Data.Vector.Unboxed.Base.$fMVectorMVectorBool_$ssizeOf
                          (GHC.Err.undefined @ GHC.Word.Word8)
                    } in
                    Control.Monad.Primitive.primitive
                      @ m
                      $dPrimMonad
                      @ ()
                      (\ s# :: GHC.Prim.State#
                                 (Control.Monad.Primitive.PrimState m)[OneShot] ->
                       case Data.Primitive.ByteArray.unI#
                              (GHC.Num.$fNumInt_$c* (GHC.Types.I# dt3) sz) of wild4 { DEFAULT ->
                       case Data.Primitive.ByteArray.unI#
                              (GHC.Num.$fNumInt_$c* (GHC.Types.I# dt2) sz) of wild5 { DEFAULT ->
                       case Data.Primitive.ByteArray.unI#
                              (GHC.Num.$fNumInt_$c* (GHC.Types.I# dt5) sz) of wild6 { DEFAULT ->
                       case GHC.Prim.copyMutableByteArray#
                              @ (Control.Monad.Primitive.PrimState m)
                              dt7
                              wild6
                              dt4
                              wild5
                              wild4
                              s# of s'# { DEFAULT ->
                       (# s'#, GHC.Tuple.() #) } } } }) } })
                   (GHC.Base.>>
                      @ m
                      $dMonad
                      @ ()
                      @ ()
                      (case bs1
                              `cast`
                            (Trans
                                 (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                           <Control.Monad.Primitive.PrimState m>_N))
                                 (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                      <Control.Monad.Primitive.PrimState
                                         m>_N)) of wild2 { Data.Vector.Primitive.Mutable.MVector dt2 dt3 dt4 ->
                       case bs2
                              `cast`
                            (Trans
                                 (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                           <Control.Monad.Primitive.PrimState m>_N))
                                 (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                      <Control.Monad.Primitive.PrimState
                                         m>_N)) of wild3 { Data.Vector.Primitive.Mutable.MVector dt5 dt6 dt7 ->
                       let {
                         sz :: GHC.Types.Int
                         = Data.Vector.Primitive.$fVectorVectora_$ssizeOf
                             (GHC.Err.undefined @ GHC.Types.Int)
                       } in
                       Control.Monad.Primitive.primitive
                         @ m
                         $dPrimMonad
                         @ ()
                         (\ s# :: GHC.Prim.State#
                                    (Control.Monad.Primitive.PrimState m)[OneShot] ->
                          case Data.Primitive.ByteArray.unI#
                                 (GHC.Num.$fNumInt_$c* (GHC.Types.I# dt3) sz) of wild4 { DEFAULT ->
                          case Data.Primitive.ByteArray.unI#
                                 (GHC.Num.$fNumInt_$c* (GHC.Types.I# dt2) sz) of wild5 { DEFAULT ->
                          case Data.Primitive.ByteArray.unI#
                                 (GHC.Num.$fNumInt_$c* (GHC.Types.I# dt5) sz) of wild6 { DEFAULT ->
                          case GHC.Prim.copyMutableByteArray#
                                 @ (Control.Monad.Primitive.PrimState m)
                                 dt7
                                 wild6
                                 dt4
                                 wild5
                                 wild4
                                 s# of s'# { DEFAULT ->
                          (# s'#, GHC.Tuple.() #) } } } }) } })
                      (case cs1
                              `cast`
                            (Trans
                                 (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                           <Control.Monad.Primitive.PrimState m>_N))
                                 (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                      <Control.Monad.Primitive.PrimState
                                         m>_N)) of wild2 { Data.Vector.Primitive.Mutable.MVector dt2 dt3 dt4 ->
                       case cs2
                              `cast`
                            (Trans
                                 (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                           <Control.Monad.Primitive.PrimState m>_N))
                                 (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                      <Control.Monad.Primitive.PrimState
                                         m>_N)) of wild3 { Data.Vector.Primitive.Mutable.MVector dt5 dt6 dt7 ->
                       let {
                         sz :: GHC.Types.Int
                         = Data.Vector.Primitive.$fVectorVectora_$ssizeOf
                             (GHC.Err.undefined @ GHC.Types.Int)
                       } in
                       Control.Monad.Primitive.primitive
                         @ m
                         $dPrimMonad
                         @ ()
                         (\ s# :: GHC.Prim.State#
                                    (Control.Monad.Primitive.PrimState m)[OneShot] ->
                          case Data.Primitive.ByteArray.unI#
                                 (GHC.Num.$fNumInt_$c* (GHC.Types.I# dt3) sz) of wild4 { DEFAULT ->
                          case Data.Primitive.ByteArray.unI#
                                 (GHC.Num.$fNumInt_$c* (GHC.Types.I# dt2) sz) of wild5 { DEFAULT ->
                          case Data.Primitive.ByteArray.unI#
                                 (GHC.Num.$fNumInt_$c* (GHC.Types.I# dt5) sz) of wild6 { DEFAULT ->
                          case GHC.Prim.copyMutableByteArray#
                                 @ (Control.Monad.Primitive.PrimState m)
                                 dt7
                                 wild6
                                 dt4
                                 wild5
                                 wild4
                                 s# of s'# { DEFAULT ->
                          (# s'#, GHC.Tuple.() #) } } } }) } })) } }) -}
b13936b6226fe6ee038902e83e9bea5b
  $fMVectorMVectorMove_$cbasicUnsafeGrow ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Unboxed.Base.MVector
      (Control.Monad.Primitive.PrimState m) MoveTypes.Move
    -> GHC.Types.Int
    -> m (Data.Vector.Unboxed.Base.MVector
            (Control.Monad.Primitive.PrimState m) MoveTypes.Move)
  {- Arity: 3,
     Strictness: <S(SL),U(U,C(U))><L,1*U(U,U(U,U,U),U(U,U,U),U(U,U,U))><L,U(U)>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   eta :: Data.Vector.Unboxed.Base.MVector
                            (Control.Monad.Primitive.PrimState m) MoveTypes.Move
                   eta1 :: GHC.Types.Int ->
                 GHC.Base.liftM
                   @ (Data.Vector.Unboxed.Base.MVector
                        (Control.Monad.Primitive.PrimState m)
                        (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int))
                   @ (Data.Vector.Unboxed.Base.MVector
                        (Control.Monad.Primitive.PrimState m) MoveTypes.Move)
                   @ m
                   (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                   (\ tpl :: Data.Vector.Unboxed.Base.MVector
                               (Control.Monad.Primitive.PrimState m)
                               (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int) ->
                    tpl)
                     `cast`
                   (<Data.Vector.Unboxed.Base.MVector
                       (Control.Monad.Primitive.PrimState m)
                       (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int)>_R
                    ->_R Trans
                             (Sym (MoveTypes.NTCo:R:MVectorsMove[0]
                                       <Control.Monad.Primitive.PrimState m>_N))
                             (Sub (Sym (MoveTypes.TFCo:R:MVectorsMove[0]
                                            <Control.Monad.Primitive.PrimState m>_N))))
                   (let {
                      $dMonad :: GHC.Base.Monad m
                      = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                    } in
                    case eta
                           `cast`
                         (Trans
                              (Sub (MoveTypes.TFCo:R:MVectorsMove[0]
                                        <Control.Monad.Primitive.PrimState m>_N))
                              (Trans
                                   (MoveTypes.NTCo:R:MVectorsMove[0]
                                        <Control.Monad.Primitive.PrimState m>_N)
                                   (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,,)[0]
                                             <Control.Monad.Primitive.PrimState m>_N
                                             <GHC.Word.Word8>_N
                                             <GHC.Types.Int>_N
                                             <GHC.Types.Int>_N)))) of wild { Data.Vector.Unboxed.Base.MV_3 dt as bs cs ->
                    let {
                      n_ :: GHC.Types.Int = GHC.Types.I# dt
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                      @ (Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m)
                           (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int))
                      (GHC.Base.liftM
                         @ (Data.Vector.Primitive.Mutable.MVector
                              (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                         @ (Data.Vector.Unboxed.Base.MVector
                              (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                         @ m
                         (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                         (\ tpl :: Data.Vector.Primitive.Mutable.MVector
                                     (Control.Monad.Primitive.PrimState m) GHC.Word.Word8 ->
                          tpl)
                           `cast`
                         (<Data.Vector.Primitive.Mutable.MVector
                             (Control.Monad.Primitive.PrimState m) GHC.Word.Word8>_R
                          ->_R Trans
                                   (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                             <Control.Monad.Primitive.PrimState m>_N))
                                   (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                                  <Control.Monad.Primitive.PrimState m>_N))))
                         (let {
                            $dMonad1 :: GHC.Base.Monad m
                            = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                          } in
                          let {
                            n :: GHC.Types.Int
                            = Data.Vector.Unboxed.Base.$fMVectorMVectorBool2
                                @ (Control.Monad.Primitive.PrimState m)
                                as
                                  `cast`
                                (Trans
                                     (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                               <Control.Monad.Primitive.PrimState m>_N))
                                     (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                          <Control.Monad.Primitive.PrimState m>_N))
                          } in
                          GHC.Base.>>=
                            @ m
                            $dMonad1
                            @ (Data.Vector.Primitive.Mutable.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                            @ (Data.Vector.Primitive.Mutable.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                            (let {
                               size :: GHC.Types.Int
                               = Data.Vector.Unboxed.Base.$fMVectorMVectorBool_$ssizeOf
                                   (GHC.Err.undefined @ GHC.Word.Word8)
                             } in
                             case GHC.Num.$fNumInt_$c+ n eta1 of wild1 { GHC.Types.I# x ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.<# x 0) of wild2 {
                               GHC.Types.False
                               -> case GHC.Real.$fIntegralInt_$cdiv
                                         GHC.Base.maxInt
                                         size of wild3 { GHC.Types.I# y ->
                                  case GHC.Prim.tagToEnum#
                                         @ GHC.Types.Bool
                                         (GHC.Prim.># x y) of wild4 {
                                    GHC.Types.False
                                    -> GHC.Base.liftM
                                         @ (Data.Primitive.ByteArray.MutableByteArray
                                              (Control.Monad.Primitive.PrimState m))
                                         @ (Data.Vector.Primitive.Mutable.MVector
                                              (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                                         @ m
                                         (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                                         (Data.Vector.Primitive.Mutable.$WMVector
                                            @ (Control.Monad.Primitive.PrimState m)
                                            @ GHC.Word.Word8
                                            (GHC.Types.I# 0)
                                            wild1)
                                         (case GHC.Num.$fNumInt_$c*
                                                 wild1
                                                 size of wild5 { GHC.Types.I# n# ->
                                          Control.Monad.Primitive.primitive
                                            @ m
                                            $dPrimMonad
                                            @ (Data.Primitive.ByteArray.MutableByteArray
                                                 (Control.Monad.Primitive.PrimState m))
                                            (\ s# :: GHC.Prim.State#
                                                       (Control.Monad.Primitive.PrimState
                                                          m)[OneShot] ->
                                             case GHC.Prim.newByteArray#
                                                    @ (Control.Monad.Primitive.PrimState m)
                                                    n#
                                                    s# of ds1 { (#,#) ipv ipv1 ->
                                             (# ipv,
                                                Data.Primitive.ByteArray.MutableByteArray
                                                  @ (Control.Monad.Primitive.PrimState m)
                                                  ipv1 #) }) })
                                    GHC.Types.True
                                    -> GHC.Base.$
                                         @ [GHC.Types.Char]
                                         @ (m (Data.Vector.Primitive.Mutable.MVector
                                                 (Control.Monad.Primitive.PrimState m)
                                                 GHC.Word.Word8))
                                         (GHC.Err.error
                                            @ (m (Data.Vector.Primitive.Mutable.MVector
                                                    (Control.Monad.Primitive.PrimState m)
                                                    GHC.Word.Word8)))
                                         (GHC.Base.augment
                                            @ GHC.Types.Char
                                            (\ @ b
                                               c :: GHC.Types.Char -> b -> b[OneShot]
                                               n1 :: b[OneShot] ->
                                             GHC.CString.unpackFoldrCString#
                                               @ b
                                               "Primitive.basicUnsafeNew: length to large: "#
                                               c
                                               n1)
                                            (GHC.Show.$fShowInt_$cshow wild1)) } }
                               GHC.Types.True
                               -> GHC.Base.$
                                    @ [GHC.Types.Char]
                                    @ (m (Data.Vector.Primitive.Mutable.MVector
                                            (Control.Monad.Primitive.PrimState m) GHC.Word.Word8))
                                    (GHC.Err.error
                                       @ (m (Data.Vector.Primitive.Mutable.MVector
                                               (Control.Monad.Primitive.PrimState m)
                                               GHC.Word.Word8)))
                                    (GHC.Base.augment
                                       @ GHC.Types.Char
                                       (\ @ b
                                          c :: GHC.Types.Char -> b -> b[OneShot]
                                          n1 :: b[OneShot] ->
                                        GHC.CString.unpackFoldrCString#
                                          @ b
                                          "Primitive.basicUnsafeNew: negative length: "#
                                          c
                                          n1)
                                       (GHC.Show.$fShowInt_$cshow wild1)) } })
                            (\ v' :: Data.Vector.Primitive.Mutable.MVector
                                       (Control.Monad.Primitive.PrimState m) GHC.Word.Word8 ->
                             GHC.Base.>>
                               @ m
                               $dMonad1
                               @ ()
                               @ (Data.Vector.Primitive.Mutable.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                               (case Data.Vector.Unboxed.Base.$fMVectorMVectorBool1
                                       @ (Control.Monad.Primitive.PrimState m)
                                       (GHC.Types.I# 0)
                                       n
                                       v' of wild1 { Data.Vector.Primitive.Mutable.MVector dt1 dt2 dt3 ->
                                case as
                                       `cast`
                                     (Trans
                                          (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                                    <Control.Monad.Primitive.PrimState m>_N))
                                          (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                               <Control.Monad.Primitive.PrimState
                                                  m>_N)) of wild2 { Data.Vector.Primitive.Mutable.MVector dt4 dt5 dt6 ->
                                let {
                                  sz :: GHC.Types.Int
                                  = Data.Vector.Unboxed.Base.$fMVectorMVectorBool_$ssizeOf
                                      (GHC.Err.undefined @ GHC.Word.Word8)
                                } in
                                Control.Monad.Primitive.primitive
                                  @ m
                                  $dPrimMonad
                                  @ ()
                                  (\ s# :: GHC.Prim.State#
                                             (Control.Monad.Primitive.PrimState m)[OneShot] ->
                                   case Data.Primitive.ByteArray.unI#
                                          (GHC.Num.$fNumInt_$c*
                                             (GHC.Types.I# dt2)
                                             sz) of wild3 { DEFAULT ->
                                   case Data.Primitive.ByteArray.unI#
                                          (GHC.Num.$fNumInt_$c*
                                             (GHC.Types.I# dt1)
                                             sz) of wild4 { DEFAULT ->
                                   case Data.Primitive.ByteArray.unI#
                                          (GHC.Num.$fNumInt_$c*
                                             (GHC.Types.I# dt4)
                                             sz) of wild5 { DEFAULT ->
                                   case GHC.Prim.copyMutableByteArray#
                                          @ (Control.Monad.Primitive.PrimState m)
                                          dt6
                                          wild5
                                          dt3
                                          wild4
                                          wild3
                                          s# of s'# { DEFAULT ->
                                   (# s'#, GHC.Tuple.() #) } } } }) } })
                               (GHC.Base.return
                                  @ m
                                  $dMonad1
                                  @ (Data.Vector.Primitive.Mutable.MVector
                                       (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                                  v'))))
                      (\ as' :: Data.Vector.Unboxed.Base.MVector
                                  (Control.Monad.Primitive.PrimState m) GHC.Word.Word8 ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (Data.Vector.Unboxed.Base.MVector
                              (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                         @ (Data.Vector.Unboxed.Base.MVector
                              (Control.Monad.Primitive.PrimState m)
                              (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int))
                         (GHC.Base.liftM
                            @ (Data.Vector.Primitive.Mutable.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                            @ (Data.Vector.Unboxed.Base.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                            @ m
                            (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                            (\ tpl :: Data.Vector.Primitive.Mutable.MVector
                                        (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                             tpl)
                              `cast`
                            (<Data.Vector.Primitive.Mutable.MVector
                                (Control.Monad.Primitive.PrimState m) GHC.Types.Int>_R
                             ->_R Trans
                                      (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                                <Control.Monad.Primitive.PrimState m>_N))
                                      (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                     <Control.Monad.Primitive.PrimState m>_N))))
                            (let {
                               $dMonad1 :: GHC.Base.Monad m
                               = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                             } in
                             let {
                               n :: GHC.Types.Int
                               = Data.Vector.Primitive.$fVectorVectora2
                                   @ (Control.Monad.Primitive.PrimState m)
                                   bs
                                     `cast`
                                   (Trans
                                        (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                  <Control.Monad.Primitive.PrimState m>_N))
                                        (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                             <Control.Monad.Primitive.PrimState m>_N))
                             } in
                             GHC.Base.>>=
                               @ m
                               $dMonad1
                               @ (Data.Vector.Primitive.Mutable.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                               @ (Data.Vector.Primitive.Mutable.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                               (let {
                                  size :: GHC.Types.Int
                                  = Data.Vector.Primitive.$fVectorVectora_$ssizeOf
                                      (GHC.Err.undefined @ GHC.Types.Int)
                                } in
                                case GHC.Num.$fNumInt_$c+ n eta1 of wild1 { GHC.Types.I# x ->
                                case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.<# x 0) of wild2 {
                                  GHC.Types.False
                                  -> case GHC.Real.$fIntegralInt_$cdiv
                                            GHC.Base.maxInt
                                            size of wild3 { GHC.Types.I# y ->
                                     case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.># x y) of wild4 {
                                       GHC.Types.False
                                       -> GHC.Base.liftM
                                            @ (Data.Primitive.ByteArray.MutableByteArray
                                                 (Control.Monad.Primitive.PrimState m))
                                            @ (Data.Vector.Primitive.Mutable.MVector
                                                 (Control.Monad.Primitive.PrimState m)
                                                 GHC.Types.Int)
                                            @ m
                                            (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                                            (Data.Vector.Primitive.Mutable.$WMVector
                                               @ (Control.Monad.Primitive.PrimState m)
                                               @ GHC.Types.Int
                                               (GHC.Types.I# 0)
                                               wild1)
                                            (case GHC.Num.$fNumInt_$c*
                                                    wild1
                                                    size of wild5 { GHC.Types.I# n# ->
                                             Control.Monad.Primitive.primitive
                                               @ m
                                               $dPrimMonad
                                               @ (Data.Primitive.ByteArray.MutableByteArray
                                                    (Control.Monad.Primitive.PrimState m))
                                               (\ s# :: GHC.Prim.State#
                                                          (Control.Monad.Primitive.PrimState
                                                             m)[OneShot] ->
                                                case GHC.Prim.newByteArray#
                                                       @ (Control.Monad.Primitive.PrimState m)
                                                       n#
                                                       s# of ds1 { (#,#) ipv ipv1 ->
                                                (# ipv,
                                                   Data.Primitive.ByteArray.MutableByteArray
                                                     @ (Control.Monad.Primitive.PrimState m)
                                                     ipv1 #) }) })
                                       GHC.Types.True
                                       -> GHC.Base.$
                                            @ [GHC.Types.Char]
                                            @ (m (Data.Vector.Primitive.Mutable.MVector
                                                    (Control.Monad.Primitive.PrimState m)
                                                    GHC.Types.Int))
                                            (GHC.Err.error
                                               @ (m (Data.Vector.Primitive.Mutable.MVector
                                                       (Control.Monad.Primitive.PrimState m)
                                                       GHC.Types.Int)))
                                            (GHC.Base.augment
                                               @ GHC.Types.Char
                                               (\ @ b
                                                  c :: GHC.Types.Char -> b -> b[OneShot]
                                                  n1 :: b[OneShot] ->
                                                GHC.CString.unpackFoldrCString#
                                                  @ b
                                                  "Primitive.basicUnsafeNew: length to large: "#
                                                  c
                                                  n1)
                                               (GHC.Show.$fShowInt_$cshow wild1)) } }
                                  GHC.Types.True
                                  -> GHC.Base.$
                                       @ [GHC.Types.Char]
                                       @ (m (Data.Vector.Primitive.Mutable.MVector
                                               (Control.Monad.Primitive.PrimState m) GHC.Types.Int))
                                       (GHC.Err.error
                                          @ (m (Data.Vector.Primitive.Mutable.MVector
                                                  (Control.Monad.Primitive.PrimState m)
                                                  GHC.Types.Int)))
                                       (GHC.Base.augment
                                          @ GHC.Types.Char
                                          (\ @ b
                                             c :: GHC.Types.Char -> b -> b[OneShot]
                                             n1 :: b[OneShot] ->
                                           GHC.CString.unpackFoldrCString#
                                             @ b
                                             "Primitive.basicUnsafeNew: negative length: "#
                                             c
                                             n1)
                                          (GHC.Show.$fShowInt_$cshow wild1)) } })
                               (\ v' :: Data.Vector.Primitive.Mutable.MVector
                                          (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                                GHC.Base.>>
                                  @ m
                                  $dMonad1
                                  @ ()
                                  @ (Data.Vector.Primitive.Mutable.MVector
                                       (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                                  (case Data.Vector.Primitive.$fVectorVectora1
                                          @ (Control.Monad.Primitive.PrimState m)
                                          (GHC.Types.I# 0)
                                          n
                                          v' of wild1 { Data.Vector.Primitive.Mutable.MVector dt1 dt2 dt3 ->
                                   case bs
                                          `cast`
                                        (Trans
                                             (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                       <Control.Monad.Primitive.PrimState m>_N))
                                             (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                                  <Control.Monad.Primitive.PrimState
                                                     m>_N)) of wild2 { Data.Vector.Primitive.Mutable.MVector dt4 dt5 dt6 ->
                                   let {
                                     sz :: GHC.Types.Int
                                     = Data.Vector.Primitive.$fVectorVectora_$ssizeOf
                                         (GHC.Err.undefined @ GHC.Types.Int)
                                   } in
                                   Control.Monad.Primitive.primitive
                                     @ m
                                     $dPrimMonad
                                     @ ()
                                     (\ s# :: GHC.Prim.State#
                                                (Control.Monad.Primitive.PrimState m)[OneShot] ->
                                      case Data.Primitive.ByteArray.unI#
                                             (GHC.Num.$fNumInt_$c*
                                                (GHC.Types.I# dt2)
                                                sz) of wild3 { DEFAULT ->
                                      case Data.Primitive.ByteArray.unI#
                                             (GHC.Num.$fNumInt_$c*
                                                (GHC.Types.I# dt1)
                                                sz) of wild4 { DEFAULT ->
                                      case Data.Primitive.ByteArray.unI#
                                             (GHC.Num.$fNumInt_$c*
                                                (GHC.Types.I# dt4)
                                                sz) of wild5 { DEFAULT ->
                                      case GHC.Prim.copyMutableByteArray#
                                             @ (Control.Monad.Primitive.PrimState m)
                                             dt6
                                             wild5
                                             dt3
                                             wild4
                                             wild3
                                             s# of s'# { DEFAULT ->
                                      (# s'#, GHC.Tuple.() #) } } } }) } })
                                  (GHC.Base.return
                                     @ m
                                     $dMonad1
                                     @ (Data.Vector.Primitive.Mutable.MVector
                                          (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                                     v'))))
                         (\ bs' :: Data.Vector.Unboxed.Base.MVector
                                     (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                          GHC.Base.>>=
                            @ m
                            $dMonad
                            @ (Data.Vector.Unboxed.Base.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                            @ (Data.Vector.Unboxed.Base.MVector
                                 (Control.Monad.Primitive.PrimState m)
                                 (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int))
                            (GHC.Base.liftM
                               @ (Data.Vector.Primitive.Mutable.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                               @ (Data.Vector.Unboxed.Base.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                               @ m
                               (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                               (\ tpl :: Data.Vector.Primitive.Mutable.MVector
                                           (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                                tpl)
                                 `cast`
                               (<Data.Vector.Primitive.Mutable.MVector
                                   (Control.Monad.Primitive.PrimState m) GHC.Types.Int>_R
                                ->_R Trans
                                         (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                                   <Control.Monad.Primitive.PrimState m>_N))
                                         (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                        <Control.Monad.Primitive.PrimState m>_N))))
                               (let {
                                  $dMonad1 :: GHC.Base.Monad m
                                  = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                                } in
                                let {
                                  n :: GHC.Types.Int
                                  = Data.Vector.Primitive.$fVectorVectora2
                                      @ (Control.Monad.Primitive.PrimState m)
                                      cs
                                        `cast`
                                      (Trans
                                           (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                     <Control.Monad.Primitive.PrimState m>_N))
                                           (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                                <Control.Monad.Primitive.PrimState m>_N))
                                } in
                                GHC.Base.>>=
                                  @ m
                                  $dMonad1
                                  @ (Data.Vector.Primitive.Mutable.MVector
                                       (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                                  @ (Data.Vector.Primitive.Mutable.MVector
                                       (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                                  (let {
                                     size :: GHC.Types.Int
                                     = Data.Vector.Primitive.$fVectorVectora_$ssizeOf
                                         (GHC.Err.undefined @ GHC.Types.Int)
                                   } in
                                   case GHC.Num.$fNumInt_$c+ n eta1 of wild1 { GHC.Types.I# x ->
                                   case GHC.Prim.tagToEnum#
                                          @ GHC.Types.Bool
                                          (GHC.Prim.<# x 0) of wild2 {
                                     GHC.Types.False
                                     -> case GHC.Real.$fIntegralInt_$cdiv
                                               GHC.Base.maxInt
                                               size of wild3 { GHC.Types.I# y ->
                                        case GHC.Prim.tagToEnum#
                                               @ GHC.Types.Bool
                                               (GHC.Prim.># x y) of wild4 {
                                          GHC.Types.False
                                          -> GHC.Base.liftM
                                               @ (Data.Primitive.ByteArray.MutableByteArray
                                                    (Control.Monad.Primitive.PrimState m))
                                               @ (Data.Vector.Primitive.Mutable.MVector
                                                    (Control.Monad.Primitive.PrimState m)
                                                    GHC.Types.Int)
                                               @ m
                                               (Control.Monad.Primitive.$p1PrimMonad
                                                  @ m
                                                  $dPrimMonad)
                                               (Data.Vector.Primitive.Mutable.$WMVector
                                                  @ (Control.Monad.Primitive.PrimState m)
                                                  @ GHC.Types.Int
                                                  (GHC.Types.I# 0)
                                                  wild1)
                                               (case GHC.Num.$fNumInt_$c*
                                                       wild1
                                                       size of wild5 { GHC.Types.I# n# ->
                                                Control.Monad.Primitive.primitive
                                                  @ m
                                                  $dPrimMonad
                                                  @ (Data.Primitive.ByteArray.MutableByteArray
                                                       (Control.Monad.Primitive.PrimState m))
                                                  (\ s# :: GHC.Prim.State#
                                                             (Control.Monad.Primitive.PrimState
                                                                m)[OneShot] ->
                                                   case GHC.Prim.newByteArray#
                                                          @ (Control.Monad.Primitive.PrimState m)
                                                          n#
                                                          s# of ds1 { (#,#) ipv ipv1 ->
                                                   (# ipv,
                                                      Data.Primitive.ByteArray.MutableByteArray
                                                        @ (Control.Monad.Primitive.PrimState m)
                                                        ipv1 #) }) })
                                          GHC.Types.True
                                          -> GHC.Base.$
                                               @ [GHC.Types.Char]
                                               @ (m (Data.Vector.Primitive.Mutable.MVector
                                                       (Control.Monad.Primitive.PrimState m)
                                                       GHC.Types.Int))
                                               (GHC.Err.error
                                                  @ (m (Data.Vector.Primitive.Mutable.MVector
                                                          (Control.Monad.Primitive.PrimState m)
                                                          GHC.Types.Int)))
                                               (GHC.Base.augment
                                                  @ GHC.Types.Char
                                                  (\ @ b
                                                     c :: GHC.Types.Char -> b -> b[OneShot]
                                                     n1 :: b[OneShot] ->
                                                   GHC.CString.unpackFoldrCString#
                                                     @ b
                                                     "Primitive.basicUnsafeNew: length to large: "#
                                                     c
                                                     n1)
                                                  (GHC.Show.$fShowInt_$cshow wild1)) } }
                                     GHC.Types.True
                                     -> GHC.Base.$
                                          @ [GHC.Types.Char]
                                          @ (m (Data.Vector.Primitive.Mutable.MVector
                                                  (Control.Monad.Primitive.PrimState m)
                                                  GHC.Types.Int))
                                          (GHC.Err.error
                                             @ (m (Data.Vector.Primitive.Mutable.MVector
                                                     (Control.Monad.Primitive.PrimState m)
                                                     GHC.Types.Int)))
                                          (GHC.Base.augment
                                             @ GHC.Types.Char
                                             (\ @ b
                                                c :: GHC.Types.Char -> b -> b[OneShot]
                                                n1 :: b[OneShot] ->
                                              GHC.CString.unpackFoldrCString#
                                                @ b
                                                "Primitive.basicUnsafeNew: negative length: "#
                                                c
                                                n1)
                                             (GHC.Show.$fShowInt_$cshow wild1)) } })
                                  (\ v' :: Data.Vector.Primitive.Mutable.MVector
                                             (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                                   GHC.Base.>>
                                     @ m
                                     $dMonad1
                                     @ ()
                                     @ (Data.Vector.Primitive.Mutable.MVector
                                          (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                                     (case Data.Vector.Primitive.$fVectorVectora1
                                             @ (Control.Monad.Primitive.PrimState m)
                                             (GHC.Types.I# 0)
                                             n
                                             v' of wild1 { Data.Vector.Primitive.Mutable.MVector dt1 dt2 dt3 ->
                                      case cs
                                             `cast`
                                           (Trans
                                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                          <Control.Monad.Primitive.PrimState m>_N))
                                                (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                                     <Control.Monad.Primitive.PrimState
                                                        m>_N)) of wild2 { Data.Vector.Primitive.Mutable.MVector dt4 dt5 dt6 ->
                                      let {
                                        sz :: GHC.Types.Int
                                        = Data.Vector.Primitive.$fVectorVectora_$ssizeOf
                                            (GHC.Err.undefined @ GHC.Types.Int)
                                      } in
                                      Control.Monad.Primitive.primitive
                                        @ m
                                        $dPrimMonad
                                        @ ()
                                        (\ s# :: GHC.Prim.State#
                                                   (Control.Monad.Primitive.PrimState m)[OneShot] ->
                                         case Data.Primitive.ByteArray.unI#
                                                (GHC.Num.$fNumInt_$c*
                                                   (GHC.Types.I# dt2)
                                                   sz) of wild3 { DEFAULT ->
                                         case Data.Primitive.ByteArray.unI#
                                                (GHC.Num.$fNumInt_$c*
                                                   (GHC.Types.I# dt1)
                                                   sz) of wild4 { DEFAULT ->
                                         case Data.Primitive.ByteArray.unI#
                                                (GHC.Num.$fNumInt_$c*
                                                   (GHC.Types.I# dt4)
                                                   sz) of wild5 { DEFAULT ->
                                         case GHC.Prim.copyMutableByteArray#
                                                @ (Control.Monad.Primitive.PrimState m)
                                                dt6
                                                wild5
                                                dt3
                                                wild4
                                                wild3
                                                s# of s'# { DEFAULT ->
                                         (# s'#, GHC.Tuple.() #) } } } }) } })
                                     (GHC.Base.return
                                        @ m
                                        $dMonad1
                                        @ (Data.Vector.Primitive.Mutable.MVector
                                             (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                                        v'))))
                            (\ cs' :: Data.Vector.Unboxed.Base.MVector
                                        (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                             GHC.Base.$
                               @ (Data.Vector.Unboxed.Base.MVector
                                    (Control.Monad.Primitive.PrimState m)
                                    (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int))
                               @ (m (Data.Vector.Unboxed.Base.MVector
                                       (Control.Monad.Primitive.PrimState m)
                                       (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int)))
                               (GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (Data.Vector.Unboxed.Base.MVector
                                       (Control.Monad.Primitive.PrimState m)
                                       (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int)))
                               (case GHC.Num.$fNumInt_$c+ eta1 n_ of dt1 { GHC.Types.I# dt2 ->
                                case as'
                                       `cast`
                                     (Trans
                                          (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                                    <Control.Monad.Primitive.PrimState m>_N))
                                          (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                               <Control.Monad.Primitive.PrimState
                                                  m>_N)) of nt { Data.Vector.Primitive.Mutable.MVector ipv ipv1 ipv2 ->
                                case bs'
                                       `cast`
                                     (Trans
                                          (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                    <Control.Monad.Primitive.PrimState m>_N))
                                          (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                               <Control.Monad.Primitive.PrimState
                                                  m>_N)) of nt1 { Data.Vector.Primitive.Mutable.MVector ipv3 ipv4 ipv5 ->
                                case cs'
                                       `cast`
                                     (Trans
                                          (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                    <Control.Monad.Primitive.PrimState m>_N))
                                          (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                               <Control.Monad.Primitive.PrimState
                                                  m>_N)) of nt2 { Data.Vector.Primitive.Mutable.MVector ipv6 ipv7 ipv8 ->
                                (Data.Vector.Unboxed.Base.MV_3
                                   @ (Control.Monad.Primitive.PrimState m)
                                   @ GHC.Word.Word8
                                   @ GHC.Types.Int
                                   @ GHC.Types.Int
                                   dt2
                                   nt
                                     `cast`
                                   (Trans
                                        (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                                  <Control.Monad.Primitive.PrimState m>_N))
                                        (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                                       <Control.Monad.Primitive.PrimState m>_N))))
                                   nt1
                                     `cast`
                                   (Trans
                                        (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                                  <Control.Monad.Primitive.PrimState m>_N))
                                        (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                       <Control.Monad.Primitive.PrimState m>_N))))
                                   nt2
                                     `cast`
                                   (Trans
                                        (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                                  <Control.Monad.Primitive.PrimState m>_N))
                                        (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                       <Control.Monad.Primitive.PrimState m>_N)))))
                                  `cast`
                                (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,,)[0]
                                               <Control.Monad.Primitive.PrimState m>_N
                                               <GHC.Word.Word8>_N
                                               <GHC.Types.Int>_N
                                               <GHC.Types.Int>_N))) } } } })))) })) -}
b13936b6226fe6ee038902e83e9bea5b
  $fMVectorMVectorMove_$cbasicUnsafeMove ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Unboxed.Base.MVector
      (Control.Monad.Primitive.PrimState m) MoveTypes.Move
    -> Data.Vector.Unboxed.Base.MVector
         (Control.Monad.Primitive.PrimState m) MoveTypes.Move
    -> m ()
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(SL),U(1*U,C(U))><S(LSSS),1*U(A,U(U,U,U),U(U,U,U),U(U,U,U))><S,1*U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   ds :: Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m) MoveTypes.Move
                   ds1 :: Data.Vector.Unboxed.Base.MVector
                            (Control.Monad.Primitive.PrimState m) MoveTypes.Move ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                 } in
                 case ds
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:MVectorsMove[0]
                                     <Control.Monad.Primitive.PrimState m>_N))
                           (Trans
                                (MoveTypes.NTCo:R:MVectorsMove[0]
                                     <Control.Monad.Primitive.PrimState m>_N)
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,,)[0]
                                          <Control.Monad.Primitive.PrimState m>_N
                                          <GHC.Word.Word8>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N)))) of wild { Data.Vector.Unboxed.Base.MV_3 dt as1 bs1 cs1 ->
                 case ds1
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:MVectorsMove[0]
                                     <Control.Monad.Primitive.PrimState m>_N))
                           (Trans
                                (MoveTypes.NTCo:R:MVectorsMove[0]
                                     <Control.Monad.Primitive.PrimState m>_N)
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,,)[0]
                                          <Control.Monad.Primitive.PrimState m>_N
                                          <GHC.Word.Word8>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N)))) of wild1 { Data.Vector.Unboxed.Base.MV_3 dt1 as2 bs2 cs2 ->
                 GHC.Base.>>
                   @ m
                   $dMonad
                   @ ()
                   @ ()
                   (Data.Vector.Unboxed.Base.$fMVectorMVectorWord8_$cbasicUnsafeMove
                      @ m
                      $dPrimMonad
                      as1
                      as2)
                   (GHC.Base.>>
                      @ m
                      $dMonad
                      @ ()
                      @ ()
                      (Data.Vector.Unboxed.Base.$fMVectorMVectorInt_$cbasicUnsafeMove
                         @ m
                         $dPrimMonad
                         bs1
                         bs2)
                      (Data.Vector.Unboxed.Base.$fMVectorMVectorInt_$cbasicUnsafeMove
                         @ m
                         $dPrimMonad
                         cs1
                         cs2)) } }) -}
b13936b6226fe6ee038902e83e9bea5b
  $fMVectorMVectorMove_$cbasicUnsafeNew ::
    Control.Monad.Primitive.PrimMonad m =>
    GHC.Types.Int
    -> m (Data.Vector.Unboxed.Base.MVector
            (Control.Monad.Primitive.PrimState m) MoveTypes.Move)
  {- Arity: 2, Strictness: <S(SL),U(U,C(U))><L,U(U)>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   eta :: GHC.Types.Int ->
                 GHC.Base.liftM
                   @ (Data.Vector.Unboxed.Base.MVector
                        (Control.Monad.Primitive.PrimState m)
                        (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int))
                   @ (Data.Vector.Unboxed.Base.MVector
                        (Control.Monad.Primitive.PrimState m) MoveTypes.Move)
                   @ m
                   (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                   (\ tpl :: Data.Vector.Unboxed.Base.MVector
                               (Control.Monad.Primitive.PrimState m)
                               (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int) ->
                    tpl)
                     `cast`
                   (<Data.Vector.Unboxed.Base.MVector
                       (Control.Monad.Primitive.PrimState m)
                       (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int)>_R
                    ->_R Trans
                             (Sym (MoveTypes.NTCo:R:MVectorsMove[0]
                                       <Control.Monad.Primitive.PrimState m>_N))
                             (Sub (Sym (MoveTypes.TFCo:R:MVectorsMove[0]
                                            <Control.Monad.Primitive.PrimState m>_N))))
                   (let {
                      $dMonad :: GHC.Base.Monad m
                      = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                    } in
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                      @ (Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m)
                           (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int))
                      (GHC.Base.liftM
                         @ (Data.Vector.Primitive.Mutable.MVector
                              (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                         @ (Data.Vector.Unboxed.Base.MVector
                              (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                         @ m
                         (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                         (\ tpl :: Data.Vector.Primitive.Mutable.MVector
                                     (Control.Monad.Primitive.PrimState m) GHC.Word.Word8 ->
                          tpl)
                           `cast`
                         (<Data.Vector.Primitive.Mutable.MVector
                             (Control.Monad.Primitive.PrimState m) GHC.Word.Word8>_R
                          ->_R Trans
                                   (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                             <Control.Monad.Primitive.PrimState m>_N))
                                   (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                                  <Control.Monad.Primitive.PrimState m>_N))))
                         (let {
                            size :: GHC.Types.Int
                            = Data.Vector.Unboxed.Base.$fMVectorMVectorBool_$ssizeOf
                                (GHC.Err.undefined @ GHC.Word.Word8)
                          } in
                          case eta of wild { GHC.Types.I# x ->
                          case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.<# x 0) of wild1 {
                            GHC.Types.False
                            -> case GHC.Real.$fIntegralInt_$cdiv
                                      GHC.Base.maxInt
                                      size of wild2 { GHC.Types.I# y ->
                               case GHC.Prim.tagToEnum#
                                      @ GHC.Types.Bool
                                      (GHC.Prim.># x y) of wild3 {
                                 GHC.Types.False
                                 -> GHC.Base.liftM
                                      @ (Data.Primitive.ByteArray.MutableByteArray
                                           (Control.Monad.Primitive.PrimState m))
                                      @ (Data.Vector.Primitive.Mutable.MVector
                                           (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                                      @ m
                                      (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                                      (Data.Vector.Primitive.Mutable.$WMVector
                                         @ (Control.Monad.Primitive.PrimState m)
                                         @ GHC.Word.Word8
                                         (GHC.Types.I# 0)
                                         wild)
                                      (case GHC.Num.$fNumInt_$c*
                                              wild
                                              size of wild4 { GHC.Types.I# n# ->
                                       Control.Monad.Primitive.primitive
                                         @ m
                                         $dPrimMonad
                                         @ (Data.Primitive.ByteArray.MutableByteArray
                                              (Control.Monad.Primitive.PrimState m))
                                         (\ s# :: GHC.Prim.State#
                                                    (Control.Monad.Primitive.PrimState
                                                       m)[OneShot] ->
                                          case GHC.Prim.newByteArray#
                                                 @ (Control.Monad.Primitive.PrimState m)
                                                 n#
                                                 s# of ds1 { (#,#) ipv ipv1 ->
                                          (# ipv,
                                             Data.Primitive.ByteArray.MutableByteArray
                                               @ (Control.Monad.Primitive.PrimState m)
                                               ipv1 #) }) })
                                 GHC.Types.True
                                 -> GHC.Base.$
                                      @ [GHC.Types.Char]
                                      @ (m (Data.Vector.Primitive.Mutable.MVector
                                              (Control.Monad.Primitive.PrimState m) GHC.Word.Word8))
                                      (GHC.Err.error
                                         @ (m (Data.Vector.Primitive.Mutable.MVector
                                                 (Control.Monad.Primitive.PrimState m)
                                                 GHC.Word.Word8)))
                                      (GHC.Base.augment
                                         @ GHC.Types.Char
                                         (\ @ b
                                            c :: GHC.Types.Char -> b -> b[OneShot]
                                            n :: b[OneShot] ->
                                          GHC.CString.unpackFoldrCString#
                                            @ b
                                            "Primitive.basicUnsafeNew: length to large: "#
                                            c
                                            n)
                                         (GHC.Show.$fShowInt_$cshow wild)) } }
                            GHC.Types.True
                            -> GHC.Base.$
                                 @ [GHC.Types.Char]
                                 @ (m (Data.Vector.Primitive.Mutable.MVector
                                         (Control.Monad.Primitive.PrimState m) GHC.Word.Word8))
                                 (GHC.Err.error
                                    @ (m (Data.Vector.Primitive.Mutable.MVector
                                            (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)))
                                 (GHC.Base.augment
                                    @ GHC.Types.Char
                                    (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                                     GHC.CString.unpackFoldrCString#
                                       @ b
                                       "Primitive.basicUnsafeNew: negative length: "#
                                       c
                                       n)
                                    (GHC.Show.$fShowInt_$cshow wild)) } }))
                      (\ as :: Data.Vector.Unboxed.Base.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Word.Word8 ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (Data.Vector.Unboxed.Base.MVector
                              (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                         @ (Data.Vector.Unboxed.Base.MVector
                              (Control.Monad.Primitive.PrimState m)
                              (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int))
                         (GHC.Base.liftM
                            @ (Data.Vector.Primitive.Mutable.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                            @ (Data.Vector.Unboxed.Base.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                            @ m
                            (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                            (\ tpl :: Data.Vector.Primitive.Mutable.MVector
                                        (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                             tpl)
                              `cast`
                            (<Data.Vector.Primitive.Mutable.MVector
                                (Control.Monad.Primitive.PrimState m) GHC.Types.Int>_R
                             ->_R Trans
                                      (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                                <Control.Monad.Primitive.PrimState m>_N))
                                      (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                     <Control.Monad.Primitive.PrimState m>_N))))
                            (let {
                               size :: GHC.Types.Int
                               = Data.Vector.Primitive.$fVectorVectora_$ssizeOf
                                   (GHC.Err.undefined @ GHC.Types.Int)
                             } in
                             case eta of wild { GHC.Types.I# x ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.<# x 0) of wild1 {
                               GHC.Types.False
                               -> case GHC.Real.$fIntegralInt_$cdiv
                                         GHC.Base.maxInt
                                         size of wild2 { GHC.Types.I# y ->
                                  case GHC.Prim.tagToEnum#
                                         @ GHC.Types.Bool
                                         (GHC.Prim.># x y) of wild3 {
                                    GHC.Types.False
                                    -> GHC.Base.liftM
                                         @ (Data.Primitive.ByteArray.MutableByteArray
                                              (Control.Monad.Primitive.PrimState m))
                                         @ (Data.Vector.Primitive.Mutable.MVector
                                              (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                                         @ m
                                         (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                                         (Data.Vector.Primitive.Mutable.$WMVector
                                            @ (Control.Monad.Primitive.PrimState m)
                                            @ GHC.Types.Int
                                            (GHC.Types.I# 0)
                                            wild)
                                         (case GHC.Num.$fNumInt_$c*
                                                 wild
                                                 size of wild4 { GHC.Types.I# n# ->
                                          Control.Monad.Primitive.primitive
                                            @ m
                                            $dPrimMonad
                                            @ (Data.Primitive.ByteArray.MutableByteArray
                                                 (Control.Monad.Primitive.PrimState m))
                                            (\ s# :: GHC.Prim.State#
                                                       (Control.Monad.Primitive.PrimState
                                                          m)[OneShot] ->
                                             case GHC.Prim.newByteArray#
                                                    @ (Control.Monad.Primitive.PrimState m)
                                                    n#
                                                    s# of ds1 { (#,#) ipv ipv1 ->
                                             (# ipv,
                                                Data.Primitive.ByteArray.MutableByteArray
                                                  @ (Control.Monad.Primitive.PrimState m)
                                                  ipv1 #) }) })
                                    GHC.Types.True
                                    -> GHC.Base.$
                                         @ [GHC.Types.Char]
                                         @ (m (Data.Vector.Primitive.Mutable.MVector
                                                 (Control.Monad.Primitive.PrimState m)
                                                 GHC.Types.Int))
                                         (GHC.Err.error
                                            @ (m (Data.Vector.Primitive.Mutable.MVector
                                                    (Control.Monad.Primitive.PrimState m)
                                                    GHC.Types.Int)))
                                         (GHC.Base.augment
                                            @ GHC.Types.Char
                                            (\ @ b
                                               c :: GHC.Types.Char -> b -> b[OneShot]
                                               n :: b[OneShot] ->
                                             GHC.CString.unpackFoldrCString#
                                               @ b
                                               "Primitive.basicUnsafeNew: length to large: "#
                                               c
                                               n)
                                            (GHC.Show.$fShowInt_$cshow wild)) } }
                               GHC.Types.True
                               -> GHC.Base.$
                                    @ [GHC.Types.Char]
                                    @ (m (Data.Vector.Primitive.Mutable.MVector
                                            (Control.Monad.Primitive.PrimState m) GHC.Types.Int))
                                    (GHC.Err.error
                                       @ (m (Data.Vector.Primitive.Mutable.MVector
                                               (Control.Monad.Primitive.PrimState m)
                                               GHC.Types.Int)))
                                    (GHC.Base.augment
                                       @ GHC.Types.Char
                                       (\ @ b
                                          c :: GHC.Types.Char -> b -> b[OneShot]
                                          n :: b[OneShot] ->
                                        GHC.CString.unpackFoldrCString#
                                          @ b
                                          "Primitive.basicUnsafeNew: negative length: "#
                                          c
                                          n)
                                       (GHC.Show.$fShowInt_$cshow wild)) } }))
                         (\ bs :: Data.Vector.Unboxed.Base.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                          GHC.Base.>>=
                            @ m
                            $dMonad
                            @ (Data.Vector.Unboxed.Base.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                            @ (Data.Vector.Unboxed.Base.MVector
                                 (Control.Monad.Primitive.PrimState m)
                                 (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int))
                            (GHC.Base.liftM
                               @ (Data.Vector.Primitive.Mutable.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                               @ (Data.Vector.Unboxed.Base.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                               @ m
                               (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                               (\ tpl :: Data.Vector.Primitive.Mutable.MVector
                                           (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                                tpl)
                                 `cast`
                               (<Data.Vector.Primitive.Mutable.MVector
                                   (Control.Monad.Primitive.PrimState m) GHC.Types.Int>_R
                                ->_R Trans
                                         (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                                   <Control.Monad.Primitive.PrimState m>_N))
                                         (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                        <Control.Monad.Primitive.PrimState m>_N))))
                               (let {
                                  size :: GHC.Types.Int
                                  = Data.Vector.Primitive.$fVectorVectora_$ssizeOf
                                      (GHC.Err.undefined @ GHC.Types.Int)
                                } in
                                case eta of wild { GHC.Types.I# x ->
                                case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.<# x 0) of wild1 {
                                  GHC.Types.False
                                  -> case GHC.Real.$fIntegralInt_$cdiv
                                            GHC.Base.maxInt
                                            size of wild2 { GHC.Types.I# y ->
                                     case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.># x y) of wild3 {
                                       GHC.Types.False
                                       -> GHC.Base.liftM
                                            @ (Data.Primitive.ByteArray.MutableByteArray
                                                 (Control.Monad.Primitive.PrimState m))
                                            @ (Data.Vector.Primitive.Mutable.MVector
                                                 (Control.Monad.Primitive.PrimState m)
                                                 GHC.Types.Int)
                                            @ m
                                            (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                                            (Data.Vector.Primitive.Mutable.$WMVector
                                               @ (Control.Monad.Primitive.PrimState m)
                                               @ GHC.Types.Int
                                               (GHC.Types.I# 0)
                                               wild)
                                            (case GHC.Num.$fNumInt_$c*
                                                    wild
                                                    size of wild4 { GHC.Types.I# n# ->
                                             Control.Monad.Primitive.primitive
                                               @ m
                                               $dPrimMonad
                                               @ (Data.Primitive.ByteArray.MutableByteArray
                                                    (Control.Monad.Primitive.PrimState m))
                                               (\ s# :: GHC.Prim.State#
                                                          (Control.Monad.Primitive.PrimState
                                                             m)[OneShot] ->
                                                case GHC.Prim.newByteArray#
                                                       @ (Control.Monad.Primitive.PrimState m)
                                                       n#
                                                       s# of ds1 { (#,#) ipv ipv1 ->
                                                (# ipv,
                                                   Data.Primitive.ByteArray.MutableByteArray
                                                     @ (Control.Monad.Primitive.PrimState m)
                                                     ipv1 #) }) })
                                       GHC.Types.True
                                       -> GHC.Base.$
                                            @ [GHC.Types.Char]
                                            @ (m (Data.Vector.Primitive.Mutable.MVector
                                                    (Control.Monad.Primitive.PrimState m)
                                                    GHC.Types.Int))
                                            (GHC.Err.error
                                               @ (m (Data.Vector.Primitive.Mutable.MVector
                                                       (Control.Monad.Primitive.PrimState m)
                                                       GHC.Types.Int)))
                                            (GHC.Base.augment
                                               @ GHC.Types.Char
                                               (\ @ b
                                                  c :: GHC.Types.Char -> b -> b[OneShot]
                                                  n :: b[OneShot] ->
                                                GHC.CString.unpackFoldrCString#
                                                  @ b
                                                  "Primitive.basicUnsafeNew: length to large: "#
                                                  c
                                                  n)
                                               (GHC.Show.$fShowInt_$cshow wild)) } }
                                  GHC.Types.True
                                  -> GHC.Base.$
                                       @ [GHC.Types.Char]
                                       @ (m (Data.Vector.Primitive.Mutable.MVector
                                               (Control.Monad.Primitive.PrimState m) GHC.Types.Int))
                                       (GHC.Err.error
                                          @ (m (Data.Vector.Primitive.Mutable.MVector
                                                  (Control.Monad.Primitive.PrimState m)
                                                  GHC.Types.Int)))
                                       (GHC.Base.augment
                                          @ GHC.Types.Char
                                          (\ @ b
                                             c :: GHC.Types.Char -> b -> b[OneShot]
                                             n :: b[OneShot] ->
                                           GHC.CString.unpackFoldrCString#
                                             @ b
                                             "Primitive.basicUnsafeNew: negative length: "#
                                             c
                                             n)
                                          (GHC.Show.$fShowInt_$cshow wild)) } }))
                            (\ cs :: Data.Vector.Unboxed.Base.MVector
                                       (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                             GHC.Base.$
                               @ (Data.Vector.Unboxed.Base.MVector
                                    (Control.Monad.Primitive.PrimState m)
                                    (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int))
                               @ (m (Data.Vector.Unboxed.Base.MVector
                                       (Control.Monad.Primitive.PrimState m)
                                       (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int)))
                               (GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (Data.Vector.Unboxed.Base.MVector
                                       (Control.Monad.Primitive.PrimState m)
                                       (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int)))
                               (Data.Vector.Unboxed.Base.$WMV_3
                                  @ (Control.Monad.Primitive.PrimState m)
                                  @ GHC.Word.Word8
                                  @ GHC.Types.Int
                                  @ GHC.Types.Int
                                  eta
                                  as
                                  bs
                                  cs)))))) -}
b13936b6226fe6ee038902e83e9bea5b
  $fMVectorMVectorMove_$cbasicUnsafeRead ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Unboxed.Base.MVector
      (Control.Monad.Primitive.PrimState m) MoveTypes.Move
    -> GHC.Types.Int -> m MoveTypes.Move
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(SL),U(U,C(U))><L,1*U(A,U(U,A,U),U(U,A,U),U(U,A,U))><L,U(U)>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   eta :: Data.Vector.Unboxed.Base.MVector
                            (Control.Monad.Primitive.PrimState m) MoveTypes.Move
                   eta1 :: GHC.Types.Int ->
                 GHC.Base.liftM
                   @ (GHC.Word.Word8, Index.Index, Index.Index)
                   @ MoveTypes.Move
                   @ m
                   (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                   (\ ds :: (GHC.Word.Word8, Index.Index, Index.Index) ->
                    case ds of wild { (,,) m1 f t ->
                    MoveTypes.$WMove
                      m1 `cast` (Sym (MoveTypes.NTCo:MoveData[0]))
                      f
                      t })
                   (let {
                      $dMonad :: GHC.Base.Monad m
                      = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                    } in
                    case eta
                           `cast`
                         (Trans
                              (Sub (MoveTypes.TFCo:R:MVectorsMove[0]
                                        <Control.Monad.Primitive.PrimState m>_N))
                              (Trans
                                   (MoveTypes.NTCo:R:MVectorsMove[0]
                                        <Control.Monad.Primitive.PrimState m>_N)
                                   (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,,)[0]
                                             <Control.Monad.Primitive.PrimState m>_N
                                             <GHC.Word.Word8>_N
                                             <GHC.Types.Int>_N
                                             <GHC.Types.Int>_N)))) of wild { Data.Vector.Unboxed.Base.MV_3 dt as bs cs ->
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ GHC.Word.Word8
                      @ (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int)
                      (case as
                              `cast`
                            (Trans
                                 (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                           <Control.Monad.Primitive.PrimState m>_N))
                                 (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                      <Control.Monad.Primitive.PrimState
                                         m>_N)) of wild1 { Data.Vector.Primitive.Mutable.MVector dt1 dt2 dt3 ->
                       case GHC.Num.$fNumInt_$c+
                              (GHC.Types.I# dt1)
                              eta1 of wild2 { GHC.Types.I# i# ->
                       Control.Monad.Primitive.primitive
                         @ m
                         $dPrimMonad
                         @ GHC.Word.Word8
                         (Data.Primitive.Types.$fPrimWord8_$creadByteArray#
                            @ (Control.Monad.Primitive.PrimState m)
                            dt3
                            i#) } })
                      (\ a21 :: GHC.Word.Word8 ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ GHC.Types.Int
                         @ (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int)
                         (case bs
                                 `cast`
                               (Trans
                                    (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                              <Control.Monad.Primitive.PrimState m>_N))
                                    (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                         <Control.Monad.Primitive.PrimState
                                            m>_N)) of wild1 { Data.Vector.Primitive.Mutable.MVector dt1 dt2 dt3 ->
                          case GHC.Num.$fNumInt_$c+
                                 (GHC.Types.I# dt1)
                                 eta1 of wild2 { GHC.Types.I# i# ->
                          Control.Monad.Primitive.primitive
                            @ m
                            $dPrimMonad
                            @ GHC.Types.Int
                            (Data.Primitive.Types.$fPrimInt_$creadByteArray#
                               @ (Control.Monad.Primitive.PrimState m)
                               dt3
                               i#) } })
                         (\ b1 :: GHC.Types.Int ->
                          GHC.Base.>>=
                            @ m
                            $dMonad
                            @ GHC.Types.Int
                            @ (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int)
                            (case cs
                                    `cast`
                                  (Trans
                                       (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                 <Control.Monad.Primitive.PrimState m>_N))
                                       (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                            <Control.Monad.Primitive.PrimState
                                               m>_N)) of wild1 { Data.Vector.Primitive.Mutable.MVector dt1 dt2 dt3 ->
                             case GHC.Num.$fNumInt_$c+
                                    (GHC.Types.I# dt1)
                                    eta1 of wild2 { GHC.Types.I# i# ->
                             Control.Monad.Primitive.primitive
                               @ m
                               $dPrimMonad
                               @ GHC.Types.Int
                               (Data.Primitive.Types.$fPrimInt_$creadByteArray#
                                  @ (Control.Monad.Primitive.PrimState m)
                                  dt3
                                  i#) } })
                            (\ c1 :: GHC.Types.Int ->
                             GHC.Base.return
                               @ m
                               $dMonad
                               @ (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int)
                               (a21, b1, c1)))) })) -}
b13936b6226fe6ee038902e83e9bea5b
  $fMVectorMVectorMove_$cbasicUnsafeReplicate ::
    Control.Monad.Primitive.PrimMonad m =>
    GHC.Types.Int
    -> MoveTypes.Move
    -> m (Data.Vector.Unboxed.Base.MVector
            (Control.Monad.Primitive.PrimState m) MoveTypes.Move)
  {- Arity: 3, Strictness: <S(SL),U(U,C(U))><L,U(U)><L,1*U(U,U,U)>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   eta :: GHC.Types.Int
                   eta1 :: MoveTypes.Move ->
                 GHC.Base.liftM
                   @ (Data.Vector.Unboxed.Base.MVector
                        (Control.Monad.Primitive.PrimState m)
                        (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int))
                   @ (Data.Vector.Unboxed.Base.MVector
                        (Control.Monad.Primitive.PrimState m) MoveTypes.Move)
                   @ m
                   (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                   (\ tpl :: Data.Vector.Unboxed.Base.MVector
                               (Control.Monad.Primitive.PrimState m)
                               (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int) ->
                    tpl)
                     `cast`
                   (<Data.Vector.Unboxed.Base.MVector
                       (Control.Monad.Primitive.PrimState m)
                       (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int)>_R
                    ->_R Trans
                             (Sym (MoveTypes.NTCo:R:MVectorsMove[0]
                                       <Control.Monad.Primitive.PrimState m>_N))
                             (Sub (Sym (MoveTypes.TFCo:R:MVectorsMove[0]
                                            <Control.Monad.Primitive.PrimState m>_N))))
                   (let {
                      $dMonad :: GHC.Base.Monad m
                      = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                    } in
                    case eta1 of wild { MoveTypes.Move dt dt1 dt2 ->
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                      @ (Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m)
                           (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int))
                      (GHC.Base.liftM
                         @ (Data.Vector.Primitive.Mutable.MVector
                              (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                         @ (Data.Vector.Unboxed.Base.MVector
                              (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                         @ m
                         (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                         (\ tpl :: Data.Vector.Primitive.Mutable.MVector
                                     (Control.Monad.Primitive.PrimState m) GHC.Word.Word8 ->
                          tpl)
                           `cast`
                         (<Data.Vector.Primitive.Mutable.MVector
                             (Control.Monad.Primitive.PrimState m) GHC.Word.Word8>_R
                          ->_R Trans
                                   (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                             <Control.Monad.Primitive.PrimState m>_N))
                                   (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                                  <Control.Monad.Primitive.PrimState m>_N))))
                         (let {
                            $dMonad1 :: GHC.Base.Monad m
                            = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                          } in
                          GHC.Base.>>=
                            @ m
                            $dMonad1
                            @ (Data.Vector.Primitive.Mutable.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                            @ (Data.Vector.Primitive.Mutable.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                            (let {
                               size :: GHC.Types.Int
                               = Data.Vector.Unboxed.Base.$fMVectorMVectorBool_$ssizeOf
                                   (GHC.Err.undefined @ GHC.Word.Word8)
                             } in
                             case eta of wild1 { GHC.Types.I# x ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.<# x 0) of wild2 {
                               GHC.Types.False
                               -> case GHC.Real.$fIntegralInt_$cdiv
                                         GHC.Base.maxInt
                                         size of wild3 { GHC.Types.I# y ->
                                  case GHC.Prim.tagToEnum#
                                         @ GHC.Types.Bool
                                         (GHC.Prim.># x y) of wild4 {
                                    GHC.Types.False
                                    -> GHC.Base.liftM
                                         @ (Data.Primitive.ByteArray.MutableByteArray
                                              (Control.Monad.Primitive.PrimState m))
                                         @ (Data.Vector.Primitive.Mutable.MVector
                                              (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                                         @ m
                                         (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                                         (Data.Vector.Primitive.Mutable.$WMVector
                                            @ (Control.Monad.Primitive.PrimState m)
                                            @ GHC.Word.Word8
                                            (GHC.Types.I# 0)
                                            wild1)
                                         (case GHC.Num.$fNumInt_$c*
                                                 wild1
                                                 size of wild5 { GHC.Types.I# n# ->
                                          Control.Monad.Primitive.primitive
                                            @ m
                                            $dPrimMonad
                                            @ (Data.Primitive.ByteArray.MutableByteArray
                                                 (Control.Monad.Primitive.PrimState m))
                                            (\ s# :: GHC.Prim.State#
                                                       (Control.Monad.Primitive.PrimState
                                                          m)[OneShot] ->
                                             case GHC.Prim.newByteArray#
                                                    @ (Control.Monad.Primitive.PrimState m)
                                                    n#
                                                    s# of ds1 { (#,#) ipv ipv1 ->
                                             (# ipv,
                                                Data.Primitive.ByteArray.MutableByteArray
                                                  @ (Control.Monad.Primitive.PrimState m)
                                                  ipv1 #) }) })
                                    GHC.Types.True
                                    -> GHC.Base.$
                                         @ [GHC.Types.Char]
                                         @ (m (Data.Vector.Primitive.Mutable.MVector
                                                 (Control.Monad.Primitive.PrimState m)
                                                 GHC.Word.Word8))
                                         (GHC.Err.error
                                            @ (m (Data.Vector.Primitive.Mutable.MVector
                                                    (Control.Monad.Primitive.PrimState m)
                                                    GHC.Word.Word8)))
                                         (GHC.Base.augment
                                            @ GHC.Types.Char
                                            (\ @ b
                                               c :: GHC.Types.Char -> b -> b[OneShot]
                                               n :: b[OneShot] ->
                                             GHC.CString.unpackFoldrCString#
                                               @ b
                                               "Primitive.basicUnsafeNew: length to large: "#
                                               c
                                               n)
                                            (GHC.Show.$fShowInt_$cshow wild1)) } }
                               GHC.Types.True
                               -> GHC.Base.$
                                    @ [GHC.Types.Char]
                                    @ (m (Data.Vector.Primitive.Mutable.MVector
                                            (Control.Monad.Primitive.PrimState m) GHC.Word.Word8))
                                    (GHC.Err.error
                                       @ (m (Data.Vector.Primitive.Mutable.MVector
                                               (Control.Monad.Primitive.PrimState m)
                                               GHC.Word.Word8)))
                                    (GHC.Base.augment
                                       @ GHC.Types.Char
                                       (\ @ b
                                          c :: GHC.Types.Char -> b -> b[OneShot]
                                          n :: b[OneShot] ->
                                        GHC.CString.unpackFoldrCString#
                                          @ b
                                          "Primitive.basicUnsafeNew: negative length: "#
                                          c
                                          n)
                                       (GHC.Show.$fShowInt_$cshow wild1)) } })
                            (\ v1 :: Data.Vector.Primitive.Mutable.MVector
                                       (Control.Monad.Primitive.PrimState m) GHC.Word.Word8 ->
                             GHC.Base.>>
                               @ m
                               $dMonad1
                               @ ()
                               @ (Data.Vector.Primitive.Mutable.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                               (case v1 of wild1 { Data.Vector.Primitive.Mutable.MVector dt3 dt4 dt5 ->
                                Control.Monad.Primitive.primitive
                                  @ m
                                  $dPrimMonad
                                  @ ()
                                  (\ s# :: GHC.Prim.State#
                                             (Control.Monad.Primitive.PrimState m)[OneShot] ->
                                   case GHC.Base.id
                                          @ GHC.Types.Int
                                          (GHC.Types.I# dt3) of wild2 { GHC.Types.I# x#1 ->
                                   case ((Data.Primitive.Internal.Operations.setWord8Array#
                                            @ (Control.Monad.Primitive.PrimState m)
                                            dt5
                                            (GHC.Int.I64# x#1)
                                              `cast`
                                            (Sym (Foreign.C.Types.NTCo:CPtrdiff[0]))
                                            (GHC.Word.W64# (GHC.Prim.int2Word# dt4))
                                              `cast`
                                            (Sym (Foreign.C.Types.NTCo:CSize[0]))
                                            dt)
                                           `cast`
                                         (Trans
                                              (GHC.Types.NTCo:IO[0] <()>_R)
                                              ((GHC.Prim.State#
                                                  (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R
                                               ->_R ((# (GHC.Prim.State#
                                                           (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R,
                                                        <()>_R #))_R))
                                           s#
                                             `cast`
                                           (GHC.Prim.State#
                                              (Trans
                                                   (UnivCo mkUnsafeCo nominal (Control.Monad.Primitive.PrimState
                                                                                 m) GHC.Prim.RealWorld)
                                                   (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0]))))_R)
                                          `cast`
                                        ((# (GHC.Prim.State#
                                               (Trans
                                                    (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])
                                                    (UnivCo mkUnsafeCo nominal GHC.Prim.RealWorld (Control.Monad.Primitive.PrimState
                                                                                                     m))))_R,
                                            UnivCo mkUnsafeCo representational () GHC.Prim.Any #))_R of ds1 { (#,#) ipv ipv1 ->
                                   (# ipv, GHC.Tuple.() #) } }) })
                               (GHC.Base.return
                                  @ m
                                  $dMonad1
                                  @ (Data.Vector.Primitive.Mutable.MVector
                                       (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                                  v1))))
                      (\ as :: Data.Vector.Unboxed.Base.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Word.Word8 ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (Data.Vector.Unboxed.Base.MVector
                              (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                         @ (Data.Vector.Unboxed.Base.MVector
                              (Control.Monad.Primitive.PrimState m)
                              (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int))
                         (GHC.Base.liftM
                            @ (Data.Vector.Primitive.Mutable.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                            @ (Data.Vector.Unboxed.Base.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                            @ m
                            (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                            (\ tpl :: Data.Vector.Primitive.Mutable.MVector
                                        (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                             tpl)
                              `cast`
                            (<Data.Vector.Primitive.Mutable.MVector
                                (Control.Monad.Primitive.PrimState m) GHC.Types.Int>_R
                             ->_R Trans
                                      (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                                <Control.Monad.Primitive.PrimState m>_N))
                                      (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                     <Control.Monad.Primitive.PrimState m>_N))))
                            (let {
                               $dMonad1 :: GHC.Base.Monad m
                               = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                             } in
                             GHC.Base.>>=
                               @ m
                               $dMonad1
                               @ (Data.Vector.Primitive.Mutable.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                               @ (Data.Vector.Primitive.Mutable.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                               (let {
                                  size :: GHC.Types.Int
                                  = Data.Vector.Primitive.$fVectorVectora_$ssizeOf
                                      (GHC.Err.undefined @ GHC.Types.Int)
                                } in
                                case eta of wild1 { GHC.Types.I# x ->
                                case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.<# x 0) of wild2 {
                                  GHC.Types.False
                                  -> case GHC.Real.$fIntegralInt_$cdiv
                                            GHC.Base.maxInt
                                            size of wild3 { GHC.Types.I# y ->
                                     case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.># x y) of wild4 {
                                       GHC.Types.False
                                       -> GHC.Base.liftM
                                            @ (Data.Primitive.ByteArray.MutableByteArray
                                                 (Control.Monad.Primitive.PrimState m))
                                            @ (Data.Vector.Primitive.Mutable.MVector
                                                 (Control.Monad.Primitive.PrimState m)
                                                 GHC.Types.Int)
                                            @ m
                                            (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                                            (Data.Vector.Primitive.Mutable.$WMVector
                                               @ (Control.Monad.Primitive.PrimState m)
                                               @ GHC.Types.Int
                                               (GHC.Types.I# 0)
                                               wild1)
                                            (case GHC.Num.$fNumInt_$c*
                                                    wild1
                                                    size of wild5 { GHC.Types.I# n# ->
                                             Control.Monad.Primitive.primitive
                                               @ m
                                               $dPrimMonad
                                               @ (Data.Primitive.ByteArray.MutableByteArray
                                                    (Control.Monad.Primitive.PrimState m))
                                               (\ s# :: GHC.Prim.State#
                                                          (Control.Monad.Primitive.PrimState
                                                             m)[OneShot] ->
                                                case GHC.Prim.newByteArray#
                                                       @ (Control.Monad.Primitive.PrimState m)
                                                       n#
                                                       s# of ds1 { (#,#) ipv ipv1 ->
                                                (# ipv,
                                                   Data.Primitive.ByteArray.MutableByteArray
                                                     @ (Control.Monad.Primitive.PrimState m)
                                                     ipv1 #) }) })
                                       GHC.Types.True
                                       -> GHC.Base.$
                                            @ [GHC.Types.Char]
                                            @ (m (Data.Vector.Primitive.Mutable.MVector
                                                    (Control.Monad.Primitive.PrimState m)
                                                    GHC.Types.Int))
                                            (GHC.Err.error
                                               @ (m (Data.Vector.Primitive.Mutable.MVector
                                                       (Control.Monad.Primitive.PrimState m)
                                                       GHC.Types.Int)))
                                            (GHC.Base.augment
                                               @ GHC.Types.Char
                                               (\ @ b
                                                  c :: GHC.Types.Char -> b -> b[OneShot]
                                                  n :: b[OneShot] ->
                                                GHC.CString.unpackFoldrCString#
                                                  @ b
                                                  "Primitive.basicUnsafeNew: length to large: "#
                                                  c
                                                  n)
                                               (GHC.Show.$fShowInt_$cshow wild1)) } }
                                  GHC.Types.True
                                  -> GHC.Base.$
                                       @ [GHC.Types.Char]
                                       @ (m (Data.Vector.Primitive.Mutable.MVector
                                               (Control.Monad.Primitive.PrimState m) GHC.Types.Int))
                                       (GHC.Err.error
                                          @ (m (Data.Vector.Primitive.Mutable.MVector
                                                  (Control.Monad.Primitive.PrimState m)
                                                  GHC.Types.Int)))
                                       (GHC.Base.augment
                                          @ GHC.Types.Char
                                          (\ @ b
                                             c :: GHC.Types.Char -> b -> b[OneShot]
                                             n :: b[OneShot] ->
                                           GHC.CString.unpackFoldrCString#
                                             @ b
                                             "Primitive.basicUnsafeNew: negative length: "#
                                             c
                                             n)
                                          (GHC.Show.$fShowInt_$cshow wild1)) } })
                               (\ v1 :: Data.Vector.Primitive.Mutable.MVector
                                          (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                                GHC.Base.>>
                                  @ m
                                  $dMonad1
                                  @ ()
                                  @ (Data.Vector.Primitive.Mutable.MVector
                                       (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                                  (case v1 of wild1 { Data.Vector.Primitive.Mutable.MVector dt3 dt4 dt5 ->
                                   Control.Monad.Primitive.primitive
                                     @ m
                                     $dPrimMonad
                                     @ ()
                                     (\ s# :: GHC.Prim.State#
                                                (Control.Monad.Primitive.PrimState m)[OneShot] ->
                                      case GHC.Base.id
                                             @ GHC.Types.Int
                                             (GHC.Types.I# dt3) of wild2 { GHC.Types.I# x#1 ->
                                      case ((Data.Primitive.Internal.Operations.setIntArray#
                                               @ (Control.Monad.Primitive.PrimState m)
                                               dt5
                                               (GHC.Int.I64# x#1)
                                                 `cast`
                                               (Sym (Foreign.C.Types.NTCo:CPtrdiff[0]))
                                               (GHC.Word.W64# (GHC.Prim.int2Word# dt4))
                                                 `cast`
                                               (Sym (Foreign.C.Types.NTCo:CSize[0]))
                                               dt1)
                                              `cast`
                                            (Trans
                                                 (GHC.Types.NTCo:IO[0] <()>_R)
                                                 ((GHC.Prim.State#
                                                     (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R
                                                  ->_R ((# (GHC.Prim.State#
                                                              (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R,
                                                           <()>_R #))_R))
                                              s#
                                                `cast`
                                              (GHC.Prim.State#
                                                 (Trans
                                                      (UnivCo mkUnsafeCo nominal (Control.Monad.Primitive.PrimState
                                                                                    m) GHC.Prim.RealWorld)
                                                      (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0]))))_R)
                                             `cast`
                                           ((# (GHC.Prim.State#
                                                  (Trans
                                                       (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])
                                                       (UnivCo mkUnsafeCo nominal GHC.Prim.RealWorld (Control.Monad.Primitive.PrimState
                                                                                                        m))))_R,
                                               UnivCo mkUnsafeCo representational () GHC.Prim.Any #))_R of ds1 { (#,#) ipv ipv1 ->
                                      (# ipv, GHC.Tuple.() #) } }) })
                                  (GHC.Base.return
                                     @ m
                                     $dMonad1
                                     @ (Data.Vector.Primitive.Mutable.MVector
                                          (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                                     v1))))
                         (\ bs :: Data.Vector.Unboxed.Base.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                          GHC.Base.>>=
                            @ m
                            $dMonad
                            @ (Data.Vector.Unboxed.Base.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                            @ (Data.Vector.Unboxed.Base.MVector
                                 (Control.Monad.Primitive.PrimState m)
                                 (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int))
                            (GHC.Base.liftM
                               @ (Data.Vector.Primitive.Mutable.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                               @ (Data.Vector.Unboxed.Base.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                               @ m
                               (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                               (\ tpl :: Data.Vector.Primitive.Mutable.MVector
                                           (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                                tpl)
                                 `cast`
                               (<Data.Vector.Primitive.Mutable.MVector
                                   (Control.Monad.Primitive.PrimState m) GHC.Types.Int>_R
                                ->_R Trans
                                         (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                                   <Control.Monad.Primitive.PrimState m>_N))
                                         (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                        <Control.Monad.Primitive.PrimState m>_N))))
                               (let {
                                  $dMonad1 :: GHC.Base.Monad m
                                  = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                                } in
                                GHC.Base.>>=
                                  @ m
                                  $dMonad1
                                  @ (Data.Vector.Primitive.Mutable.MVector
                                       (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                                  @ (Data.Vector.Primitive.Mutable.MVector
                                       (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                                  (let {
                                     size :: GHC.Types.Int
                                     = Data.Vector.Primitive.$fVectorVectora_$ssizeOf
                                         (GHC.Err.undefined @ GHC.Types.Int)
                                   } in
                                   case eta of wild1 { GHC.Types.I# x ->
                                   case GHC.Prim.tagToEnum#
                                          @ GHC.Types.Bool
                                          (GHC.Prim.<# x 0) of wild2 {
                                     GHC.Types.False
                                     -> case GHC.Real.$fIntegralInt_$cdiv
                                               GHC.Base.maxInt
                                               size of wild3 { GHC.Types.I# y ->
                                        case GHC.Prim.tagToEnum#
                                               @ GHC.Types.Bool
                                               (GHC.Prim.># x y) of wild4 {
                                          GHC.Types.False
                                          -> GHC.Base.liftM
                                               @ (Data.Primitive.ByteArray.MutableByteArray
                                                    (Control.Monad.Primitive.PrimState m))
                                               @ (Data.Vector.Primitive.Mutable.MVector
                                                    (Control.Monad.Primitive.PrimState m)
                                                    GHC.Types.Int)
                                               @ m
                                               (Control.Monad.Primitive.$p1PrimMonad
                                                  @ m
                                                  $dPrimMonad)
                                               (Data.Vector.Primitive.Mutable.$WMVector
                                                  @ (Control.Monad.Primitive.PrimState m)
                                                  @ GHC.Types.Int
                                                  (GHC.Types.I# 0)
                                                  wild1)
                                               (case GHC.Num.$fNumInt_$c*
                                                       wild1
                                                       size of wild5 { GHC.Types.I# n# ->
                                                Control.Monad.Primitive.primitive
                                                  @ m
                                                  $dPrimMonad
                                                  @ (Data.Primitive.ByteArray.MutableByteArray
                                                       (Control.Monad.Primitive.PrimState m))
                                                  (\ s# :: GHC.Prim.State#
                                                             (Control.Monad.Primitive.PrimState
                                                                m)[OneShot] ->
                                                   case GHC.Prim.newByteArray#
                                                          @ (Control.Monad.Primitive.PrimState m)
                                                          n#
                                                          s# of ds1 { (#,#) ipv ipv1 ->
                                                   (# ipv,
                                                      Data.Primitive.ByteArray.MutableByteArray
                                                        @ (Control.Monad.Primitive.PrimState m)
                                                        ipv1 #) }) })
                                          GHC.Types.True
                                          -> GHC.Base.$
                                               @ [GHC.Types.Char]
                                               @ (m (Data.Vector.Primitive.Mutable.MVector
                                                       (Control.Monad.Primitive.PrimState m)
                                                       GHC.Types.Int))
                                               (GHC.Err.error
                                                  @ (m (Data.Vector.Primitive.Mutable.MVector
                                                          (Control.Monad.Primitive.PrimState m)
                                                          GHC.Types.Int)))
                                               (GHC.Base.augment
                                                  @ GHC.Types.Char
                                                  (\ @ b
                                                     c :: GHC.Types.Char -> b -> b[OneShot]
                                                     n :: b[OneShot] ->
                                                   GHC.CString.unpackFoldrCString#
                                                     @ b
                                                     "Primitive.basicUnsafeNew: length to large: "#
                                                     c
                                                     n)
                                                  (GHC.Show.$fShowInt_$cshow wild1)) } }
                                     GHC.Types.True
                                     -> GHC.Base.$
                                          @ [GHC.Types.Char]
                                          @ (m (Data.Vector.Primitive.Mutable.MVector
                                                  (Control.Monad.Primitive.PrimState m)
                                                  GHC.Types.Int))
                                          (GHC.Err.error
                                             @ (m (Data.Vector.Primitive.Mutable.MVector
                                                     (Control.Monad.Primitive.PrimState m)
                                                     GHC.Types.Int)))
                                          (GHC.Base.augment
                                             @ GHC.Types.Char
                                             (\ @ b
                                                c :: GHC.Types.Char -> b -> b[OneShot]
                                                n :: b[OneShot] ->
                                              GHC.CString.unpackFoldrCString#
                                                @ b
                                                "Primitive.basicUnsafeNew: negative length: "#
                                                c
                                                n)
                                             (GHC.Show.$fShowInt_$cshow wild1)) } })
                                  (\ v1 :: Data.Vector.Primitive.Mutable.MVector
                                             (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                                   GHC.Base.>>
                                     @ m
                                     $dMonad1
                                     @ ()
                                     @ (Data.Vector.Primitive.Mutable.MVector
                                          (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                                     (case v1 of wild1 { Data.Vector.Primitive.Mutable.MVector dt3 dt4 dt5 ->
                                      Control.Monad.Primitive.primitive
                                        @ m
                                        $dPrimMonad
                                        @ ()
                                        (\ s# :: GHC.Prim.State#
                                                   (Control.Monad.Primitive.PrimState m)[OneShot] ->
                                         case GHC.Base.id
                                                @ GHC.Types.Int
                                                (GHC.Types.I# dt3) of wild2 { GHC.Types.I# x#1 ->
                                         case ((Data.Primitive.Internal.Operations.setIntArray#
                                                  @ (Control.Monad.Primitive.PrimState m)
                                                  dt5
                                                  (GHC.Int.I64# x#1)
                                                    `cast`
                                                  (Sym (Foreign.C.Types.NTCo:CPtrdiff[0]))
                                                  (GHC.Word.W64# (GHC.Prim.int2Word# dt4))
                                                    `cast`
                                                  (Sym (Foreign.C.Types.NTCo:CSize[0]))
                                                  dt2)
                                                 `cast`
                                               (Trans
                                                    (GHC.Types.NTCo:IO[0] <()>_R)
                                                    ((GHC.Prim.State#
                                                        (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R
                                                     ->_R ((# (GHC.Prim.State#
                                                                 (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])))_R,
                                                              <()>_R #))_R))
                                                 s#
                                                   `cast`
                                                 (GHC.Prim.State#
                                                    (Trans
                                                         (UnivCo mkUnsafeCo nominal (Control.Monad.Primitive.PrimState
                                                                                       m) GHC.Prim.RealWorld)
                                                         (Sym (Control.Monad.Primitive.TFCo:R:PrimStateIO[0]))))_R)
                                                `cast`
                                              ((# (GHC.Prim.State#
                                                     (Trans
                                                          (Control.Monad.Primitive.TFCo:R:PrimStateIO[0])
                                                          (UnivCo mkUnsafeCo nominal GHC.Prim.RealWorld (Control.Monad.Primitive.PrimState
                                                                                                           m))))_R,
                                                  UnivCo mkUnsafeCo representational () GHC.Prim.Any #))_R of ds1 { (#,#) ipv ipv1 ->
                                         (# ipv, GHC.Tuple.() #) } }) })
                                     (GHC.Base.return
                                        @ m
                                        $dMonad1
                                        @ (Data.Vector.Primitive.Mutable.MVector
                                             (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                                        v1))))
                            (\ cs :: Data.Vector.Unboxed.Base.MVector
                                       (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                             GHC.Base.$
                               @ (Data.Vector.Unboxed.Base.MVector
                                    (Control.Monad.Primitive.PrimState m)
                                    (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int))
                               @ (m (Data.Vector.Unboxed.Base.MVector
                                       (Control.Monad.Primitive.PrimState m)
                                       (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int)))
                               (GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (Data.Vector.Unboxed.Base.MVector
                                       (Control.Monad.Primitive.PrimState m)
                                       (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int)))
                               (Data.Vector.Unboxed.Base.$WMV_3
                                  @ (Control.Monad.Primitive.PrimState m)
                                  @ GHC.Word.Word8
                                  @ GHC.Types.Int
                                  @ GHC.Types.Int
                                  eta
                                  as
                                  bs
                                  cs)))) })) -}
b13936b6226fe6ee038902e83e9bea5b
  $fMVectorMVectorMove_$cbasicUnsafeSlice ::
    GHC.Types.Int
    -> GHC.Types.Int
    -> Data.Vector.Unboxed.Base.MVector s MoveTypes.Move
    -> Data.Vector.Unboxed.Base.MVector s MoveTypes.Move
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,1*U(U)><S,1*U(U)><S(LSSS),1*U(A,U(U,A,U),U(U,A,U),U(U,A,U))>m,
     Inline: INLINE (sat-args=3),
     Unfolding: InlineRule (3, False, False)
                (\ @ s
                   idx :: GHC.Types.Int
                   len :: GHC.Types.Int
                   ds :: Data.Vector.Unboxed.Base.MVector s MoveTypes.Move ->
                 case ds
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:MVectorsMove[0] <s>_N))
                           (Trans
                                (MoveTypes.NTCo:R:MVectorsMove[0] <s>_N)
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,,)[0]
                                          <s>_N
                                          <GHC.Word.Word8>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N)))) of wild { Data.Vector.Unboxed.Base.MV_3 dt as bs cs ->
                 case len of dt1 { GHC.Types.I# dt2 ->
                 case (GHC.Base.$
                         @ (Data.Vector.Primitive.Mutable.MVector s GHC.Word.Word8)
                         @ (Data.Vector.Unboxed.Base.MVector s GHC.Word.Word8)
                         (\ tpl :: Data.Vector.Primitive.Mutable.MVector s GHC.Word.Word8 ->
                          tpl)
                           `cast`
                         (<Data.Vector.Primitive.Mutable.MVector s GHC.Word.Word8>_R
                          ->_R Trans
                                   (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0] <s>_N))
                                   (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                                  <s>_N))))
                         (Data.Vector.Unboxed.Base.$fMVectorMVectorBool1
                            @ s
                            idx
                            dt1
                            as
                              `cast`
                            (Trans
                                 (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0] <s>_N))
                                 (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0] <s>_N))))
                        `cast`
                      (Trans
                           (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0] <s>_N))
                           (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                <s>_N)) of nt { Data.Vector.Primitive.Mutable.MVector ipv ipv1 ipv2 ->
                 case (GHC.Base.$
                         @ (Data.Vector.Primitive.Mutable.MVector s GHC.Types.Int)
                         @ (Data.Vector.Unboxed.Base.MVector s GHC.Types.Int)
                         (\ tpl :: Data.Vector.Primitive.Mutable.MVector s GHC.Types.Int ->
                          tpl)
                           `cast`
                         (<Data.Vector.Primitive.Mutable.MVector s GHC.Types.Int>_R
                          ->_R Trans
                                   (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0] <s>_N))
                                   (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                  <s>_N))))
                         (Data.Vector.Primitive.$fVectorVectora1
                            @ s
                            idx
                            dt1
                            bs
                              `cast`
                            (Trans
                                 (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0] <s>_N))
                                 (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0] <s>_N))))
                        `cast`
                      (Trans
                           (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0] <s>_N))
                           (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                <s>_N)) of nt1 { Data.Vector.Primitive.Mutable.MVector ipv3 ipv4 ipv5 ->
                 case (GHC.Base.$
                         @ (Data.Vector.Primitive.Mutable.MVector s GHC.Types.Int)
                         @ (Data.Vector.Unboxed.Base.MVector s GHC.Types.Int)
                         (\ tpl :: Data.Vector.Primitive.Mutable.MVector s GHC.Types.Int ->
                          tpl)
                           `cast`
                         (<Data.Vector.Primitive.Mutable.MVector s GHC.Types.Int>_R
                          ->_R Trans
                                   (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0] <s>_N))
                                   (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                  <s>_N))))
                         (Data.Vector.Primitive.$fVectorVectora1
                            @ s
                            idx
                            dt1
                            cs
                              `cast`
                            (Trans
                                 (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0] <s>_N))
                                 (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0] <s>_N))))
                        `cast`
                      (Trans
                           (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0] <s>_N))
                           (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                <s>_N)) of nt2 { Data.Vector.Primitive.Mutable.MVector ipv6 ipv7 ipv8 ->
                 (Data.Vector.Unboxed.Base.MV_3
                    @ s
                    @ GHC.Word.Word8
                    @ GHC.Types.Int
                    @ GHC.Types.Int
                    dt2
                    nt
                      `cast`
                    (Trans
                         (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0] <s>_N))
                         (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                        <s>_N))))
                    nt1
                      `cast`
                    (Trans
                         (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0] <s>_N))
                         (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0] <s>_N))))
                    nt2
                      `cast`
                    (Trans
                         (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0] <s>_N))
                         (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                        <s>_N)))))
                   `cast`
                 (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,,)[0]
                                <s>_N
                                <GHC.Word.Word8>_N
                                <GHC.Types.Int>_N
                                <GHC.Types.Int>_N))) } } } } })
                  `cast`
                (forall s.
                 <GHC.Types.Int>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R <Data.Vector.Unboxed.Base.MVector s MoveTypes.Move>_R
                 ->_R Trans
                          (Sym (MoveTypes.NTCo:R:MVectorsMove[0] <s>_N))
                          (Sub (Sym (MoveTypes.TFCo:R:MVectorsMove[0] <s>_N)))) -}
b13936b6226fe6ee038902e83e9bea5b
  $fMVectorMVectorMove_$cbasicUnsafeWrite ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Unboxed.Base.MVector
      (Control.Monad.Primitive.PrimState m) MoveTypes.Move
    -> GHC.Types.Int -> MoveTypes.Move -> m ()
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(SL),U(1*U,C(U))><S(LSSS),1*U(A,U(U,A,U),U(U,A,U),U(U,A,U))><L,U(U)><S,1*U(U,U,U)>,
     Inline: INLINE (sat-args=3),
     Unfolding: InlineRule (3, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   ds :: Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m) MoveTypes.Move
                   idx :: GHC.Types.Int
                   val :: MoveTypes.Move ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                 } in
                 case ds
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:MVectorsMove[0]
                                     <Control.Monad.Primitive.PrimState m>_N))
                           (Trans
                                (MoveTypes.NTCo:R:MVectorsMove[0]
                                     <Control.Monad.Primitive.PrimState m>_N)
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,,)[0]
                                          <Control.Monad.Primitive.PrimState m>_N
                                          <GHC.Word.Word8>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N)))) of wild { Data.Vector.Unboxed.Base.MV_3 dt as bs cs ->
                 case val of wild1 { MoveTypes.Move dt1 dt2 dt3 ->
                 GHC.Base.>>
                   @ m
                   $dMonad
                   @ ()
                   @ ()
                   (case as
                           `cast`
                         (Trans
                              (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                        <Control.Monad.Primitive.PrimState m>_N))
                              (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                   <Control.Monad.Primitive.PrimState
                                      m>_N)) of wild2 { Data.Vector.Primitive.Mutable.MVector dt4 dt5 dt6 ->
                    case GHC.Num.$fNumInt_$c+
                           (GHC.Types.I# dt4)
                           idx of wild3 { GHC.Types.I# i# ->
                    Control.Monad.Primitive.primitive
                      @ m
                      $dPrimMonad
                      @ ()
                      (\ s# :: GHC.Prim.State#
                                 (Control.Monad.Primitive.PrimState m)[OneShot] ->
                       case GHC.Prim.writeWord8Array#
                              @ (Control.Monad.Primitive.PrimState m)
                              dt6
                              i#
                              dt1
                              s# of s'# { DEFAULT ->
                       (# s'#, GHC.Tuple.() #) }) } })
                   (GHC.Base.>>
                      @ m
                      $dMonad
                      @ ()
                      @ ()
                      (case bs
                              `cast`
                            (Trans
                                 (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                           <Control.Monad.Primitive.PrimState m>_N))
                                 (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                      <Control.Monad.Primitive.PrimState
                                         m>_N)) of wild2 { Data.Vector.Primitive.Mutable.MVector dt4 dt5 dt6 ->
                       case GHC.Num.$fNumInt_$c+
                              (GHC.Types.I# dt4)
                              idx of wild3 { GHC.Types.I# i# ->
                       Control.Monad.Primitive.primitive
                         @ m
                         $dPrimMonad
                         @ ()
                         (\ s# :: GHC.Prim.State#
                                    (Control.Monad.Primitive.PrimState m)[OneShot] ->
                          case GHC.Prim.writeIntArray#
                                 @ (Control.Monad.Primitive.PrimState m)
                                 dt6
                                 i#
                                 dt2
                                 s# of s'# { DEFAULT ->
                          (# s'#, GHC.Tuple.() #) }) } })
                      (case cs
                              `cast`
                            (Trans
                                 (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                           <Control.Monad.Primitive.PrimState m>_N))
                                 (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                      <Control.Monad.Primitive.PrimState
                                         m>_N)) of wild2 { Data.Vector.Primitive.Mutable.MVector dt4 dt5 dt6 ->
                       case GHC.Num.$fNumInt_$c+
                              (GHC.Types.I# dt4)
                              idx of wild3 { GHC.Types.I# i# ->
                       Control.Monad.Primitive.primitive
                         @ m
                         $dPrimMonad
                         @ ()
                         (\ s# :: GHC.Prim.State#
                                    (Control.Monad.Primitive.PrimState m)[OneShot] ->
                          case GHC.Prim.writeIntArray#
                                 @ (Control.Monad.Primitive.PrimState m)
                                 dt6
                                 i#
                                 dt3
                                 s# of s'# { DEFAULT ->
                          (# s'#, GHC.Tuple.() #) }) } })) } }) -}
b13936b6226fe6ee038902e83e9bea5b
  $fShowMove :: GHC.Show.Show MoveTypes.Move
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ MoveTypes.Move
                  MoveTypes.$fShowMove_$s$dmshowsPrec
                  MoveTypes.$fShowMove_$cshow
                  MoveTypes.$fShowMove_$cshowList -}
b13936b6226fe6ee038902e83e9bea5b
  $fShowMove1 ::
    MoveTypes.Move -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2,
     Unfolding: (\ x :: MoveTypes.Move s :: GHC.Base.String[OneShot] ->
                 GHC.Base.++ @ GHC.Types.Char (MoveTypes.$fShowMove_$cshow x) s) -}
b13936b6226fe6ee038902e83e9bea5b
  $fShowMove_$cshow :: MoveTypes.Move -> GHC.Base.String
  {- Arity: 1, Strictness: <L,1*U(U,U,U)>,
     Unfolding: (\ x :: MoveTypes.Move ->
                 Text.PrettyPrint.ANSI.Leijen.displayS
                   (Text.PrettyPrint.ANSI.Leijen.renderFits
                      Text.PrettyPrint.ANSI.Leijen.fits1
                      Text.PrettyPrint.ANSI.Leijen.$fShowDoc3
                      Text.PrettyPrint.ANSI.Leijen.$fShowDoc2
                      (MoveTypes.moveToDoc x))
                   (GHC.Types.[] @ GHC.Types.Char)) -}
b13936b6226fe6ee038902e83e9bea5b
  $fShowMove_$cshowList :: [MoveTypes.Move] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: (\ ls :: [MoveTypes.Move] s :: GHC.Base.String ->
                 GHC.Show.showList__ @ MoveTypes.Move MoveTypes.$fShowMove1 ls s) -}
b13936b6226fe6ee038902e83e9bea5b
  $fShowMove_$s$dmshowsPrec ::
    GHC.Types.Int -> MoveTypes.Move -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><L,1*U(U,U,U)><L,1*U>,
     Unfolding: InlineRule (-1, True, False)
                (\ ds :: GHC.Types.Int x :: MoveTypes.Move s :: GHC.Base.String ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (MoveTypes.$fShowMove_$cshow x))
                   s) -}
b13936b6226fe6ee038902e83e9bea5b
  $fUnboxMove :: Data.Vector.Unboxed.Base.Unbox MoveTypes.Move
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ MoveTypes.Move
                  MoveTypes.$fVectorVectorMove
                  MoveTypes.$fMVectorMVectorMove -}
b13936b6226fe6ee038902e83e9bea5b
  $fVectorVectorMove ::
    Data.Vector.Generic.Base.Vector
      Data.Vector.Unboxed.Base.Vector MoveTypes.Move
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Vector.Unboxed.Base.Vector
                  @ MoveTypes.Move
                  MoveTypes.$fMVectorMVectorMove
                    `cast`
                  (Data.Vector.Generic.Mutable.Base.MVector
                     (Sym (Data.Vector.Unboxed.Base.TFCo:R:MutableVector[0]))
                     <MoveTypes.Move>_N)_R
                  MoveTypes.$fVectorVectorMove_$cbasicUnsafeFreeze
                  MoveTypes.$fVectorVectorMove_$cbasicUnsafeThaw
                  MoveTypes.$fVectorVectorMove_$cbasicLength
                  MoveTypes.$fVectorVectorMove_$cbasicUnsafeSlice
                  MoveTypes.$fVectorVectorMove_$cbasicUnsafeIndexM
                  MoveTypes.$fVectorVectorMove_$cbasicUnsafeCopy
                  MoveTypes.$fVectorVectorMove_$celemseq -}
b13936b6226fe6ee038902e83e9bea5b
  $fVectorVectorMove_$cbasicLength ::
    Data.Vector.Unboxed.Base.Vector MoveTypes.Move -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LSSS),1*U(U,1*H,1*H,1*H)>m,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ ds :: Data.Vector.Unboxed.Base.Vector MoveTypes.Move ->
                 case ds
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:VectorMove[0]))
                           (Trans
                                (MoveTypes.NTCo:R:VectorMove[0])
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:Vector(,,)[0]
                                          <GHC.Word.Word8>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N)))) of wild { Data.Vector.Unboxed.Base.V_3 dt ds1 ds2 ds3 ->
                 GHC.Types.I# dt }) -}
b13936b6226fe6ee038902e83e9bea5b
  $fVectorVectorMove_$cbasicUnsafeCopy ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Generic.Base.Mutable
      Data.Vector.Unboxed.Base.Vector
      (Control.Monad.Primitive.PrimState m)
      MoveTypes.Move
    -> Data.Vector.Unboxed.Base.Vector MoveTypes.Move -> m ()
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(SL),U(1*U,C(U))><S(LSSS),1*U(A,U(U,U,U),U(U,U,U),U(U,U,U))><S(LSSS),1*U(A,U(U,A,U),U(U,A,U),U(U,A,U))>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   ds :: Data.Vector.Generic.Base.Mutable
                           Data.Vector.Unboxed.Base.Vector
                           (Control.Monad.Primitive.PrimState m)
                           MoveTypes.Move
                   ds1 :: Data.Vector.Unboxed.Base.Vector MoveTypes.Move ->
                 let {
                   $dMonad :: GHC.Base.Monad m
                   = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                 } in
                 case ds
                        `cast`
                      (Trans
                           (Sub (Data.Vector.Unboxed.Base.TFCo:R:MutableVector[0]) <Control.Monad.Primitive.PrimState
                                                                                      m>_N <MoveTypes.Move>_N)
                           (Trans
                                (Sub (MoveTypes.TFCo:R:MVectorsMove[0]
                                          <Control.Monad.Primitive.PrimState m>_N))
                                (Trans
                                     (MoveTypes.NTCo:R:MVectorsMove[0]
                                          <Control.Monad.Primitive.PrimState m>_N)
                                     (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,,)[0]
                                               <Control.Monad.Primitive.PrimState m>_N
                                               <GHC.Word.Word8>_N
                                               <GHC.Types.Int>_N
                                               <GHC.Types.Int>_N))))) of wild { Data.Vector.Unboxed.Base.MV_3 dt as1 bs1 cs1 ->
                 case ds1
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:VectorMove[0]))
                           (Trans
                                (MoveTypes.NTCo:R:VectorMove[0])
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:Vector(,,)[0]
                                          <GHC.Word.Word8>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N)))) of wild1 { Data.Vector.Unboxed.Base.V_3 dt1 as2 bs2 cs2 ->
                 GHC.Base.>>
                   @ m
                   $dMonad
                   @ ()
                   @ ()
                   (Data.Vector.Unboxed.Base.$fVectorVectorWord8_$cbasicUnsafeCopy
                      @ m
                      $dPrimMonad
                      as1
                        `cast`
                      (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MutableVector[0])) <Control.Monad.Primitive.PrimState
                                                                                       m>_N <GHC.Word.Word8>_N)
                      as2)
                   (GHC.Base.>>
                      @ m
                      $dMonad
                      @ ()
                      @ ()
                      (Data.Vector.Unboxed.Base.$fVectorVectorInt_$cbasicUnsafeCopy
                         @ m
                         $dPrimMonad
                         bs1
                           `cast`
                         (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MutableVector[0])) <Control.Monad.Primitive.PrimState
                                                                                          m>_N <GHC.Types.Int>_N)
                         bs2)
                      (Data.Vector.Unboxed.Base.$fVectorVectorInt_$cbasicUnsafeCopy
                         @ m
                         $dPrimMonad
                         cs1
                           `cast`
                         (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MutableVector[0])) <Control.Monad.Primitive.PrimState
                                                                                          m>_N <GHC.Types.Int>_N)
                         cs2)) } }) -}
b13936b6226fe6ee038902e83e9bea5b
  $fVectorVectorMove_$cbasicUnsafeFreeze ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Generic.Base.Mutable
      Data.Vector.Unboxed.Base.Vector
      (Control.Monad.Primitive.PrimState m)
      MoveTypes.Move
    -> m (Data.Vector.Unboxed.Base.Vector MoveTypes.Move)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),U(U,C(U))><L,1*U(U,U(U,U,U),U(U,U,U),U(U,U,U))>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   eta :: Data.Vector.Generic.Base.Mutable
                            Data.Vector.Unboxed.Base.Vector
                            (Control.Monad.Primitive.PrimState m)
                            MoveTypes.Move ->
                 GHC.Base.liftM
                   @ (Data.Vector.Unboxed.Base.Vector
                        (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int))
                   @ (Data.Vector.Unboxed.Base.Vector MoveTypes.Move)
                   @ m
                   (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                   (\ tpl :: Data.Vector.Unboxed.Base.Vector
                               (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int) ->
                    tpl)
                     `cast`
                   (<Data.Vector.Unboxed.Base.Vector
                       (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int)>_R
                    ->_R Trans
                             (Sym (MoveTypes.NTCo:R:VectorMove[0]))
                             (Sub (Sym (MoveTypes.TFCo:R:VectorMove[0]))))
                   (let {
                      $dMonad :: GHC.Base.Monad m
                      = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                    } in
                    case eta
                           `cast`
                         (Trans
                              (Sub (Data.Vector.Unboxed.Base.TFCo:R:MutableVector[0]) <Control.Monad.Primitive.PrimState
                                                                                         m>_N <MoveTypes.Move>_N)
                              (Trans
                                   (Sub (MoveTypes.TFCo:R:MVectorsMove[0]
                                             <Control.Monad.Primitive.PrimState m>_N))
                                   (Trans
                                        (MoveTypes.NTCo:R:MVectorsMove[0]
                                             <Control.Monad.Primitive.PrimState m>_N)
                                        (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,,)[0]
                                                  <Control.Monad.Primitive.PrimState m>_N
                                                  <GHC.Word.Word8>_N
                                                  <GHC.Types.Int>_N
                                                  <GHC.Types.Int>_N))))) of wild { Data.Vector.Unboxed.Base.MV_3 dt as bs cs ->
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (Data.Vector.Unboxed.Base.Vector GHC.Word.Word8)
                      @ (Data.Vector.Unboxed.Base.Vector
                           (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int))
                      (GHC.Base.liftM
                         @ (Data.Vector.Primitive.Vector GHC.Word.Word8)
                         @ (Data.Vector.Unboxed.Base.Vector GHC.Word.Word8)
                         @ m
                         (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                         (\ tpl :: Data.Vector.Primitive.Vector GHC.Word.Word8 -> tpl)
                           `cast`
                         (<Data.Vector.Primitive.Vector GHC.Word.Word8>_R
                          ->_R Trans
                                   (Sym (Data.Vector.Unboxed.Base.NTCo:R:VectorWord8[0]))
                                   (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:VectorWord8[0]))))
                         (case as
                                 `cast`
                               (Trans
                                    (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                              <Control.Monad.Primitive.PrimState m>_N))
                                    (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                         <Control.Monad.Primitive.PrimState
                                            m>_N)) of wild1 { Data.Vector.Primitive.Mutable.MVector dt1 dt2 dt3 ->
                          GHC.Base.liftM
                            @ Data.Primitive.ByteArray.ByteArray
                            @ (Data.Vector.Primitive.Vector GHC.Word.Word8)
                            @ m
                            (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                            (Data.Vector.Primitive.$WVector
                               @ GHC.Word.Word8
                               (GHC.Types.I# dt1)
                               (GHC.Types.I# dt2))
                            (Control.Monad.Primitive.primitive
                               @ m
                               $dPrimMonad
                               @ Data.Primitive.ByteArray.ByteArray
                               (\ s# :: GHC.Prim.State#
                                          (Control.Monad.Primitive.PrimState m)[OneShot] ->
                                case GHC.Prim.unsafeFreezeByteArray#
                                       @ (Control.Monad.Primitive.PrimState m)
                                       dt3
                                       s# of ds1 { (#,#) ipv ipv1 ->
                                (# ipv, Data.Primitive.ByteArray.ByteArray ipv1 #) })) }))
                      (\ as' :: Data.Vector.Unboxed.Base.Vector GHC.Word.Word8 ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (Data.Vector.Unboxed.Base.Vector GHC.Types.Int)
                         @ (Data.Vector.Unboxed.Base.Vector
                              (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int))
                         (GHC.Base.liftM
                            @ (Data.Vector.Primitive.Vector GHC.Types.Int)
                            @ (Data.Vector.Unboxed.Base.Vector GHC.Types.Int)
                            @ m
                            (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                            (\ tpl :: Data.Vector.Primitive.Vector GHC.Types.Int -> tpl)
                              `cast`
                            (<Data.Vector.Primitive.Vector GHC.Types.Int>_R
                             ->_R Trans
                                      (Sym (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0]))
                                      (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))))
                            (case bs
                                    `cast`
                                  (Trans
                                       (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                 <Control.Monad.Primitive.PrimState m>_N))
                                       (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                            <Control.Monad.Primitive.PrimState
                                               m>_N)) of wild1 { Data.Vector.Primitive.Mutable.MVector dt1 dt2 dt3 ->
                             GHC.Base.liftM
                               @ Data.Primitive.ByteArray.ByteArray
                               @ (Data.Vector.Primitive.Vector GHC.Types.Int)
                               @ m
                               (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                               (Data.Vector.Primitive.$WVector
                                  @ GHC.Types.Int
                                  (GHC.Types.I# dt1)
                                  (GHC.Types.I# dt2))
                               (Control.Monad.Primitive.primitive
                                  @ m
                                  $dPrimMonad
                                  @ Data.Primitive.ByteArray.ByteArray
                                  (\ s# :: GHC.Prim.State#
                                             (Control.Monad.Primitive.PrimState m)[OneShot] ->
                                   case GHC.Prim.unsafeFreezeByteArray#
                                          @ (Control.Monad.Primitive.PrimState m)
                                          dt3
                                          s# of ds1 { (#,#) ipv ipv1 ->
                                   (# ipv, Data.Primitive.ByteArray.ByteArray ipv1 #) })) }))
                         (\ bs' :: Data.Vector.Unboxed.Base.Vector GHC.Types.Int ->
                          GHC.Base.>>=
                            @ m
                            $dMonad
                            @ (Data.Vector.Unboxed.Base.Vector GHC.Types.Int)
                            @ (Data.Vector.Unboxed.Base.Vector
                                 (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int))
                            (GHC.Base.liftM
                               @ (Data.Vector.Primitive.Vector GHC.Types.Int)
                               @ (Data.Vector.Unboxed.Base.Vector GHC.Types.Int)
                               @ m
                               (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                               (\ tpl :: Data.Vector.Primitive.Vector GHC.Types.Int -> tpl)
                                 `cast`
                               (<Data.Vector.Primitive.Vector GHC.Types.Int>_R
                                ->_R Trans
                                         (Sym (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0]))
                                         (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))))
                               (case cs
                                       `cast`
                                     (Trans
                                          (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                    <Control.Monad.Primitive.PrimState m>_N))
                                          (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                               <Control.Monad.Primitive.PrimState
                                                  m>_N)) of wild1 { Data.Vector.Primitive.Mutable.MVector dt1 dt2 dt3 ->
                                GHC.Base.liftM
                                  @ Data.Primitive.ByteArray.ByteArray
                                  @ (Data.Vector.Primitive.Vector GHC.Types.Int)
                                  @ m
                                  (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                                  (Data.Vector.Primitive.$WVector
                                     @ GHC.Types.Int
                                     (GHC.Types.I# dt1)
                                     (GHC.Types.I# dt2))
                                  (Control.Monad.Primitive.primitive
                                     @ m
                                     $dPrimMonad
                                     @ Data.Primitive.ByteArray.ByteArray
                                     (\ s# :: GHC.Prim.State#
                                                (Control.Monad.Primitive.PrimState m)[OneShot] ->
                                      case GHC.Prim.unsafeFreezeByteArray#
                                             @ (Control.Monad.Primitive.PrimState m)
                                             dt3
                                             s# of ds1 { (#,#) ipv ipv1 ->
                                      (# ipv, Data.Primitive.ByteArray.ByteArray ipv1 #) })) }))
                            (\ cs' :: Data.Vector.Unboxed.Base.Vector GHC.Types.Int ->
                             GHC.Base.$
                               @ (Data.Vector.Unboxed.Base.Vector
                                    (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int))
                               @ (m (Data.Vector.Unboxed.Base.Vector
                                       (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int)))
                               (GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (Data.Vector.Unboxed.Base.Vector
                                       (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int)))
                               (case as'
                                       `cast`
                                     (Trans
                                          (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorWord8[0]))
                                          (Data.Vector.Unboxed.Base.NTCo:R:VectorWord8[0])) of nt { Data.Vector.Primitive.Vector ipv ipv1 ipv2 ->
                                case bs'
                                       `cast`
                                     (Trans
                                          (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))
                                          (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0])) of nt1 { Data.Vector.Primitive.Vector ipv3 ipv4 ipv5 ->
                                case cs'
                                       `cast`
                                     (Trans
                                          (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))
                                          (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0])) of nt2 { Data.Vector.Primitive.Vector ipv6 ipv7 ipv8 ->
                                (Data.Vector.Unboxed.Base.V_3
                                   @ GHC.Word.Word8
                                   @ GHC.Types.Int
                                   @ GHC.Types.Int
                                   dt
                                   nt
                                     `cast`
                                   (Trans
                                        (Sym (Data.Vector.Unboxed.Base.NTCo:R:VectorWord8[0]))
                                        (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:VectorWord8[0]))))
                                   nt1
                                     `cast`
                                   (Trans
                                        (Sym (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0]))
                                        (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))))
                                   nt2
                                     `cast`
                                   (Trans
                                        (Sym (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0]))
                                        (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0])))))
                                  `cast`
                                (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:Vector(,,)[0]
                                               <GHC.Word.Word8>_N
                                               <GHC.Types.Int>_N
                                               <GHC.Types.Int>_N))) } } })))) })) -}
b13936b6226fe6ee038902e83e9bea5b
  $fVectorVectorMove_$cbasicUnsafeIndexM ::
    GHC.Base.Monad m =>
    Data.Vector.Unboxed.Base.Vector MoveTypes.Move
    -> GHC.Types.Int -> m MoveTypes.Move
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLL),U(A,C(C1(U)),A,C(U),A)><L,1*U(A,U(U,A,U),U(U,A,U),U(U,A,U))><L,U(U)>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ (m :: * -> *)
                   $dMonad :: GHC.Base.Monad m
                   ds :: Data.Vector.Unboxed.Base.Vector MoveTypes.Move
                   idx :: GHC.Types.Int ->
                 GHC.Base.liftM
                   @ (GHC.Word.Word8, Index.Index, Index.Index)
                   @ MoveTypes.Move
                   @ m
                   $dMonad
                   (\ ds1 :: (GHC.Word.Word8, Index.Index, Index.Index) ->
                    case ds1 of wild { (,,) m1 f t ->
                    MoveTypes.$WMove
                      m1 `cast` (Sym (MoveTypes.NTCo:MoveData[0]))
                      f
                      t })
                   (case ds
                           `cast`
                         (Trans
                              (Sub (MoveTypes.TFCo:R:VectorMove[0]))
                              (Trans
                                   (MoveTypes.NTCo:R:VectorMove[0])
                                   (Sub (Data.Vector.Unboxed.Base.TFCo:R:Vector(,,)[0]
                                             <GHC.Word.Word8>_N
                                             <GHC.Types.Int>_N
                                             <GHC.Types.Int>_N)))) of wild { Data.Vector.Unboxed.Base.V_3 dt as bs cs ->
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ GHC.Word.Word8
                      @ (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int)
                      (case as
                              `cast`
                            (Trans
                                 (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorWord8[0]))
                                 (Data.Vector.Unboxed.Base.NTCo:R:VectorWord8[0])) of wild1 { Data.Vector.Primitive.Vector dt1 dt2 dt3 ->
                       case GHC.Num.$fNumInt_$c+
                              (GHC.Types.I# dt1)
                              idx of wild2 { GHC.Types.I# i# ->
                       case GHC.Prim.indexWord8Array# dt3 i# of wild3 { DEFAULT ->
                       GHC.Base.$!
                         @ GHC.Word.Word8
                         @ (m GHC.Word.Word8)
                         (GHC.Base.return @ m $dMonad @ GHC.Word.Word8)
                         (GHC.Word.W8# wild3) } } })
                      (\ a21 :: GHC.Word.Word8 ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ GHC.Types.Int
                         @ (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int)
                         (case bs
                                 `cast`
                               (Trans
                                    (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))
                                    (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0])) of wild1 { Data.Vector.Primitive.Vector dt1 dt2 dt3 ->
                          case GHC.Num.$fNumInt_$c+
                                 (GHC.Types.I# dt1)
                                 idx of wild2 { GHC.Types.I# i# ->
                          case GHC.Prim.indexIntArray# dt3 i# of wild3 { DEFAULT ->
                          GHC.Base.$!
                            @ GHC.Types.Int
                            @ (m GHC.Types.Int)
                            (GHC.Base.return @ m $dMonad @ GHC.Types.Int)
                            (GHC.Types.I# wild3) } } })
                         (\ b1 :: GHC.Types.Int ->
                          GHC.Base.>>=
                            @ m
                            $dMonad
                            @ GHC.Types.Int
                            @ (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int)
                            (case cs
                                    `cast`
                                  (Trans
                                       (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))
                                       (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0])) of wild1 { Data.Vector.Primitive.Vector dt1 dt2 dt3 ->
                             case GHC.Num.$fNumInt_$c+
                                    (GHC.Types.I# dt1)
                                    idx of wild2 { GHC.Types.I# i# ->
                             case GHC.Prim.indexIntArray# dt3 i# of wild3 { DEFAULT ->
                             GHC.Base.$!
                               @ GHC.Types.Int
                               @ (m GHC.Types.Int)
                               (GHC.Base.return @ m $dMonad @ GHC.Types.Int)
                               (GHC.Types.I# wild3) } } })
                            (\ c1 :: GHC.Types.Int ->
                             GHC.Base.return
                               @ m
                               $dMonad
                               @ (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int)
                               (a21, b1, c1)))) })) -}
b13936b6226fe6ee038902e83e9bea5b
  $fVectorVectorMove_$cbasicUnsafeSlice ::
    GHC.Types.Int
    -> GHC.Types.Int
    -> Data.Vector.Unboxed.Base.Vector MoveTypes.Move
    -> Data.Vector.Unboxed.Base.Vector MoveTypes.Move
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,1*U(U)><S,1*U(U)><S(LSSS),1*U(A,U(U,A,U),U(U,A,U),U(U,A,U))>m,
     Inline: INLINE (sat-args=3),
     Unfolding: InlineRule (3, False, False)
                (\ idx :: GHC.Types.Int
                   len :: GHC.Types.Int
                   ds :: Data.Vector.Unboxed.Base.Vector MoveTypes.Move ->
                 case ds
                        `cast`
                      (Trans
                           (Sub (MoveTypes.TFCo:R:VectorMove[0]))
                           (Trans
                                (MoveTypes.NTCo:R:VectorMove[0])
                                (Sub (Data.Vector.Unboxed.Base.TFCo:R:Vector(,,)[0]
                                          <GHC.Word.Word8>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N)))) of wild { Data.Vector.Unboxed.Base.V_3 dt as bs cs ->
                 case len of dt1 { GHC.Types.I# dt2 ->
                 case (GHC.Base.$
                         @ (Data.Vector.Primitive.Vector GHC.Word.Word8)
                         @ (Data.Vector.Unboxed.Base.Vector GHC.Word.Word8)
                         (\ tpl :: Data.Vector.Primitive.Vector GHC.Word.Word8 -> tpl)
                           `cast`
                         (<Data.Vector.Primitive.Vector GHC.Word.Word8>_R
                          ->_R Trans
                                   (Sym (Data.Vector.Unboxed.Base.NTCo:R:VectorWord8[0]))
                                   (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:VectorWord8[0]))))
                         (case as
                                 `cast`
                               (Trans
                                    (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorWord8[0]))
                                    (Data.Vector.Unboxed.Base.NTCo:R:VectorWord8[0])) of wild1 { Data.Vector.Primitive.Vector dt4 dt5 dt6 ->
                          case GHC.Num.$fNumInt_$c+
                                 (GHC.Types.I# dt4)
                                 idx of dt3 { GHC.Types.I# dt7 ->
                          Data.Vector.Primitive.Vector @ GHC.Word.Word8 dt7 dt2 dt6 } }))
                        `cast`
                      (Trans
                           (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorWord8[0]))
                           (Data.Vector.Unboxed.Base.NTCo:R:VectorWord8[0])) of nt { Data.Vector.Primitive.Vector ipv ipv1 ipv2 ->
                 case (GHC.Base.$
                         @ (Data.Vector.Primitive.Vector GHC.Types.Int)
                         @ (Data.Vector.Unboxed.Base.Vector GHC.Types.Int)
                         (\ tpl :: Data.Vector.Primitive.Vector GHC.Types.Int -> tpl)
                           `cast`
                         (<Data.Vector.Primitive.Vector GHC.Types.Int>_R
                          ->_R Trans
                                   (Sym (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0]))
                                   (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))))
                         (case bs
                                 `cast`
                               (Trans
                                    (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))
                                    (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0])) of wild1 { Data.Vector.Primitive.Vector dt4 dt5 dt6 ->
                          case GHC.Num.$fNumInt_$c+
                                 (GHC.Types.I# dt4)
                                 idx of dt3 { GHC.Types.I# dt7 ->
                          Data.Vector.Primitive.Vector @ GHC.Types.Int dt7 dt2 dt6 } }))
                        `cast`
                      (Trans
                           (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))
                           (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0])) of nt1 { Data.Vector.Primitive.Vector ipv3 ipv4 ipv5 ->
                 case (GHC.Base.$
                         @ (Data.Vector.Primitive.Vector GHC.Types.Int)
                         @ (Data.Vector.Unboxed.Base.Vector GHC.Types.Int)
                         (\ tpl :: Data.Vector.Primitive.Vector GHC.Types.Int -> tpl)
                           `cast`
                         (<Data.Vector.Primitive.Vector GHC.Types.Int>_R
                          ->_R Trans
                                   (Sym (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0]))
                                   (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))))
                         (case cs
                                 `cast`
                               (Trans
                                    (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))
                                    (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0])) of wild1 { Data.Vector.Primitive.Vector dt4 dt5 dt6 ->
                          case GHC.Num.$fNumInt_$c+
                                 (GHC.Types.I# dt4)
                                 idx of dt3 { GHC.Types.I# dt7 ->
                          Data.Vector.Primitive.Vector @ GHC.Types.Int dt7 dt2 dt6 } }))
                        `cast`
                      (Trans
                           (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))
                           (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0])) of nt2 { Data.Vector.Primitive.Vector ipv6 ipv7 ipv8 ->
                 (Data.Vector.Unboxed.Base.V_3
                    @ GHC.Word.Word8
                    @ GHC.Types.Int
                    @ GHC.Types.Int
                    dt2
                    nt
                      `cast`
                    (Trans
                         (Sym (Data.Vector.Unboxed.Base.NTCo:R:VectorWord8[0]))
                         (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:VectorWord8[0]))))
                    nt1
                      `cast`
                    (Trans
                         (Sym (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0]))
                         (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))))
                    nt2
                      `cast`
                    (Trans
                         (Sym (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0]))
                         (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0])))))
                   `cast`
                 (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:Vector(,,)[0]
                                <GHC.Word.Word8>_N
                                <GHC.Types.Int>_N
                                <GHC.Types.Int>_N))) } } } } })
                  `cast`
                (<GHC.Types.Int>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R <Data.Vector.Unboxed.Base.Vector MoveTypes.Move>_R
                 ->_R Trans
                          (Sym (MoveTypes.NTCo:R:VectorMove[0]))
                          (Sub (Sym (MoveTypes.TFCo:R:VectorMove[0])))) -}
b13936b6226fe6ee038902e83e9bea5b
  $fVectorVectorMove_$cbasicUnsafeThaw ::
    Control.Monad.Primitive.PrimMonad m =>
    Data.Vector.Unboxed.Base.Vector MoveTypes.Move
    -> m (Data.Vector.Generic.Base.Mutable
            Data.Vector.Unboxed.Base.Vector
            (Control.Monad.Primitive.PrimState m)
            MoveTypes.Move)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),U(U,C(U))><L,1*U(U,U(U,U,U),U(U,U,U),U(U,U,U))>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ (m :: * -> *)
                   $dPrimMonad :: Control.Monad.Primitive.PrimMonad m
                   eta :: Data.Vector.Unboxed.Base.Vector MoveTypes.Move ->
                 GHC.Base.liftM
                   @ (Data.Vector.Unboxed.Base.MVector
                        (Control.Monad.Primitive.PrimState m)
                        (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int))
                   @ (Data.Vector.Unboxed.Base.MVector
                        (Control.Monad.Primitive.PrimState m) MoveTypes.Move)
                   @ m
                   (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                   (\ tpl :: Data.Vector.Unboxed.Base.MVector
                               (Control.Monad.Primitive.PrimState m)
                               (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int) ->
                    tpl)
                     `cast`
                   (<Data.Vector.Unboxed.Base.MVector
                       (Control.Monad.Primitive.PrimState m)
                       (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int)>_R
                    ->_R Trans
                             (Sym (MoveTypes.NTCo:R:MVectorsMove[0]
                                       <Control.Monad.Primitive.PrimState m>_N))
                             (Sub (Sym (MoveTypes.TFCo:R:MVectorsMove[0]
                                            <Control.Monad.Primitive.PrimState m>_N))))
                   (let {
                      $dMonad :: GHC.Base.Monad m
                      = Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad
                    } in
                    case eta
                           `cast`
                         (Trans
                              (Sub (MoveTypes.TFCo:R:VectorMove[0]))
                              (Trans
                                   (MoveTypes.NTCo:R:VectorMove[0])
                                   (Sub (Data.Vector.Unboxed.Base.TFCo:R:Vector(,,)[0]
                                             <GHC.Word.Word8>_N
                                             <GHC.Types.Int>_N
                                             <GHC.Types.Int>_N)))) of wild { Data.Vector.Unboxed.Base.V_3 dt as bs cs ->
                    GHC.Base.>>=
                      @ m
                      $dMonad
                      @ (Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                      @ (Data.Vector.Unboxed.Base.MVector
                           (Control.Monad.Primitive.PrimState m)
                           (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int))
                      (GHC.Base.liftM
                         @ (Data.Vector.Primitive.Mutable.MVector
                              (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                         @ (Data.Vector.Unboxed.Base.MVector
                              (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                         @ m
                         (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                         (\ tpl :: Data.Vector.Primitive.Mutable.MVector
                                     (Control.Monad.Primitive.PrimState m) GHC.Word.Word8 ->
                          tpl)
                           `cast`
                         (<Data.Vector.Primitive.Mutable.MVector
                             (Control.Monad.Primitive.PrimState m) GHC.Word.Word8>_R
                          ->_R Trans
                                   (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                             <Control.Monad.Primitive.PrimState m>_N))
                                   (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                                  <Control.Monad.Primitive.PrimState m>_N))))
                         (case as
                                 `cast`
                               (Trans
                                    (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorWord8[0]))
                                    (Data.Vector.Unboxed.Base.NTCo:R:VectorWord8[0])) of wild1 { Data.Vector.Primitive.Vector dt1 dt2 dt3 ->
                          GHC.Base.liftM
                            @ (Data.Primitive.ByteArray.MutableByteArray
                                 (Control.Monad.Primitive.PrimState m))
                            @ (Data.Vector.Primitive.Mutable.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Word.Word8)
                            @ m
                            (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                            (Data.Vector.Primitive.Mutable.$WMVector
                               @ (Control.Monad.Primitive.PrimState m)
                               @ GHC.Word.Word8
                               (GHC.Types.I# dt1)
                               (GHC.Types.I# dt2))
                            (Control.Monad.Primitive.primitive
                               @ m
                               $dPrimMonad
                               @ (Data.Primitive.ByteArray.MutableByteArray
                                    (Control.Monad.Primitive.PrimState m))
                               (\ s# :: GHC.Prim.State#
                                          (Control.Monad.Primitive.PrimState m)[OneShot] ->
                                (# s#,
                                   Data.Primitive.ByteArray.MutableByteArray
                                     @ (Control.Monad.Primitive.PrimState m)
                                     dt3
                                       `cast`
                                     (UnivCo mkUnsafeCo representational GHC.Prim.ByteArray# (GHC.Prim.MutableByteArray#
                                                                                                (Control.Monad.Primitive.PrimState
                                                                                                   m))) #))) }))
                      (\ as' :: Data.Vector.Unboxed.Base.MVector
                                  (Control.Monad.Primitive.PrimState m) GHC.Word.Word8 ->
                       GHC.Base.>>=
                         @ m
                         $dMonad
                         @ (Data.Vector.Unboxed.Base.MVector
                              (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                         @ (Data.Vector.Unboxed.Base.MVector
                              (Control.Monad.Primitive.PrimState m)
                              (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int))
                         (GHC.Base.liftM
                            @ (Data.Vector.Primitive.Mutable.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                            @ (Data.Vector.Unboxed.Base.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                            @ m
                            (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                            (\ tpl :: Data.Vector.Primitive.Mutable.MVector
                                        (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                             tpl)
                              `cast`
                            (<Data.Vector.Primitive.Mutable.MVector
                                (Control.Monad.Primitive.PrimState m) GHC.Types.Int>_R
                             ->_R Trans
                                      (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                                <Control.Monad.Primitive.PrimState m>_N))
                                      (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                     <Control.Monad.Primitive.PrimState m>_N))))
                            (case bs
                                    `cast`
                                  (Trans
                                       (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))
                                       (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0])) of wild1 { Data.Vector.Primitive.Vector dt1 dt2 dt3 ->
                             GHC.Base.liftM
                               @ (Data.Primitive.ByteArray.MutableByteArray
                                    (Control.Monad.Primitive.PrimState m))
                               @ (Data.Vector.Primitive.Mutable.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                               @ m
                               (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                               (Data.Vector.Primitive.Mutable.$WMVector
                                  @ (Control.Monad.Primitive.PrimState m)
                                  @ GHC.Types.Int
                                  (GHC.Types.I# dt1)
                                  (GHC.Types.I# dt2))
                               (Control.Monad.Primitive.primitive
                                  @ m
                                  $dPrimMonad
                                  @ (Data.Primitive.ByteArray.MutableByteArray
                                       (Control.Monad.Primitive.PrimState m))
                                  (\ s# :: GHC.Prim.State#
                                             (Control.Monad.Primitive.PrimState m)[OneShot] ->
                                   (# s#,
                                      Data.Primitive.ByteArray.MutableByteArray
                                        @ (Control.Monad.Primitive.PrimState m)
                                        dt3
                                          `cast`
                                        (UnivCo mkUnsafeCo representational GHC.Prim.ByteArray# (GHC.Prim.MutableByteArray#
                                                                                                   (Control.Monad.Primitive.PrimState
                                                                                                      m))) #))) }))
                         (\ bs' :: Data.Vector.Unboxed.Base.MVector
                                     (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                          GHC.Base.>>=
                            @ m
                            $dMonad
                            @ (Data.Vector.Unboxed.Base.MVector
                                 (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                            @ (Data.Vector.Unboxed.Base.MVector
                                 (Control.Monad.Primitive.PrimState m)
                                 (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int))
                            (GHC.Base.liftM
                               @ (Data.Vector.Primitive.Mutable.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                               @ (Data.Vector.Unboxed.Base.MVector
                                    (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                               @ m
                               (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                               (\ tpl :: Data.Vector.Primitive.Mutable.MVector
                                           (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                                tpl)
                                 `cast`
                               (<Data.Vector.Primitive.Mutable.MVector
                                   (Control.Monad.Primitive.PrimState m) GHC.Types.Int>_R
                                ->_R Trans
                                         (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                                   <Control.Monad.Primitive.PrimState m>_N))
                                         (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                        <Control.Monad.Primitive.PrimState m>_N))))
                               (case cs
                                       `cast`
                                     (Trans
                                          (Sub (Data.Vector.Unboxed.Base.TFCo:R:VectorInt[0]))
                                          (Data.Vector.Unboxed.Base.NTCo:R:VectorInt[0])) of wild1 { Data.Vector.Primitive.Vector dt1 dt2 dt3 ->
                                GHC.Base.liftM
                                  @ (Data.Primitive.ByteArray.MutableByteArray
                                       (Control.Monad.Primitive.PrimState m))
                                  @ (Data.Vector.Primitive.Mutable.MVector
                                       (Control.Monad.Primitive.PrimState m) GHC.Types.Int)
                                  @ m
                                  (Control.Monad.Primitive.$p1PrimMonad @ m $dPrimMonad)
                                  (Data.Vector.Primitive.Mutable.$WMVector
                                     @ (Control.Monad.Primitive.PrimState m)
                                     @ GHC.Types.Int
                                     (GHC.Types.I# dt1)
                                     (GHC.Types.I# dt2))
                                  (Control.Monad.Primitive.primitive
                                     @ m
                                     $dPrimMonad
                                     @ (Data.Primitive.ByteArray.MutableByteArray
                                          (Control.Monad.Primitive.PrimState m))
                                     (\ s# :: GHC.Prim.State#
                                                (Control.Monad.Primitive.PrimState m)[OneShot] ->
                                      (# s#,
                                         Data.Primitive.ByteArray.MutableByteArray
                                           @ (Control.Monad.Primitive.PrimState m)
                                           dt3
                                             `cast`
                                           (UnivCo mkUnsafeCo representational GHC.Prim.ByteArray# (GHC.Prim.MutableByteArray#
                                                                                                      (Control.Monad.Primitive.PrimState
                                                                                                         m))) #))) }))
                            (\ cs' :: Data.Vector.Unboxed.Base.MVector
                                        (Control.Monad.Primitive.PrimState m) GHC.Types.Int ->
                             GHC.Base.$
                               @ (Data.Vector.Unboxed.Base.MVector
                                    (Control.Monad.Primitive.PrimState m)
                                    (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int))
                               @ (m (Data.Vector.Unboxed.Base.MVector
                                       (Control.Monad.Primitive.PrimState m)
                                       (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int)))
                               (GHC.Base.return
                                  @ m
                                  $dMonad
                                  @ (Data.Vector.Unboxed.Base.MVector
                                       (Control.Monad.Primitive.PrimState m)
                                       (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int)))
                               (case as'
                                       `cast`
                                     (Trans
                                          (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                                    <Control.Monad.Primitive.PrimState m>_N))
                                          (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                               <Control.Monad.Primitive.PrimState
                                                  m>_N)) of nt { Data.Vector.Primitive.Mutable.MVector ipv ipv1 ipv2 ->
                                case bs'
                                       `cast`
                                     (Trans
                                          (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                    <Control.Monad.Primitive.PrimState m>_N))
                                          (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                               <Control.Monad.Primitive.PrimState
                                                  m>_N)) of nt1 { Data.Vector.Primitive.Mutable.MVector ipv3 ipv4 ipv5 ->
                                case cs'
                                       `cast`
                                     (Trans
                                          (Sub (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                    <Control.Monad.Primitive.PrimState m>_N))
                                          (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                               <Control.Monad.Primitive.PrimState
                                                  m>_N)) of nt2 { Data.Vector.Primitive.Mutable.MVector ipv6 ipv7 ipv8 ->
                                (Data.Vector.Unboxed.Base.MV_3
                                   @ (Control.Monad.Primitive.PrimState m)
                                   @ GHC.Word.Word8
                                   @ GHC.Types.Int
                                   @ GHC.Types.Int
                                   dt
                                   nt
                                     `cast`
                                   (Trans
                                        (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsWord8[0]
                                                  <Control.Monad.Primitive.PrimState m>_N))
                                        (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsWord8[0]
                                                       <Control.Monad.Primitive.PrimState m>_N))))
                                   nt1
                                     `cast`
                                   (Trans
                                        (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                                  <Control.Monad.Primitive.PrimState m>_N))
                                        (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                       <Control.Monad.Primitive.PrimState m>_N))))
                                   nt2
                                     `cast`
                                   (Trans
                                        (Sym (Data.Vector.Unboxed.Base.NTCo:R:MVectorsInt[0]
                                                  <Control.Monad.Primitive.PrimState m>_N))
                                        (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectorsInt[0]
                                                       <Control.Monad.Primitive.PrimState m>_N)))))
                                  `cast`
                                (Sub (Sym (Data.Vector.Unboxed.Base.TFCo:R:MVectors(,,)[0]
                                               <Control.Monad.Primitive.PrimState m>_N
                                               <GHC.Word.Word8>_N
                                               <GHC.Types.Int>_N
                                               <GHC.Types.Int>_N))) } } })))) }))
                  `cast`
                (forall (m :: * -> *).
                 <Control.Monad.Primitive.PrimMonad m>_R
                 ->_R <Data.Vector.Unboxed.Base.Vector MoveTypes.Move>_R
                 ->_R <m>_R (Sym (Data.Vector.Unboxed.Base.TFCo:R:MutableVector[0]) <Control.Monad.Primitive.PrimState
                                                                                       m>_N <MoveTypes.Move>_N)) -}
b13936b6226fe6ee038902e83e9bea5b
  $fVectorVectorMove_$celemseq ::
    Data.Vector.Unboxed.Base.Vector MoveTypes.Move
    -> MoveTypes.Move -> b -> b
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><S,1*H><S,1*U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ b
                   ds :: Data.Vector.Unboxed.Base.Vector MoveTypes.Move
                   val :: MoveTypes.Move ->
                 case val of wild { MoveTypes.Move dt dt1 dt2 ->
                 let {
                   f :: b -> b = GHC.Prim.seq @ GHC.Word.Word8 @ b (GHC.Word.W8# dt)
                 } in
                 let {
                   f1 :: b -> b = GHC.Prim.seq @ GHC.Types.Int @ b (GHC.Types.I# dt1)
                 } in
                 let {
                   g :: b -> b = GHC.Prim.seq @ GHC.Types.Int @ b (GHC.Types.I# dt2)
                 } in
                 \ x :: b -> f (f1 (g x)) }) -}
74d448f47e08de141a084d80256e05c0
  $mBishopM ::
    MoveTypes.MoveData
    -> (GHC.Prim.Void# -> r) -> (GHC.Prim.Void# -> r) -> r
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><L,1*C1(U)><L,1*C1(U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (r :: OpenKind)
                   scrut :: MoveTypes.MoveData
                   cont :: GHC.Prim.Void# -> r
                   fail :: GHC.Prim.Void# -> r ->
                 case scrut
                        `cast`
                      (MoveTypes.NTCo:MoveData[0]) of wild { GHC.Word.W8# a4 ->
                 case a4 of wild1 {
                   DEFAULT -> fail GHC.Prim.void#
                   __word 5 -> cont GHC.Prim.void# } }) -}
51ce39eca45e6465d246e2bce97af087
  $mBishopP ::
    MoveTypes.MoveData
    -> (GHC.Prim.Void# -> r) -> (GHC.Prim.Void# -> r) -> r
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><L,1*C1(U)><L,1*C1(U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (r :: OpenKind)
                   scrut :: MoveTypes.MoveData
                   cont :: GHC.Prim.Void# -> r
                   fail :: GHC.Prim.Void# -> r ->
                 case scrut
                        `cast`
                      (MoveTypes.NTCo:MoveData[0]) of wild { GHC.Word.W8# a4 ->
                 case a4 of wild1 {
                   DEFAULT -> fail GHC.Prim.void#
                   __word 12 -> cont GHC.Prim.void# } }) -}
fdc5184b841ef1dcb2719aef101fe39e
  $mCastleL ::
    MoveTypes.MoveData
    -> (GHC.Prim.Void# -> r) -> (GHC.Prim.Void# -> r) -> r
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><L,1*C1(U)><L,1*C1(U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (r :: OpenKind)
                   scrut :: MoveTypes.MoveData
                   cont :: GHC.Prim.Void# -> r
                   fail :: GHC.Prim.Void# -> r ->
                 case scrut
                        `cast`
                      (MoveTypes.NTCo:MoveData[0]) of wild { GHC.Word.W8# a4 ->
                 case a4 of wild1 {
                   DEFAULT -> fail GHC.Prim.void#
                   __word 9 -> cont GHC.Prim.void# } }) -}
1892192b7dd64fc2ab1ef4c5ed1a5939
  $mCastleR ::
    MoveTypes.MoveData
    -> (GHC.Prim.Void# -> r) -> (GHC.Prim.Void# -> r) -> r
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><L,1*C1(U)><L,1*C1(U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (r :: OpenKind)
                   scrut :: MoveTypes.MoveData
                   cont :: GHC.Prim.Void# -> r
                   fail :: GHC.Prim.Void# -> r ->
                 case scrut
                        `cast`
                      (MoveTypes.NTCo:MoveData[0]) of wild { GHC.Word.W8# a4 ->
                 case a4 of wild1 {
                   DEFAULT -> fail GHC.Prim.void#
                   __word 10 -> cont GHC.Prim.void# } }) -}
636bb5590303192429a370b4e548b022
  $mDoublePush ::
    MoveTypes.MoveData
    -> (GHC.Prim.Void# -> r) -> (GHC.Prim.Void# -> r) -> r
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><L,1*C1(U)><L,1*C1(U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (r :: OpenKind)
                   scrut :: MoveTypes.MoveData
                   cont :: GHC.Prim.Void# -> r
                   fail :: GHC.Prim.Void# -> r ->
                 case scrut
                        `cast`
                      (MoveTypes.NTCo:MoveData[0]) of wild { GHC.Word.W8# a4 ->
                 case a4 of wild1 {
                   DEFAULT -> fail GHC.Prim.void#
                   __word 1 -> cont GHC.Prim.void# } }) -}
4fb69118bee1e144bccb4eabae194762
  $mEnPassantA ::
    MoveTypes.MoveData
    -> (GHC.Prim.Void# -> r) -> (GHC.Prim.Void# -> r) -> r
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><L,1*C1(U)><L,1*C1(U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (r :: OpenKind)
                   scrut :: MoveTypes.MoveData
                   cont :: GHC.Prim.Void# -> r
                   fail :: GHC.Prim.Void# -> r ->
                 case scrut
                        `cast`
                      (MoveTypes.NTCo:MoveData[0]) of wild { GHC.Word.W8# a4 ->
                 case a4 of wild1 {
                   DEFAULT -> fail GHC.Prim.void#
                   __word 3 -> cont GHC.Prim.void# } }) -}
53f3ccf27a4432fed011356d394a1d2f
  $mKingM ::
    MoveTypes.MoveData
    -> (GHC.Prim.Void# -> r) -> (GHC.Prim.Void# -> r) -> r
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><L,1*C1(U)><L,1*C1(U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (r :: OpenKind)
                   scrut :: MoveTypes.MoveData
                   cont :: GHC.Prim.Void# -> r
                   fail :: GHC.Prim.Void# -> r ->
                 case scrut
                        `cast`
                      (MoveTypes.NTCo:MoveData[0]) of wild { GHC.Word.W8# a4 ->
                 case a4 of wild1 {
                   DEFAULT -> fail GHC.Prim.void#
                   __word 8 -> cont GHC.Prim.void# } }) -}
b9098ec5690aaf1c2513a4281e158db6
  $mKnightM ::
    MoveTypes.MoveData
    -> (GHC.Prim.Void# -> r) -> (GHC.Prim.Void# -> r) -> r
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><L,1*C1(U)><L,1*C1(U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (r :: OpenKind)
                   scrut :: MoveTypes.MoveData
                   cont :: GHC.Prim.Void# -> r
                   fail :: GHC.Prim.Void# -> r ->
                 case scrut
                        `cast`
                      (MoveTypes.NTCo:MoveData[0]) of wild { GHC.Word.W8# a4 ->
                 case a4 of wild1 {
                   DEFAULT -> fail GHC.Prim.void#
                   __word 4 -> cont GHC.Prim.void# } }) -}
5de7322046334c272abbe209f2fe7cd6
  $mKnightP ::
    MoveTypes.MoveData
    -> (GHC.Prim.Void# -> r) -> (GHC.Prim.Void# -> r) -> r
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><L,1*C1(U)><L,1*C1(U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (r :: OpenKind)
                   scrut :: MoveTypes.MoveData
                   cont :: GHC.Prim.Void# -> r
                   fail :: GHC.Prim.Void# -> r ->
                 case scrut
                        `cast`
                      (MoveTypes.NTCo:MoveData[0]) of wild { GHC.Word.W8# a4 ->
                 case a4 of wild1 {
                   DEFAULT -> fail GHC.Prim.void#
                   __word 11 -> cont GHC.Prim.void# } }) -}
b4d650bf35bb970088fc9163ae55b594
  $mPawnA ::
    MoveTypes.MoveData
    -> (GHC.Prim.Void# -> r) -> (GHC.Prim.Void# -> r) -> r
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><L,1*C1(U)><L,1*C1(U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (r :: OpenKind)
                   scrut :: MoveTypes.MoveData
                   cont :: GHC.Prim.Void# -> r
                   fail :: GHC.Prim.Void# -> r ->
                 case scrut
                        `cast`
                      (MoveTypes.NTCo:MoveData[0]) of wild { GHC.Word.W8# a4 ->
                 case a4 of wild1 {
                   DEFAULT -> fail GHC.Prim.void#
                   __word 2 -> cont GHC.Prim.void# } }) -}
1546e5619f1d189d95a0707abfb0f31f
  $mQueenM ::
    MoveTypes.MoveData
    -> (GHC.Prim.Void# -> r) -> (GHC.Prim.Void# -> r) -> r
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><L,1*C1(U)><L,1*C1(U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (r :: OpenKind)
                   scrut :: MoveTypes.MoveData
                   cont :: GHC.Prim.Void# -> r
                   fail :: GHC.Prim.Void# -> r ->
                 case scrut
                        `cast`
                      (MoveTypes.NTCo:MoveData[0]) of wild { GHC.Word.W8# a4 ->
                 case a4 of wild1 {
                   DEFAULT -> fail GHC.Prim.void#
                   __word 7 -> cont GHC.Prim.void# } }) -}
83c3fc81dc15d975fe617c6d52dbedc4
  $mQueenP ::
    MoveTypes.MoveData
    -> (GHC.Prim.Void# -> r) -> (GHC.Prim.Void# -> r) -> r
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><L,1*C1(U)><L,1*C1(U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (r :: OpenKind)
                   scrut :: MoveTypes.MoveData
                   cont :: GHC.Prim.Void# -> r
                   fail :: GHC.Prim.Void# -> r ->
                 case scrut
                        `cast`
                      (MoveTypes.NTCo:MoveData[0]) of wild { GHC.Word.W8# a4 ->
                 case a4 of wild1 {
                   DEFAULT -> fail GHC.Prim.void#
                   __word 14 -> cont GHC.Prim.void# } }) -}
06edc2d430a7d37477b538ad5100035a
  $mRookM ::
    MoveTypes.MoveData
    -> (GHC.Prim.Void# -> r) -> (GHC.Prim.Void# -> r) -> r
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><L,1*C1(U)><L,1*C1(U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (r :: OpenKind)
                   scrut :: MoveTypes.MoveData
                   cont :: GHC.Prim.Void# -> r
                   fail :: GHC.Prim.Void# -> r ->
                 case scrut
                        `cast`
                      (MoveTypes.NTCo:MoveData[0]) of wild { GHC.Word.W8# a4 ->
                 case a4 of wild1 {
                   DEFAULT -> fail GHC.Prim.void#
                   __word 6 -> cont GHC.Prim.void# } }) -}
96b52280e26ccae05a5cd72d3c04212b
  $mRookP ::
    MoveTypes.MoveData
    -> (GHC.Prim.Void# -> r) -> (GHC.Prim.Void# -> r) -> r
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><L,1*C1(U)><L,1*C1(U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (r :: OpenKind)
                   scrut :: MoveTypes.MoveData
                   cont :: GHC.Prim.Void# -> r
                   fail :: GHC.Prim.Void# -> r ->
                 case scrut
                        `cast`
                      (MoveTypes.NTCo:MoveData[0]) of wild { GHC.Word.W8# a4 ->
                 case a4 of wild1 {
                   DEFAULT -> fail GHC.Prim.void#
                   __word 13 -> cont GHC.Prim.void# } }) -}
03a062ecb548e06f660f2f88790192c2
  $mSinglePush ::
    MoveTypes.MoveData
    -> (GHC.Prim.Void# -> r) -> (GHC.Prim.Void# -> r) -> r
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><L,1*C1(U)><L,1*C1(U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (r :: OpenKind)
                   scrut :: MoveTypes.MoveData
                   cont :: GHC.Prim.Void# -> r
                   fail :: GHC.Prim.Void# -> r ->
                 case scrut
                        `cast`
                      (MoveTypes.NTCo:MoveData[0]) of wild { GHC.Word.W8# a4 ->
                 case a4 of wild1 {
                   DEFAULT -> fail GHC.Prim.void#
                   __word 0 -> cont GHC.Prim.void# } }) -}
f61c990a7f2d0b8b3b6d35057648ecbd
  $wmoveToDoc ::
    GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> (# Text.PrettyPrint.ANSI.Leijen.Doc,
          Text.PrettyPrint.ANSI.Leijen.Doc #)
  {- Arity: 3, Strictness: <L,U><L,U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Word#
                   ww1 :: GHC.Prim.Int#
                   ww2 :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.leWord# ww __word 10) of wild {
                   GHC.Types.False
                   -> (# case Index.$windexToDoc
                                (GHC.Types.I# ww1) of ww3 { (#,#) ww4 ww5 ->
                         Text.PrettyPrint.ANSI.Leijen.Cat ww4 ww5 },
                         Text.PrettyPrint.ANSI.Leijen.Cat
                           (case Index.$windexToDoc
                                   (GHC.Types.I# ww2) of ww3 { (#,#) ww4 ww5 ->
                            Text.PrettyPrint.ANSI.Leijen.Cat ww4 ww5 })
                           (Text.PrettyPrint.ANSI.Leijen.Cat
                              MoveTypes.moveToDoc5
                              (case ww of wild1 {
                                 DEFAULT -> Text.PrettyPrint.ANSI.Leijen.Empty
                                 __word 11 -> MoveTypes.moveToDoc4
                                 __word 12 -> MoveTypes.moveToDoc3
                                 __word 13 -> MoveTypes.moveToDoc2
                                 __word 14 -> MoveTypes.moveToDoc1 })) #)
                   GHC.Types.True
                   -> (# case Index.$windexToDoc
                                (GHC.Types.I# ww1) of ww3 { (#,#) ww4 ww5 ->
                         Text.PrettyPrint.ANSI.Leijen.Cat ww4 ww5 },
                         case Index.$windexToDoc
                                (GHC.Types.I# ww2) of ww3 { (#,#) ww4 ww5 ->
                         Text.PrettyPrint.ANSI.Leijen.Cat ww4 ww5 } #) }) -}
44ba9656d441c2fa0a64a1e519410658
  pattern BishopM :: MoveTypes.MoveData
5f31ba7f05de2f39729150b4b676b7c0
  pattern BishopP :: MoveTypes.MoveData
925768585af665420a3eac15f4e5f25b
  pattern CastleL :: MoveTypes.MoveData
7e3be9961551360f4fbe72b94e1bba83
  pattern CastleR :: MoveTypes.MoveData
4f919ace8fcb628984f8f3be2de4df64
  pattern DoublePush :: MoveTypes.MoveData
0a98aa17fb6f4ce24e3182e86341db1f
  pattern EnPassantA :: MoveTypes.MoveData
2fcd72edc8098e89a3672dce93469314
  pattern KingM :: MoveTypes.MoveData
01671b71c82e508f0f62b9c6a394cfcf
  pattern KnightM :: MoveTypes.MoveData
2199eef6f4ff1ac4891d0a7954c11d03
  pattern KnightP :: MoveTypes.MoveData
b13936b6226fe6ee038902e83e9bea5b
  data Move
    = Move {metaData :: ! {-# UNPACK #-}(MoveTypes.NTCo:MoveData[0])MoveTypes.MoveData,
            from :: {-# UNPACK #-}Index.Index,
            to :: {-# UNPACK #-}Index.Index}
16c1819e512d6046846f2570c0139b5c
  newtype MoveData = MoveData GHC.Word.Word8
5961b9d8b781221e3276aa7c1c878959
  type Moves = Data.Vector.Unboxed.Base.Vector MoveTypes.Move
703eac96f15695a4347fc8ff7f322135
  pattern PawnA :: MoveTypes.MoveData
ea0b723194459abc337d9f3be5d1e2b4
  pattern QueenM :: MoveTypes.MoveData
b266227a34a955937dfa7b32c92fb621
  pattern QueenP :: MoveTypes.MoveData
b13936b6226fe6ee038902e83e9bea5b
  newtype instance Data.Vector.Unboxed.Base.MVector s0 MoveTypes.Move
    = MV_Move (Data.Vector.Unboxed.Base.MVector
                 s0 (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int))
    RecFlag: Recursive
b13936b6226fe6ee038902e83e9bea5b
  newtype instance Data.Vector.Unboxed.Base.Vector MoveTypes.Move
    = V_Move (Data.Vector.Unboxed.Base.Vector
                (GHC.Word.Word8, GHC.Types.Int, GHC.Types.Int))
    RecFlag: Recursive
0fca83847b73c8ba3ded7c9928871275
  pattern RookM :: MoveTypes.MoveData
264cc02d84b33651e27aaf00dc545927
  pattern RookP :: MoveTypes.MoveData
6d33059453b52242d93b63b296446b14
  pattern SinglePush :: MoveTypes.MoveData
b13936b6226fe6ee038902e83e9bea5b
  axiom TFCo:R:MVectorsMove::
      Data.Vector.Unboxed.Base.MVector s0 MoveTypes.Move
        = MoveTypes.R:MVectorsMove s0
b13936b6226fe6ee038902e83e9bea5b
  axiom TFCo:R:VectorMove::
      Data.Vector.Unboxed.Base.Vector MoveTypes.Move
        = MoveTypes.R:VectorMove
c3100ac9539dda6830e04128f2ec6c44
  from :: MoveTypes.Move -> Index.Index
  RecSel MoveTypes.Move
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(A,U,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: MoveTypes.Move ->
                 case ds of wild { MoveTypes.Move dt dt1 dt2 ->
                 GHC.Types.I# dt1 }) -}
539a79fb5a6e91d74bbcad500630a856
  metaData :: MoveTypes.Move -> MoveTypes.MoveData
  RecSel MoveTypes.Move
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: MoveTypes.Move ->
                 case ds of wild { MoveTypes.Move dt dt1 dt2 ->
                 (GHC.Word.W8# dt) `cast` (Sym (MoveTypes.NTCo:MoveData[0])) }) -}
b13936b6226fe6ee038902e83e9bea5b
  moveToDoc :: MoveTypes.Move -> Text.PrettyPrint.ANSI.Leijen.Doc
  {- Arity: 1, Strictness: <S,1*U(U,U,U)>m7, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: MoveTypes.Move ->
                 case w of ww { MoveTypes.Move ww1 ww2 ww3 ->
                 case MoveTypes.$wmoveToDoc ww1 ww2 ww3 of ww4 { (#,#) ww5 ww6 ->
                 Text.PrettyPrint.ANSI.Leijen.Cat ww5 ww6 } }) -}
e1297b43ac8f7c6d42a3a7931649a0be
  moveToDoc1 :: Text.PrettyPrint.ANSI.Leijen.Doc
  {- Unfolding: (case GHC.List.$wlenAcc
                        @ GHC.Types.Char
                        MoveTypes.moveToDoc_wild
                        0 of ww2 { DEFAULT ->
                 Text.PrettyPrint.ANSI.Leijen.Text
                   ww2
                   MoveTypes.moveToDoc_wild }) -}
10ad54304aec93db60bc1a0ec5251eea
  moveToDoc2 :: Text.PrettyPrint.ANSI.Leijen.Doc
  {- Unfolding: (case GHC.List.$wlenAcc
                        @ GHC.Types.Char
                        MoveTypes.moveToDoc_wild1
                        0 of ww2 { DEFAULT ->
                 Text.PrettyPrint.ANSI.Leijen.Text
                   ww2
                   MoveTypes.moveToDoc_wild1 }) -}
a9c916e722b2fe87196b2b3590e96898
  moveToDoc3 :: Text.PrettyPrint.ANSI.Leijen.Doc
  {- Unfolding: (case GHC.List.$wlenAcc
                        @ GHC.Types.Char
                        MoveTypes.moveToDoc_wild2
                        0 of ww2 { DEFAULT ->
                 Text.PrettyPrint.ANSI.Leijen.Text
                   ww2
                   MoveTypes.moveToDoc_wild2 }) -}
b6c8e22b4b5761085d4b7c713ae133c6
  moveToDoc4 :: Text.PrettyPrint.ANSI.Leijen.Doc
  {- Unfolding: (case GHC.List.$wlenAcc
                        @ GHC.Types.Char
                        MoveTypes.moveToDoc_wild3
                        0 of ww2 { DEFAULT ->
                 Text.PrettyPrint.ANSI.Leijen.Text
                   ww2
                   MoveTypes.moveToDoc_wild3 }) -}
5c853bdc3f6f1ae164991d7256edf181
  moveToDoc5 :: Text.PrettyPrint.ANSI.Leijen.Doc
  {- Unfolding: (case GHC.List.$wlenAcc
                        @ GHC.Types.Char
                        MoveTypes.moveToDoc_wild4
                        0 of ww2 { DEFAULT ->
                 Text.PrettyPrint.ANSI.Leijen.Text
                   ww2
                   MoveTypes.moveToDoc_wild4 }) -}
4a6d1a36d6235b41e30bd08bfadff75b
  moveToDoc_ipv :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# 'Q') -}
1f4507743672eca5887d2cc09b2695aa
  moveToDoc_ipv1 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# 'R') -}
62fd351fb979f9e4e546053677cfe0ef
  moveToDoc_ipv2 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# 'B') -}
cc114f6a35de1c7161a5daee3dcadaa3
  moveToDoc_ipv3 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# 'N') -}
76fed06e36f8661a55b56cfba993bcf7
  moveToDoc_ipv4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "="#) -}
8409eb44b114ac9707a25795c80991ef
  moveToDoc_ipv5 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# 'p') -}
a0c97d366c6b04bf93184b4e5a786665
  moveToDoc_wild :: [GHC.Types.Char]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   MoveTypes.moveToDoc_ipv
                   (GHC.Types.[] @ GHC.Types.Char)) -}
6ab677c581e09b6585d27f3198bb8fad
  moveToDoc_wild1 :: [GHC.Types.Char]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   MoveTypes.moveToDoc_ipv1
                   (GHC.Types.[] @ GHC.Types.Char)) -}
d180bc3607dd73b621c286bb7b249a40
  moveToDoc_wild2 :: [GHC.Types.Char]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   MoveTypes.moveToDoc_ipv2
                   (GHC.Types.[] @ GHC.Types.Char)) -}
c28d483704d164f4d64746899641a007
  moveToDoc_wild3 :: [GHC.Types.Char]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   MoveTypes.moveToDoc_ipv3
                   (GHC.Types.[] @ GHC.Types.Char)) -}
5485fc03320aa418c739d0972b7476f6
  moveToDoc_wild4 :: [GHC.Types.Char]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   MoveTypes.moveToDoc_ipv5
                   MoveTypes.moveToDoc_ipv4) -}
8b24805d03db8cc4bfdb3ba4ce4dcaf1
  to :: MoveTypes.Move -> Index.Index
  RecSel MoveTypes.Move
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(A,A,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: MoveTypes.Move ->
                 case ds of wild { MoveTypes.Move dt dt1 dt2 ->
                 GHC.Types.I# dt2 }) -}
instance Data.Vector.Generic.Mutable.Base.MVector [Data.Vector.Unboxed.Base.MVector,
                                                   MoveTypes.Move]
  = MoveTypes.$fMVectorMVectorMove
instance GHC.Show.Show [MoveTypes.Move] = MoveTypes.$fShowMove
instance Data.Vector.Unboxed.Base.Unbox [MoveTypes.Move]
  = MoveTypes.$fUnboxMove
instance Data.Vector.Generic.Base.Vector [Data.Vector.Unboxed.Base.Vector,
                                          MoveTypes.Move]
  = MoveTypes.$fVectorVectorMove
family instance Data.Vector.Unboxed.Base.MVector [.],
                                                 [MoveTypes.Move]
  = MoveTypes.TFCo:R:MVectorsMove
family instance Data.Vector.Unboxed.Base.Vector [MoveTypes.Move]
  = MoveTypes.TFCo:R:VectorMove
"SPEC/MoveTypes $dmshowsPrec @ Move" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                                 MoveTypes.Move
  GHC.Show.$dmshowsPrec @ MoveTypes.Move $dShow
  = MoveTypes.$fShowMove_$s$dmshowsPrec
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

